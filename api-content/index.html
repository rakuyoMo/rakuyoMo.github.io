{"posts":[{"title":"通过覆写方法看 Swift 方法派发","content":"在 Swift 开发中，我们常常利用 extension 和 // MARK: 来划分代码逻辑，比如划分出 “Config”、“Life cycle” 等模块。然而，在使用扩展时却常常会遇到方法覆写的问题，尤其是在定义基类的“框架方法”后，子类无法正确覆写的问题。 本文将通过覆写方法，深入探讨 Swift 中的方法派发机制，并讨论如何在代码设计时规避常见坑点。 本文基于 Swift 5 与 Xcode 16.2 编写。 何为 Swift 方法派发 首先，为不了解 “方法派发” 的读者做个简短的概念解释： 方法派发简单地讲，指的是在调用一个方法时，如何执行该方法的机制。也可以理解为 “去哪里找到该方法的实现” 的机制。 广义上说 Swift 的方法派发分以下两种： 派发类型 定义 底层机制 静态派发 在编译期就确定调用目标 直接内联调用，不参与虚函数表 动态派发 在运行时根据对象的实际类型确定调用目标 依赖虚函数表（vtable）或 Objective‑C 消息发送机制 方法覆写与方法派发 在很多项目中，我们会在基类中定义一些“框架方法”，由子类覆写这些方法来实现统一的代码结构。比如下面的类型： open class BaseCollectionViewCell: UICollectionViewCell { override public init(frame: CGRect) { super.init(frame: frame) config() } public required init?(coder: NSCoder) { super.init(coder: coder) config() } } extension BaseCollectionViewCell { open func config() { // ⚠️ Non-'@objc' instance method in extensions cannot be overridden; use 'public' instead addSubviews() addInitialLayout() } open func addSubviews() { } // ⚠️ Non-'@objc' instance method in extensions cannot be overridden; use 'public' instead open func addInitialLayout() { } // ⚠️ Non-'@objc' instance method in extensions cannot be overridden; use 'public' instead } config()、addSubviews() 和 addInitialLayout() 被我称为 “框架方法”，用来约束子类，统一管理某一类的代码。 写完方法后，Xcode 给了我们三个警告：Non-'@objc' instance method in extensions cannot be overridden; use 'public' instead。提示我们在 extension 中定义的非 @objc 方法不能被覆写的，所以我们使用的 open 是没有意义的，建议我们换成 public。 这是为什么呢？ Swift 中的方法覆写 我们先来了解一下 Swift 方法覆写的实现原理：在 Swift 中，方法覆写本质上是依赖 “动态派发机制” 来实现的。 对于一个纯 Swift 类而言，在类的主要声明部分定义的方法会被加入到虚函数表（vtable table）中。这意味着在运行时，根据对象的实际类型可以找到正确的实现，从而支持子类覆写。 在 Swift 中，虚函数表被称为 “witness table”，下文将会使用 ““witness” 这个单词代表 “虚函数表”。 而在 extension 中定义的方法，默认采用的是 “静态派发”，静态派发会在编译时直接绑定调用目标，不会被加入到 witness table 里，也不暴露在 Objective‑C 运行时中。 上一节中提到，子类覆写方法需要依靠虚函数表或 Objective‑C 运行时，所以定义在 extension 中的方法无法被子类继承。 改写 知道错误原因的你可能想到了两种解决方案： 可以将方法移动到主要声明部分，也就是通过虚函数表实现方法覆写。 或者按照警告的提示，添加 @objc，借助 Objective-C 运行时实现方法覆写。 我们先采用第一种方案，看看如何实现： open class BaseCollectionViewCell: UICollectionViewCell { ... open func config() { ... } ... } class SubCollectionViewCell: BaseCollectionViewCell { } extension SubCollectionViewCell { override func config() { } // ❌ Non-@objc instance method 'config()' declared in 'BaseCollectionViewCell' cannot be overridden from extension } 当我们尝试继承 BaseCollectionViewCell 去定义 SubCollectionViewCell 时，问题更严重了，Xcode 报了个错误： Non-@objc instance method 'config()' declared in 'BaseCollectionViewCell' cannot be overridden from extension 这其实也很好理解，根据虚函数表的原理，如果父类函数被覆写，那么表中只会保存被覆写之后的函数。所以尽管父类的 config() 方法在虚函数表中，但是子类的方法不在，这样在运行时就无法使用子类的实现替代父类的实现。 既然第一条路走不通，那么第二条路呢？比如下面这样： open class BaseCollectionViewCell: UICollectionViewCell { ... @objc open func config() { ... } ... } class SubCollectionViewCell: BaseCollectionViewCell { } extension SubCollectionViewCell { override func config() { } // ❌ Cannot override a non-dynamic class declaration from an extension } 很好，报错变了，证明有效，但不完全有效。在这个例子中，我们已经使用 @objc 将父类方法暴露给 Objective-C，但是这实际上并不意味着方法派发方式改为了 “Objective-C 消息派发”。 在 Swift 3 时代存在 @objc 的隐式推断，而在发布 Swift 4 时候，这个隐式推断被取消了。开发者在类的主要声明（请先留意这一点，后文中还会提及）中，需要手动添加 dynamic 关键字，才能告诉编译器，将这个方法改为使用 “Objective-C 消息派发”。如果只添加 @objc，那么方法仅仅是被暴露给 Objective-C 而已，实际上还是被添加到虚函数表中，最终使用函数表派发。 所以正确的做法是为父类的方法定义添加 dynamic 关键字，就像下面这样： open class BaseCollectionViewCell: UICollectionViewCell { ... @objc dynamic open func config() { ... } ... } class SubCollectionViewCell: BaseCollectionViewCell { } extension SubCollectionViewCell { override func config() { } // ✅ } 好奇的你可能会注意到一个小细节：为什么子类方法光秃秃的，既不用添加 @objc，又不用添加 dynamic？ 这是因为尽管 Swift 4 已经取消了 @objc 隐式推断，但是在继承时这一推断被保留了下来，参考：Constructs that (still) infer @objc。所以在这个例子中，为了保持一致性，子类自动继承了父类方法的修饰。 extension 狂人 好了，现在你跟我说你是 extension 的狂热粉丝，你想将父类的框架方法也移到 extension 去定义，于是你将代码改成了这样： open class BaseCollectionViewCell: UICollectionViewCell { } extension BaseCollectionViewCell { @objc // ⚠️ 因为你的粗心，你遗漏了 `dynamic` 关键字。 open func config() { } } class SubCollectionViewCell: BaseCollectionViewCell { } extension SubCollectionViewCell { override func config() { } // ✅ } 让我们假设你是一个粗心的人（对不起），你在移动代码时丢失了 config() 方法上的 dynamic 关键字。此时你会发现，子类中的 config() 方法定义没有报错！此时先别着急欢呼 “extension 万岁！”，让我们来看看为什么此时不需要使用 dynamic？ 答案是因为：在 extension 中定义方法并使用 @objc 修饰时，将自动转换为 Objective-C 消息派发。所以就不需要显式添加 dynamic 了。 再深入思考一下，“在 extension 中定义方法并使用 @objc 修饰时，将自动转换为 Objective-C 消息派发” 这么设计的原因是什么呢？ 我觉得是因为 “extension 中的方法无法被加入虚函数表”。使用 @objc 修饰后肯定无法使用静态派发，所以最终只能使用 Objective-C 消息派发了。 再再刨根问底一下，为什么 “extension 中的方法无法被加入虚函数表”？根据我目前的知识，这是 Swift 编译器做的硬性规定，并且与 Swift 的设计理念有关。本文就不展开讨论了。 纯 Swift 类 上面的示例代码中，所有的类都是继承自 NSObject，那么如果是一个纯 Swift 类呢？比如说下面这个类型： class Foo { func config() {} } class SubFoo: Foo { } extension SubFoo { override func config() {} // 🩺 这里会报错吗？报什么错？ } 结论和上面一样。不论是纯 Swift 类，还是一个继承自 NSObject 的类，在本文所讨论的场景中行为是一致的。 有朋友会提到 Swift 代码跨平台时的表现：添加了 @objc 和 dynamic 的纯 Swift 类在 Windows 或 Linus 平台上可以正常编译吗？答案肯定是否定的，Objective-C 运行时只存在于 Apple 平台，在上面两个平台中是没有的，所以代码无法通过编译。 总结 通过本文的讨论，相信你已经掌握了如何利用 extension 正确覆写父类的方法。 在实际开发中，虽然 Swift 的方法派发常被视作面试“八股文”般的基础知识，但是理解这些细微差别不仅能帮助你在设计类结构和方法定义时做出更明智的选择，还能在保证高效运行的同时，为后续的灵活扩展打下坚实的基础。 那么留一个课后思考题： class Foo { func config() {} } class SubFoo: Foo { } extension SubFoo { @objc override func config() {} // ❌ Non-@objc instance method 'config()' declared in 'Foo' cannot be overridden from extension } 上面这个代码中，父类和子类中的 config() 方法分别是哪种派发方式呢？欢迎在评论区留下你的答案。 写在最后 其实本篇文章的场景 “extension 的设计初衷是为类添加新的功能，而非修改已有方法” 是不符合 Swift 语言的设计初衷的。官方文档中是这么说的： Extensions can add new functionality to a type, but they can’t override existing functionality. 所以你可能会在看到文章开头时就说：“根本就不应该在 extension 中覆写方法！”。这也确实，Apple 并不推荐我们借助 ObjC 的方式在 extension 中覆写方法。 但是既然 Apple 允许开发者借助 ObjC 运行时的特性来实现这一功能，那么我们就姑且允许它存在吧，相信你有能力把握一个度，什么时候可以用这个功能，什么时候应尽量避免。 ","link":"https://blog.rakuyoo.top/swift-method-dispatch-via-overriding/"},{"title":"List files by size","content":"问 ChatGPT 写了一个 shell 脚本，可以在命令行中按照从大到小，递归地输出除了 .json 文件外的文件，包含文件大小和文件名。可用于辅助筛查项目中哪些图片过大。 单独脚本文件就不存到 GitHub 上了，在这里记录一下吧。 #!/bin/bash # 定义一个函数将字节大小转为人类可读格式 human_readable_size() { num=$1 # echo &quot;Converting size: $num bytes&quot; # Log: 转换字节大小 if [ &quot;$num&quot; -lt 1024 ]; then echo &quot;${num}B&quot; elif [ &quot;$num&quot; -lt 1048576 ]; then echo &quot;$((num / 1024))K&quot; elif [ &quot;$num&quot; -lt 1073741824 ]; then echo &quot;$((num / 1048576))M&quot; else echo &quot;$((num / 1073741824))G&quot; fi } # 临时文件存储所有文件信息 temp_file=$(mktemp) # echo &quot;Temporary file created: $temp_file&quot; # Log: 临时文件创建 # 使用 find 查找所有文件，排除 .json 文件 find . -type f ! -name &quot;*.json&quot; -print0 | while IFS= read -r -d '' file; do # 获取文件大小（以字节为单位，macOS 使用 stat -f%z） size=$(stat -f%z &quot;$file&quot;) # echo &quot;File: $file, Size: $size bytes&quot; # Log: 文件和大小 # 输出字节大小和文件路径到临时文件 echo &quot;$size $file&quot; &gt;&gt; &quot;$temp_file&quot; done # Log: 排序之前的临时文件内容 # echo &quot;Contents of temp file before sorting:&quot; # cat &quot;$temp_file&quot; # 按字节数降序排序，并输出格式化结果 sort -k1,1nr &quot;$temp_file&quot; | while read -r size file; do # echo &quot;Processing sorted file: $file, Size: $size bytes&quot; # Log: 处理排序后的文件 # 获取人类可读格式 readable_size=$(human_readable_size &quot;$size&quot;) # 使用 printf 来确保输出格式对齐 printf &quot;%-10s %-10s %s\\n&quot; &quot;$readable_size&quot; &quot;$size&quot; &quot;$file&quot; done # 删除临时文件 # echo &quot;Deleting temporary file: $temp_file&quot; # Log: 删除临时文件 rm &quot;$temp_file&quot; ","link":"https://blog.rakuyoo.top/list_files_by_size/"},{"title":"String Catalog 实践","content":"最近项目有了国际化（i18n）的需求，正好 WWDC23 上 Apple 推出了 String Catalog 功能。趁此机会尝试一下，并将一些经验记录下来。 如果你对 String Catalog 不太熟悉，可以先参考 老司机技术 WWDC 23 内参，或者直接观看 WWDC 的 官方视频 和 文档 来了解更多。 好了废话不多说，开始今天的内容。 开发环境 Xcode：16.2 Swift：5.9 框架：UIKit 最低支持版本：iOS 13 组件化工具：CocoaPods Xcode 15 及以上版本支持 String Catalog，版本对功能无特别限制。 但由于项目最低支持版本为 iOS 13，而 String(localized:) 是 iOS 15 引入的 API，因此需要额外处理低版本兼容的问题。 此外，关于 String Catalog 在 CocoaPods 组件化项目中的使用，相关资料较少，因此这部分内容需要实际摸索一下。 项目准备工作 首先，在项目的 PROJECT 设置中添加需要支持的语言： 接着可以（可选）调整 Scheme 的模拟器设置，将语言和地区设置为待测试的环境： 例如将语言设置为英语、地区为美国。此操作便于验证翻译效果，但地区设置通常不会影响文案展示。 String Catalog + CocoaPods 在主项目中使用 String Catalog 可以算作在 CocoaPods 中使用的一个子集，所以我们直接讲解如何在 CocoaPods 中使用 String Catalog。 新建文件 通过 Command+N 新建 String Catalog 文件，效果如下： 提示： 文件里显示的语言，是根据所属 .xcodeproj 设置里添加的语言自动生成的。 Pods.xcodeproj 默认包含多种语言，所以 Pods 中的 .xcstrings 文件才会显示这么多的语种。 但这不会影响最终的 App。鉴于我们平时在使用时，不会将 Pods.xcodeproj 提交到 git，同时 App 的多语言设置不受 Pods 的影响，所以作为开发者你完全可以无视这一点，只从 String Catalog 挑选你关注的语种即可。 这里我新建了一个文件，叫 HomeLocalizable.xcstrings，并加了两个文案。 修改 Podspec 文件 接着，我们需要修改 podspec，把 .xcstrings 文件加到资源文件中。 说到这里，聪明的你肯定可以直接猜到，是不是可以仿照 .xcassets 类型的文件，直接将 .xcstrings 文件放到 resource_bundle 的自定义 Bundle 中。没错，确实是这样： s.resource_bundle = { 'HomeBundle' =&gt; [ 'Sources/Resource/**/*.xcstrings', 'Sources/Resource/**/*.xcassets', ] } 注意： 如果只将 .xcstrings 放入 Bundle 中的话会有一个问题，详见 Pod 与 String Catalog 自动化 这一小节。 然后执行 pod install，这样 .xcstrings 文件就会被包含到 HomeBundle 里了。 添加新的文言 选择我们的默认语种，点击加号即可添加新的文言。此后同样的操作在需要翻译的语种中，设置对应文言的翻译内容即可。 需要注意的是，默认语种中文言的状态（State）默认是不展示，即 Reviewed 已审核过的，和其他语种中的绿色对勾是一样的。而当我们新建一个文言后，其他语种中文言的状态则是NEW。 我实际测试了一下，当我们向 NEW 状态的文言添加对应的翻译，或者修改了 NEEDS REVIEW 状态的文言所对应的翻译后，该条文言的状态将自动变为 Reviewed。 另外，就算文言处于 NEEDS REVIEW 状态，只要包含了对应的翻译，那么该翻译也是可以正常显示的。不过从字面上来看这一行为有些危险，稳妥起见建议开发者确保所有文言无误后，将其标记为 Reviewed 后再使用。 展示国际化文本 这一节我们就要提到 String(localized:) 的问题了。网上大部分介绍 String Catalog 的文章都会使用 String(localized: ) 这一个新的 api，然而当我实际使时才发现，它仅限于 iOS 15 + 的版本。那么该怎么办呢？ 其实我们还可以使用老的 NSLocalizedString 方法。 let text = NSLocalizedString( &quot;扫码或长按小程序码&quot;, tableName: &quot;HomeLocalizable&quot;, bundle: BundleToken.bundle, comment: &quot;&quot; ) private final class BundleToken { static let bundle: Bundle = { #if SWIFT_PACKAGE return Bundle.module #else guard let resourcePath = Bundle(for: BundleToken.self).resourcePath, let bundle = Bundle(path: resourcePath + &quot;/HomeBundle.bundle&quot;) // ⬅️ Watch this. else { fatalError(&quot;Bundle not found, please make sure the Bundle name is correct!&quot;) } return bundle #endif }() } tableName 是 .xcstrings 文件名，bundle 是在 podspec 里定义的 HomeBundle。 这里的 BundleToken 参考了 SwiftGen 的实现，做了一些适配 CocoaPods 的改动：增加 HomeBundle。 如果你好奇为什么使用老的 NSLocalizedString api 也可以，那么我们可以先 build 编译一下项目，然后在 Products 目录找到编译好了之后的应用，最后找到 HomeBundle.bundle。 此时你就会发现，.xcstrings 虽然不像是 .bundle 一样是一个 “包”，但是在编译时，它会被编译为和 .xcstrings 同名的 .strings 文件，所以我们依然可以使用 NSLocalizedString api 来读取相关设置，这点在 WWDC 的视频中也有相关说明： SwiftGen 截止文章更新（2025.1.14），SwiftGen 最新版为 6.6.3，尚未正式支持 String Catalog。（SwiftGen 目前好像进入停更的状态） 不过有一个相关的 pr：Xcode 15 String catalog support #1124。 这个 pr 对 .xcstring 文件进行解析，解析后生成的内容和老版本 .string 解析后生成的内容类似。 顺带一提，这似乎也影响到了 Tuist 对于 String Catalog 的支持。 你可以考虑使用我 fork 的这个版本：6.6.4-alpha.0。通过 mise 安装时，可以按照下面的格式修改 mise.toml 文件： [tools] &quot;ubi:rakuyoMo/SwiftGen&quot; = { version = &quot;6.6.4-alpha.0&quot;, matching = &quot;swiftgen-6.6.4-alpha.0-macos.zip&quot;, exe = &quot;swiftgen&quot; } 如果你不想分叉自编译 SwiftGen 可以考虑尝试一个名为 xcstrings-tool 的新工具，Swift 开发，不支持 brew，但是支持通过 mise 安装 cli 单独使用，详见文档 一些注意 因为这是我第一次总结 i18n 相关的内容，所以也顺带记录一些问题或者注意事项。可能比较常见，比较基础。 换行符 如果在 .xcstrings 文件中直接输入 \\n 代表换行，在实际展示时是起不到换行的效果，而是会将 \\n 展示出来。从 json 文件或Git 中查看会发现，实际内容是 \\\\n，即转义过后的内容。 正确的方式是使用 option + return 组合键在 .xcstrings 文件中输入换行。或者不嫌麻烦的话可以手动修改 json 文件，效果是一样的（手动狗头）。 nslocalizedstring_key SwiftLint 中包含着一条名为 nslocalizedstring_key 的规则，文档在这里。 它建议不要动态传入 key，比如这样是不推荐的： // 不推荐 let key = &quot;example_key&quot; let text = NSLocalizedString(key, comment: &quot;&quot;) Pod 与 String Catalog 自动化 在 Xcode 15 中，如果设置了 Use Compiler to Extract Swift Strings 为 YES，那么 String Catalog 文件就可以自动追踪国际化文本，比如下面这个字符串： let test = NSLocalizedString(&quot;Test&quot;, tableName: &quot;TestLocalizable&quot;, comment: &quot;Test&quot;) 编译后会有一个 “Syncing Localizations” 的阶段，在该阶段这个字符串会被自动记录到 TestLocalizable.xcstrings 文件中。 但是在 pod 组件化项目中，如果该字符串在某个 pod 内，则自动追踪不会生效。原因有以下几点： “Syncing Localizations” 阶段仅会扫描当前 Scheme 所包含的 target。一般我们编译时都会选择主项目，此时是不包含 pod target 的，所以不会扫描相应的代码。 Pod 的 Use Compiler to Extract Swift Strings 设置项默认为 NO，需要在 Podfile 中使用钩子手动开启（Key 为 SWIFT_EMIT_LOC_STRINGS）。 前文中，.xcstrings 被添加到 Bundle 中，这意味着它会被归入 Bundle 这个 target，比如 Pod 名为 Home，那么 .xcstrings 文件就在 Home-HomeBundle 这个 target 中。而项目代码则在 Home 这个 target 里。此时编译 Home，因为该 target 实际不包含 .xcstrings，所以字符串也不会同步到 .xcstrings 文件中。 综上，考虑到 CocoaPods 已经停止增加新功能，建议还是尽快迁移到 SPM。 ","link":"https://blog.rakuyoo.top/string-catalog/"},{"title":"HarmonyOS 与 ArkTS 开发注意事项","content":"本文持续记录一些使用 ArkTS 进行 HarmonyOS 开发时遇到的一些问题以及解决方案。以及一些可能称不上是问题，但是在我看来有必要记录一下的点。 本文的主要结构将分为 ArkTS 和 HarmonyOS 两部分。同时内容多与 iOS 开发以及 Swift 语言进行对比。 因为代码高亮限制，本文中涉及到 ArkTS 的代码，都将使用 TypeScript 的语法高亮设置 ArkTS ArkTS 是 TS 的超集，同时也阉割了一些 TS 的用法。 本节所记录的内容是从一个 TS 零基础小白的视角出发所遇到的问题。所以某些内容未必属于 ArkTS 引入，也有可能是 TS 就存在。某些小节可能会指出该小节的内容是属于 ArkTS 独有，还是 TS 就有。但是大多数小节可能并不会做此区分。 async 与 await ArkTS 的异步协程不像是 Swift 那样，需要在方法声明上显式增加 async 关键字。 只要方法返回 Promise 类型，那么在调用时候就可以通过添加 await 关键字，来获取 Promise 里所包含的数据。 比如下面的方法： function getData(): Promise&lt;string&gt; { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(&quot;Data fetched!&quot;); }, 1000); }); } function main() { const result = await getData(); // 可以使用 await console.log(result); // 输出: &quot;Data fetched!&quot; } 这其实是 TS 的语法。当你在 TypeScript 中声明一个函数为 async 时，该函数会自动返回一个 Promise 对象，而不是直接返回结果。即使函数内部没有显式地返回 Promise，async 函数会将其结果封装在一个 Promise 中。比如下面这样： async function myAsyncFunction() { return &quot;Hello, Async!&quot;; } // 调用方式 myAsyncFunction().then(result =&gt; console.log(result)); // 输出: &quot;Hello, Async!&quot; myAsyncFunction 因为被 async 修饰，所以自动返回了一个 Promise&lt;string&gt; 而不是单纯的 string。 所以如果方法没有标记 async，但是返回了 Promise，其实和标记了但是省略返回类型是一样的，自然也可以在调时直接使用 await 同步获取内容了。 HarmonyOS 环境变量配置 这里说的环境变量是 “正式环境”、“预上线环境” 以及 “测试环境”。包含接口环境配置以及一些 debug 入口等等。 在 iOS 开发中我们有预编译宏，但是 HarmonyOS 这块儿没有这个。HarmonyOS 的方法是在各个子模块中建立 target 的 sourceRoots 字段，将不同环境的代码添加到不同的 target 中，然后 entry 再引用不同的 target，以此来达到不同环境加载不同代码的需求。 本节不详细展开具体的详细内容，详细内容见官方文档。 在做这一项配置的过程中，有一个概念很容易搞错，或者说官方文档的讲解流程和实际上配置的流程有一定的出入。（当然也有可能是我个人能力不足导致理解错误）。 我们来看下面几个 build-profile.json5 文件。首先是一个 feature module 的： // feature/build-profile.json5 { &quot;apiType&quot;: &quot;stageMode&quot;, &quot;buildOption&quot;: {}, &quot;targets&quot;: [ { &quot;name&quot;: &quot;default&quot;, &quot;source&quot;: { &quot;sourceRoots&quot;: [&quot;./src/default&quot;] // 配置target为default的差异化代码空间 } }, { &quot;name&quot;: &quot;custom&quot;, &quot;source&quot;: { &quot;sourceRoots&quot;: [&quot;./src/custom&quot;] // 配置target为custom的差异化代码空间 } } ] } 其包含两个 target，使用 sourceRoots 引用了不同的代码。 然后再看 entry 的： { &quot;apiType&quot;: &quot;stageMode&quot;, &quot;buildOption&quot;: {}, &quot;targets&quot;: [ { &quot;name&quot;: &quot;default&quot;, }, ] } entry 只包含一个 default target。 最后看工程的： { &quot;app&quot;: { &quot;signingConfigs&quot;: [], &quot;products&quot;: [ { &quot;name&quot;: &quot;default&quot;, &quot;signingConfig&quot;: &quot;default&quot;, &quot;compatibleSdkVersion&quot;: &quot;5.0.0(12)&quot;, &quot;runtimeOS&quot;: &quot;HarmonyOS&quot;, }, { &quot;name&quot;: &quot;custom&quot;, &quot;signingConfig&quot;: &quot;default&quot;, &quot;compatibleSdkVersion&quot;: &quot;5.0.0(12)&quot;, &quot;runtimeOS&quot;: &quot;HarmonyOS&quot;, } ], &quot;buildModeSet&quot;: [ { &quot;name&quot;: &quot;debug&quot;, }, { &quot;name&quot;: &quot;release&quot; } ] }, &quot;modules&quot;: [ { &quot;name&quot;: &quot;entry&quot;, &quot;srcPath&quot;: &quot;./entry&quot;, &quot;targets&quot;: [ { &quot;name&quot;: &quot;default&quot;, &quot;applyToProducts&quot;: [ &quot;default&quot;, &quot;custom&quot;, ] }, ] }, { &quot;name&quot;: &quot;feature&quot;, &quot;srcPath&quot;: &quot;./feature&quot;, &quot;targets&quot;: [ { &quot;name&quot;: &quot;default&quot;, &quot;applyToProducts&quot;: [ &quot;default&quot; ] }, { &quot;name&quot;: &quot;custom&quot;, &quot;applyToProducts&quot;: [ &quot;custom&quot; ] }, ] }, ] } 在阅读官方文档后，我首先的想法就是上面这三个配置文件。定义 default 和 custom 两个 product，然后 entry 作为入口，添加到两个 product 中。feature/default 添加到 default；feature/custom 添加到 custom。这样 default product 包含 entry 和 feature/default，custom product 包含 entry 和 feature/custom。思路看着没问题对吧，然而实际运行起来会发现配置不生效：custom product 使用的是 feature/default。 问题在于思路不对，正确的思路应该是：将 entry 中定义的 target，下放给各个 module 使用。也就是说要先在 entry 中定义各个 target，然后再在各个 module 中使用 entry 定义的 target，自定向下使用。 比如有5个子 module，各自都有不同的 target 需求，分别是 1-5，那么 entry 中就应该定义这 1-5个 target，然后5个子 module 从中选取自己需要的那一个。 所以上述例子中的配置文件应该改成下面这样，先看 entry 的 build-profile.json5： { &quot;apiType&quot;: &quot;stageMode&quot;, &quot;buildOption&quot;: {}, &quot;targets&quot;: [ { &quot;name&quot;: &quot;default&quot;, }, { &quot;name&quot;: &quot;custom&quot;, // 增加 custom target }, ] } 然后修改工程级 build-profile.json5： { &quot;app&quot;: { &quot;signingConfigs&quot;: [], &quot;products&quot;: [ { &quot;name&quot;: &quot;default&quot;, &quot;signingConfig&quot;: &quot;default&quot;, &quot;compatibleSdkVersion&quot;: &quot;5.0.0(12)&quot;, &quot;runtimeOS&quot;: &quot;HarmonyOS&quot;, }, { &quot;name&quot;: &quot;custom&quot;, &quot;signingConfig&quot;: &quot;default&quot;, &quot;compatibleSdkVersion&quot;: &quot;5.0.0(12)&quot;, &quot;runtimeOS&quot;: &quot;HarmonyOS&quot;, } ], &quot;buildModeSet&quot;: [ { &quot;name&quot;: &quot;debug&quot;, }, { &quot;name&quot;: &quot;release&quot; } ] }, &quot;modules&quot;: [ { &quot;name&quot;: &quot;entry&quot;, &quot;srcPath&quot;: &quot;./entry&quot;, &quot;targets&quot;: [ { &quot;name&quot;: &quot;default&quot;, &quot;applyToProducts&quot;: [ &quot;default&quot;, ] }, { &quot;name&quot;: &quot;custom&quot;, &quot;applyToProducts&quot;: [ &quot;custom&quot;, ] }, ] }, { &quot;name&quot;: &quot;feature&quot;, &quot;srcPath&quot;: &quot;./feature&quot;, &quot;targets&quot;: [ { &quot;name&quot;: &quot;default&quot;, &quot;applyToProducts&quot;: [ &quot;default&quot; ] }, { &quot;name&quot;: &quot;custom&quot;, &quot;applyToProducts&quot;: [ &quot;custom&quot; ] }, ] }, ] } 这么修改后再运行，custom product 就可以正确地读取到 feature/custom 了。 最后再来说一说官方中的例子。官方上的示例使用 entry 演示 sourceRoots 的用法，其实暗藏了 “entry 也需要定义对应的 target” 这一点，只不过没有明说，让读者忽略了这一关键内容。 ","link":"https://blog.rakuyoo.top/notes-on-harmonyos-and-arkts-development/"},{"title":"Gitlab-CI 与 Shell 会话模式","content":"之前的文章中介绍过，iOS 常用的 Gitlab-CI 执行器是 shell，因为打包时只能使用这个。 今天将包管理工具迁到 mise 时遇到了一些和 shell 有关的问题，涉及到一些之前的知识盲区，遂记录一下。 本文的内容和 mise 无关，只是工具迁移时引出了本文涉及到的问题和知识盲区。对工具感兴趣的朋友可以点击上面的链接查看相关内容。 Shell 会话模式 先介绍一下 Shell 的几种会话模式。 我们都知道 macOS 的 默认终端环境是 zsh，zsh 有多个配套的文件，包含 ~/.zshrc、.zprofile 等。另一个比较常见的是 bash，可使用的配置文件有 ~/.bash_profile 、~/.bashrc 等。 之前我只模糊的知道有这些文件，可以在其中写入一些内容，然后启动终端后就会自动加载这些文件，却从来没有关注过 什么时候会加载哪个文件。这就涉及到 “Shell 会话模式” 这个概念。 “Shell 会话模式”是指用户启动会话时 shell（例如 bash、zsh 或其他命令行解释器）可以运行的不同方式。每种模式都规定了 shell 的行为方式、加载的初始化文件以及处理命令的方式。 此会话模式主要围绕两个概念：“是否是交互式” 以及 “是否登录”。这两种概念两两组合，诞生四种会话模式。 是否是交互式：指定用户是否可以通过键入命令直接与 shell 交互。shell 会等待用户输入并根据输入的命令提供输出。 是否登录：指开启会话时用户是否登录。 举几个例子： 交互式：打开 macOS 中的终端，此时我们可以在里面输入命令，与 shell 交互。 非交互式：Gitlab-CI 执行 script 时，就是非交互式。我们知道执行过程中我们没有办法做任何事，包括输入设备密码，say yes 等。 登录：通过 ssh 连接服务器，此时需要我们输入用户名密码。又或者执行命令时携带了 | /bin/bash --login 参数。 非登录：打开 macOS 的终端，默认是非登录的。又或者从一个已经登录了的终端中，使用 bash 或其他命令开启了新的终端窗口，这些也是非登录式的。 那么在不同的登录模式下，shell 会加载的配置文件其实是不同的： 会话类型 .bash_profile .bashrc .zprofile .zshrc 交互式登录 ✅ ❌ ✅ ❌ 交互式非登录 ❌ ✅ ❌ ✅ 非交互式登录 ✅ ❌ ❌ ❌ 非交互式非登录 ❌ ❌ ❌ ❌ 如果使用 bash，那么还有一个可能会使用的配置文件：~/.profile。它的作用和 ~/.bash_profile 类似，仅当 .bash_profile 不存在时，会尝试加载 .profile。另外，有的时候 .bash_profile 中会有命令，同时加载 .profile。 而 zsh 默认是不会尝试加载 .profile 的。 Gitlab-CI 的 script Gitlab-CI 的文档有列举出它所支持的 shell 种类，这里我们看默认的 bash。 贴一下文档中关于如何执行 script 的示例 # This command is used if the build should be executed in context of another user (the shell executor) cat generated-bash-script | su --shell /bin/bash --login user # This command is used if the build should be executed using the current user, but in a login environment cat generated-bash-script | /bin/bash --login # This command is used if the build should be executed in a Docker environment cat generated-bash-script | /bin/bash 从文档中可以看到，不论哪种方式，Gitlab-CI 都是使用 /bin/bash 环境执行的 script 中定义的脚本，并且在非 Docker 环境下，会携带 --login 参数，也就是说此时使用的是 “非交互式登录 Shell”，回看上面的表格，.bash_profile 文件会被加载。 此时就需要注意了，因为 macOS 默认的终端是 zsh，所以我们在编写脚本的时候，很可能会习惯性地将配置写入到 .zprofile 或者 .zshrc 文件中，但是回到 Gitlab-CI 中就会发现不生效，原因就是脚本的执行环境不同。 ","link":"https://blog.rakuyoo.top/gitlab-ci-and-shell-session-mode/"},{"title":"从源码看如何刷新 Epoxy 列表","content":"如何正确的刷新 Epoxy 列表可以说是熟练使用这个框架的关键，初上手时总会有 “为什么列表刷新后数据没变” 和 “为什么它刷新后数据就变了” 的疑惑。 本文从源码分析的角度，带大家来梳理 Epoxy 列表刷新的原理，并学会如何正确刷新 Epoxy 列表。 Epoxy 列表本质上还是 UICollectionView，只不过实现了 diff 算法，封装了 reuse id 的创建。 对于一个常见的 UICollectionViewCell 或 UITableViewCell，我的习惯是： Cell 初始化时创建 subviews，添加到 contentView 上，并设置布局。 对外暴露 config() 方法，或直接暴露 subviews 在 collectionView(_: cellForItemAt:) 方法中将数据设置到 subviews 上。 如果想要列表上 Cell 中的数据发生变化，无外乎以下几种方法： 创建不同的 Cell。不同的数据对应不同的 Cell，抛弃或部分抛弃重用机制。 在 Cell 创建或复用后，重新设置 subviews 上的数据。这包括两种方法： collectionView(_: cellForItemAt:) 方法中调用 config()，或直接使用 subviews。 使用响应式框架，比如 Combine，将数据绑定到 Cell 的 subviews 上。 那么接下来，我们就从这几种方法上入手，看看如何正确刷新 Epoxy 列表。 Cell 创建流程 首先我们需要知道 Epoxy 是如何创建一个 Cell。在使用框架时，我们没有显式创建过 reuse id，Epoxy 框架是如何创建它的？ 源码分析 在 CollectionView/Internal/CollectionViewDataSource.swift 中，关于 Cell 的创建如下所示： func collectionView( _ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -&gt; UICollectionViewCell { guard let item = data?.item(at: indexPath), let section = data?.section(at: indexPath.section), let reuseID = reuseIDStore.registeredReuseID(for: item.viewDifferentiator) else { // The `item(…)` or `registeredReuseID(…)` methods will assert in this scenario. return UICollectionViewCell() } let cell = collectionView.dequeueReusableCell(withReuseIdentifier: reuseID, for: indexPath) if let cell = cell as? CollectionViewCell { self.collectionView?.configure( cell: cell, with: item, at: .init(itemDataID: item.dataID, section: .dataID(section.dataID)), animated: false) } else { EpoxyLogger.shared.assertionFailure( &quot;Only CollectionViewCell and subclasses are allowed in a CollectionView.&quot;) } return cell } 首先关注创建 Cell 时使用的标识符，即 reuseID 这个变量是从何而来的。 let reuseID = reuseIDStore.registeredReuseID(for: item.viewDifferentiator) 这里包含两个需要明白的内容，分别是 reuseIDStore 和 viewDifferentiator。 从后往前看，viewDifferentiator 定义在 ViewDifferentiatorProviding 协议里，它的类型 ViewDifferentiator 是一个遵循 Hashable 的结构体： // MARK: - ViewDifferentiatorProviding public protocol ViewDifferentiatorProviding { var viewDifferentiator: ViewDifferentiator { get } } // MARK: - ViewDifferentiator public struct ViewDifferentiator: Hashable { public init(viewType: AnyClass, styleID: AnyHashable?) { viewTypeDescription = &quot;\\(type(of: viewType.self))&quot; self.styleID = styleID } public var viewTypeDescription: String public var styleID: AnyHashable? } 从源码注释上可以看出来这两个类型就是服务于 reuseID 创建的。ItemModel 是这么实现 ViewDifferentiatorProviding 协议的： extension ItemModel { public var viewDifferentiator: ViewDifferentiator { .init(viewType: View.self, styleID: styleID) } ... } 这里的 View 是一个范型，可以理解为一个实现了 EpoxyableView 的 UIView 对象。styleID 定义在 StyleIDProviding 协议中，是一个扩展出来的存储属性，其类型是 AnyHashable，这里就省略展示它的定义了。 那么使用时它的值是哪儿来的呢？ public struct ItemModel&lt;View: UIView&gt;: ViewEpoxyModeled { ... public init&lt;Params: Hashable, Content: Equatable&gt;( dataID: AnyHashable, params: Params, content: Content, makeView: @escaping (Params) -&gt; View, setContent: @escaping (CallbackContext, Content) -&gt; Void) { self.dataID = dataID styleID = params // ⬅️ 在这里进行赋值 erasedContent = content self.makeView = { makeView(params) } self.setContent = { setContent($0, content) } isErasedContentEqual = { otherModel in guard let otherContent = otherModel.erasedContent as? Content else { return false } return otherContent == content } } ... } 上面这个是 ItemModel 的初始、基本初始化方法，可以看到在初始化时，是使用 params 这个参数初始化 styleID 属性的。但是基本上我们都很少使用这个初始化方法，而是使用下面这个： extension StyledView where Self: BehaviorsConfigurableView &amp; ContentConfigurableView { public static func itemModel( dataID: AnyHashable, content: Content, behaviors: Behaviors? = nil, style: Style) -&gt; ItemModel&lt;Self&gt; { ItemModel&lt;Self&gt;( dataID: dataID, params: style, // ⬅️ 发现 params 的来源 content: content, makeView: Self.init(style:), setContent: { context, content in context.view.setContent(content, animated: context.animated) }) .setBehaviors { context in context.view.setBehaviors(behaviors) } } } 看到这里就明白了：这个 styleID 就是创建 EpoxyableView 时定义的 Style。所以 viewDifferentiator 代表的就是遵循 EpoxyableView 协议的这个类型本身以及它所包含的 Style 对象。当同一个 View 但是 Style 不同时，viewDifferentiator 也就不同。 看完了 viewDifferentiator，让我们再回过头来看 reuseIDStore。 它的类型是一个类 ReuseIDStore，从命名上可以看出这个类是专门用来存储 reuse id 的。通过源码可以看到，这个类内部使用两个 Dictionary 来封装 reuse id 的创建、存储以及读取逻辑。 对外主要提供了两个方法：reuseID(byRegistering:) 和 registeredReuseID(for:)，参数都是 ViewDifferentiator。前者用于存储 reuse id，后者负责查询读取。 内部包含以下两个 Dictionary: private var uniqueViewDifferentiatorCountsForViewTypes = [String: Int]() private var reuseIDsForViewDifferentiators = [ViewDifferentiator: String]() uniqueViewDifferentiatorCountsForViewTypes 负责计数，即一个 CollectionView 注册了几次这个 View（Cell）。 通过追踪调用栈，可以发现每次调用 setSections(_: strategy:) 方法时，如果存在新的 ViewDifferentiator，就会调用 reuseID(byRegistering:) 进行注册。 这里我们结合注册方法 reuseID(byRegistering:) 的实现来一起看： public func reuseID(byRegistering viewDifferentiator: ViewDifferentiator) -&gt; String { if let existingReuseID = reuseIDsForViewDifferentiators[viewDifferentiator] { return existingReuseID } let viewType = viewDifferentiator.viewTypeDescription let uniqueViewDifferentiatorCount = uniqueViewDifferentiatorCountsForViewTypes[viewType] ?? 0 uniqueViewDifferentiatorCountsForViewTypes[viewType] = uniqueViewDifferentiatorCount + 1 let reuseID = &quot;\\(viewType)_\\(uniqueViewDifferentiatorCount)&quot; // ⬅️ 类型加出现次数 reuseIDsForViewDifferentiators[viewDifferentiator] = reuseID return reuseID } ViewDifferentiator 是遵循 Hashable 的，对于同一个 View 类型而言，不同的 Style 实例意味着不同的 ViewDifferentiator，每一种都会调用 reuseID(byRegistering:) 进行注册。通过累加 count，可以保证不同的 ViewDifferentiator 对应不同的 reuse id。 小结 到这里我们可以用一个例子来总结一下 reuse id 的创建过程和创建结果。 假设定义如下一个 View： final class TextRow: UIView, EpoxyableView { enum Style { case small, large } } 使用时如下： // ... other row TextRow.itemModel(dataID: &quot;small&quot;, style: .small) // ... other row TextRow.itemModel(dataID: &quot;large&quot;, style: .large) // ... other row 那么当我们调用 collectionView.setSections(_: strategy:) 时，因为两个 ItemModel 实例对应的 Style 不同，CollectionView 中就会注册两个 Cell，reuse id 分别为 TextRow_0 和 TextRow_1。 所以如果你希望抛弃或部分抛弃 Cell 的重用机制，那么你就需要保证 reuse id 各不相同，即 使用不同的 View，或者不同的 View.Style。 在实际使用时，我们常通过字面含义，将比如 TextColor 等 UI 样式封装在 Style 中。在遇到 “可用时显示黑色，不可用时展示灰色” 这种需求时，动态修改 TextColor，随后调用 setSections(_: strategy:) 刷新列表。这时列表数据发生变动，其实是 reuse id 不同，系统创建了新的 Cell 来展示不同的文字颜色。很多时候这种现象其实违背了开发者的初衷。 更新 Cell 数据 另外一种方法就是更新 Cell 上子视图的数据，比如 Label 的 text 等。在 Epoxy 中，我们常将数据定义在 Content 里，并在 setContent(_: animated:) 方法内将数据渲染到 UI 上，比如这样： extension HeaderRow: ContentConfigurableView { struct Content: Equatable { let title: String let tips: String? } func setContent(_ content: Content, animated: Bool) { titleLabel.text = content.title tipsLabel.text = content.tips } } 那么是不是修改了 Content 之后，再调用 setSections(_: strategy:) 刷新列表即可刷新 UI？让我们来看一下源码。 Content 设置流程 源码分析 首先看一下 itemModel(dataID: content: behaviors: style:) 方法的定义，它是 EpoxyableView 创建 ItemModel 的方法。 extension StyledView where Self: BehaviorsConfigurableView &amp; ContentConfigurableView { public static func itemModel( dataID: AnyHashable, content: Content, behaviors: Behaviors? = nil, style: Style) -&gt; ItemModel&lt;Self&gt; { ItemModel&lt;Self&gt;( dataID: dataID, params: style, content: content, // ⬅️ 传入 makeView: Self.init(style:), setContent: { context, content in // ⬅️ 在闭包内又吐了出来，相当于闭包持有了 Content 实例 context.view.setContent(content, animated: context.animated) }) .setBehaviors { context in context.view.setBehaviors(behaviors) } } } 从实现上看，content 实例被包裹进了 setContent 闭包，延迟到合适的时机再进行调用： extension ItemModel: InternalItemModeling { ... public func configure(cell: ItemWrapperView, with metadata: ItemCellMetadata) { // Even if there's no `setContent` closure, we need to make sure to call `viewForCell` to ensure that the cell is set up. let view = viewForCell(cell) setContent?(.init(view: view, metadata: metadata)) } ... } 这里插一句，在寻找 setContent 闭包的 Caller 时，你有可能会注意到下面这个方法： extension AnyItemModel: InternalItemModeling { ... public func configure(cell: ItemWrapperView, with metadata: ItemCellMetadata) { model.configure(cell: cell, with: metadata) if let view = cell.view { setContent?(.init(view: view, metadata: metadata)) } } ... } 这个方法属于 AnyItemModel，这个类型擦除负责包裹不同的 ItemModel 实例，方法第一行的 model 即是它所包装的 ItemModel 实例。 为什么提到这个方法呢？因为这个方法看上去调用了两次 setContent 闭包。然而实际上，不止 setContent，AnyItemModel 中的其他类似的属性（比如 setBehaviors）都是 nil，所以 setContent 闭包只调用了一次，重点还是关注 ItemModel 的 configure(cell: with:) 方法。 AnyItemModel 的 setContent 是 nil 是设计上决定的，项目中搜索不到对其进行赋值的代码。至于为什么明明没有赋值，却还有调用，猜测是为了架构上的统一？ 继续向上寻找调用方，可以发现是在上文中提到的 collectionView(_: cellForItemAt:) 方法内调用的。方法实现内有一行 self.collectionView?.configure( ... )，该方法内无判断地调用了 model 的 configure(cell: with:) 方法。 小结 总结一下逻辑和调用链： 刷新 CollectionView 时，执行 collectionView(_: cellForItemAt:)，通过层层调用，最终 model.setContent 闭包被调用，View 的 setContent(_: animated) 被调用，新的 Content 被设置到 UI 上。 到这里结束了吗？还不要高兴的太早，不要忘记了 CollectionView 还存在 Diff 的逻辑：更新 Content 实例后调用 setSections(_: strategy:)，CollectionView 一定会被刷新吗？未必。 CollectionView 刷新时机 源码分析 让我们自顶向下看，先看 setSections(_: strategy:) 的实现： open class CollectionView: UICollectionView { ... public func setSections(_ sections: [SectionModel], animated: Bool) { let strategy: UpdateStrategy if configuration.usesBatchUpdatesForAllReloads { strategy = animated ? .animatedBatchUpdates : .nonanimatedBatchUpdates } else { strategy = animated ? .animatedBatchUpdates : .reloadData } setSections(sections, strategy: strategy) } public func setSections(_ sections: [SectionModel], strategy: UpdateStrategy) { EpoxyLogger.shared.assert(Thread.isMainThread, &quot;This method must be called on the main thread.&quot;) epoxyDataSource.registerSections(sections) apply(.make(sections: sections), strategy: strategy) } ... } registerSections() 上文有提到，负责注册 Section 以及 Cell。重点关注下面的 apply(_: strategy:) 方法。查看该的实现，可以看到其内部调用了下面这个方法： open class CollectionView: UICollectionView { ... private func updateView(with data: CollectionViewData, strategy: UpdateStrategy) { updateState = .preparingUpdate let performUpdates = { self.performBatchUpdates({ self.performUpdates(data: data, animated: strategy.animated) }, completion: { _ in if let nextUpdate = self.queuedUpdate, self.window != nil { self.queuedUpdate = nil self.updateView(with: nextUpdate.newData, strategy: nextUpdate.strategy) } else { self.completeUpdates() } }) } // There's two cases in which we should always have a strategy of `.reloadData`: // - The first update, since we're going from empty content to non-empty content, and we don't want to animate that update. // - Before the first layout of this collection view when `bounds.size` is still zero, since there's no benefit to doing batch updates in that scenario. let override = (epoxyDataSource.data == nil || bounds.size == .zero) ? .reloadData : strategy switch override { case .animatedBatchUpdates: performUpdates() case .nonanimatedBatchUpdates: UIView.performWithoutAnimation { performUpdates() } case .reloadData: let result = epoxyDataSource.applyData(data) updateState = .updating(from: result.oldData) reloadData() completeUpdates() } } ... } 通过上面的实现我们可以得到第一个刷新方案：如果 strategy 是 .reloadData，那么会直接调用 UICollectionView 的 reloadData 方法（即不使用 Epoxy 内置的 Diff 算法），此时 collectionView(_: cellForItemAt:) 方法必执行，新的 Content 可以被正确地更新。 之所以保留注释，是因为这里的注释比较关键。通过注释我们可以得知：初次加载时，或者对一个尚未具有尺寸的 CollectionView 调用刷新时，将忽略外部参数，永远使用 .reloadData 方式进行刷新。 那如果使用其他的 strategy 呢？就需要关注 performUpdates 闭包里调用的 performUpdates(data: animated:) 方法了。 这里稍微提一下 UICollectionView 的 performBatchUpdates(_: completion:) 方法，它是用来将多个操作（update、insert、delete 等），合并至一个动画内进行展示。 因为 performUpdates(data: animated:) 里使用了 diff 算法，该算法会同时计算出上述多种操作，所以为了更好的 UI 交互展示，需要将这些操作合并至一个动画内展示。 performUpdates(data: animated:) 方法实现比较多，这里挑一些我们关注的贴一下： open class CollectionView: UICollectionView { ... private func performUpdates(data: CollectionViewData, animated: Bool) { let result = epoxyDataSource.applyData(data) updateState = .updating(from: result.oldData) for (fromIndexPath, toIndexPath) in result.changeset.itemChangeset.updates { if let cell = cellForItem(at: fromIndexPath) as? CollectionViewCell, let item = epoxyDataSource.data?.item(at: toIndexPath) { let metadata = ItemCellMetadata( traitCollection: traitCollection, state: cell.state, animated: animated) item.configure(cell: cell, with: metadata) // ⬅️ 熟悉的老朋友 item.configureStateChange(in: cell, with: metadata) } } ... deleteSections(result.changeset.sectionChangeset.deletes) deleteItems(at: result.changeset.itemChangeset.deletes) for (fromIndex, toIndex) in result.changeset.sectionChangeset.moves { moveSection(fromIndex, toSection: toIndex) } for (fromIndexPath, toIndexPath) in result.changeset.itemChangeset.moves { moveItem(at: fromIndexPath, to: toIndexPath) // ⬅️ moveItem 未必会触发 cell 加载 } insertSections(result.changeset.sectionChangeset.inserts) insertItems(at: result.changeset.itemChangeset.inserts) // ⬅️ insertItems 也会触发 cell 加载 } ... } 方法实现的第一行，epoxyDataSource.applyData(data) 就是应用 diff 算法。之前写的 Epoxy 源码分析系列文章中，第一篇就是有关 Epoxy 的 Diff 算法的，这里就不再赘述算法原理。 在这个方法实现中可以说有两个刷新逻辑： 熟悉的朋友：item.configure(cell: cell, with: metadata)。也就是说如果上面的条件都满足，那么 configure(cell: with:) 方法就会被调用，Content 就会被更新。 又或者归到 inserts 里，作为一个新的 Cell 插入到列表中。 IndexPathChangeset 包含以下几种情况： public struct IndexPathChangeset { ... /// The inserted `IndexPath`s needed to get from the old collection to the new collection. public var inserts: [IndexPath] /// The deleted `IndexPath`s needed to get from the old collection to the new collection. public var deletes: [IndexPath] /// The updated `IndexPath`s needed to get from the old collection to the new collection. public var updates: [(old: IndexPath, new: IndexPath)] /// The moved `IndexPath`s needed to get from the old collection to the new collection. public var moves: [(old: IndexPath, new: IndexPath)] ... } 这两个方案中，inserts 的逻辑很简单。让我们忽略 diff 算法的逻辑，直接说结论：只要 dataID 发生变化，它就是一个新的 ItemModel，就会执行 delete &amp; insert。所以第二个刷新方案就是：修改前后，ItemModel 的 dataID 不同。 那 configure(cell: with:) 的前置条件都有哪些呢？首先是 for 循环的数组不为空，其次是两个 if。聪明的你应该可以发现，这两个 if 不是逻辑重点，第一个 if 只是为了满足 Swift 语法的类型转换，而第二个 if 是为了判断 Cell 是否展示出来，避免 configure(cell: with:) 多次调用。所以重点就在于 result.changeset.itemChangeset.updates 是否为空。 所以我们关注的重点就是：如何修改我们的数据源，可以让其归到 updates 集合里。条件有以下几点： 这个 ItemModel 在刷新前已经存在于列表中，在列表中具有 Index。 ItemModel 的 isDiffableItemEqual(to:) 方法返回 false。 相关方法的实现如下： extension ItemModel: Diffable { ... public func isDiffableItemEqual(to otherDiffableItem: Diffable) -&gt; Bool { guard let other = otherDiffableItem as? Self else { return false } return isErasedContentEqual?(other) ?? true } } isErasedContentEqual 在 ItemModel 初始化时进行设置： public struct ItemModel&lt;View: UIView&gt;: ViewEpoxyModeled { ... public init&lt;Content: Equatable&gt;( dataID: AnyHashable, content: Content, setContent: @escaping (CallbackContext, Content) -&gt; Void) { self.dataID = dataID erasedContent = content // ⬅️ erasedContent 就是 content self.setContent = { setContent($0, content) } isErasedContentEqual = { otherModel in guard let otherContent = otherModel.erasedContent as? Content else { return false } return otherContent == content // ⬅️ Content 遵循 Equatable 的目的就在此 } } ... } 从上面两个方法实现中我们可以得到结论： 如果 EpoxyableView 没有定义 Content，那么也就不存在 updates 的逻辑。 更新前后，两个 ItemModel 的 Content 不相等，EpoxyableView 的 setContent(_: animated:) 方法才会被调用。 那么第三种刷新方案就是：确保修改前后的 Content 不相等。 小结 现在我们知道了，在调用 setSections(_: strategy:) 方法之后，Style 不变的前提下，以下几种情况 EpoxyableView 的 setContent(_: animated) 方法将被调用： strategy 为 .reloadData 时。 包括空 CollectionView 初次加载数据，或者 CollectionView 尚没有 Size 时。 修改数据前后，ItemModel 的 dataID 发生了改变。 修改数据前后，Content 的 == 返回 false，即两个 Content 不相等。 比如下面的例子就是有效的： private var count = 0 { didSet { setItems(items, animated: true) } } @ItemModelBuilder private var items: [ItemModeling] { TextRow.itemModel( dataID: DataID.row, content: .init( title: &quot;Count \\(count)&quot;, body: &quot;Tap to increment&quot;), style: .large) .didSelect { [weak self] _ in self?.count += 1 } } 总结 到这里让我们总结一下，借助 Epoxy 的机制我们应该如何刷新列表。 方法 描述 推荐指数 使用不同的 dataID 比如声明一个 enum DataID { case some(value: String) }，每次刷新时修改 value 的值。 或者将 dataID 和数组的下标做对应，这样在移动 Cell 时，相当于同一个 ItemModel 的 Content 发生了变化。 🌟 使用不同的 Style 将需要变化的值定义在 Style 里，刷新 Style 后刷新列表 🌟🌟 利用 Equatable，修改 Content 确保 Content 的判等逻辑符合您的要求，修改 Content 后刷新列表 🌟🌟🌟🌟 有一个刷新之外的引申话题，上文也提到过，那就是什么样的数据该放到 Style 中。希望看完这篇文章后，对于这个问题你也能有新的思考和理解。 想必对于聪明的你来说，上述分析过程有点太简单了，只要稍微深入追一下代码，就能梳理清楚这些情况。甚至 Epoxy 的 demo 和文档中已经介绍的很清楚了。 但是有的时候，生活就是这么诡异。不把这些过程写下来的话，对于使用还不熟练的我而说，经常会陷入文章开头的疑问：“为什么列表刷新后数据没变” 和 “为什么它刷新后数据就变了”。也就是说即使我们知道了 “当 Content 不一致时刷新列表，列表数据会发生变化” 并按之付出实践时，依然会有不生效的情况发生。 这篇文章还不是完全体，日后当我再次发现刷新失效的情况时，我将完善这篇文章，补充对应的解决方案。 ","link":"https://blog.rakuyoo.top/refresh-epoxy-list/"},{"title":"Lazy var 的线程安全问题","content":"Swift 的 lazy 关键字一直有一个很容易被忽略的问题，那就是它不是线程安全的。 在官方文档中有这么一段描述： Note If a property marked with the lazy modifier is accessed by multiple threads simultaneously and the property hasn’t yet been initialized, there’s no guarantee that the property will be initialized only once. 官方自己也说了，如果多线程同时访问，可能导致初始化两次。 一般情况下我们不太会遇到这种问题，都是在 viewDidLoad 中添加、布局子视图，但是少数情况还是有可能会碰到这个问题，所以需要注意。 lazy var void 与 dispatch_once Xcode 16 &amp; Swift 6 以前 除了用 lazy 修饰 UI 视图之外，另一个可能比较常见的用法是用 lazy var void 代替 dispatch_once。 在中文互联网上能搜到很多这种用法，但是读到这里你应该能发现，这种用法其实也是线程不安全的，因为它用的是线程不安全的 lazy 关键字修饰。 在《Migrating to Swift 3》，官方明确提到了代替 dispatch_once 的办法： The free function dispatch_once is no longer available in Swift. In Swift, you can use lazily initialized globals or static properties and get the same thread-safety and called-once guarantees as dispatch_once provided. Example: let myGlobal = { … global contains initialization in a call to a closure … }() _ = myGlobal // using myGlobal will invoke the initialization code only the first time it is used. 请注意，示例中使用的是 let，并且是 lazily initialized globals 或者 static properties。众所周知，static 修饰或者顶层属性的初始化都是延迟初始化，再配合上线程安全的 let 定义，这才可以达到和 dispatch_once 相同的效果。 所以综上，建议使用 static let void 来代替 lazy var void。 <!-- ### Xcode 16 & Swift 6 那么在最新的 Xcode 16 中呢？ Xcode 16 会自动添加 `@MainActor`， ->","link":"https://blog.rakuyoo.top/thread-safety-with-lazy/"},{"title":"在 Xcode playground 中预览 View 视图","content":"记录一个总是忘记的操作： import UIKit import PlaygroundSupport let image = UIImage(named: &quot;winnie.png&quot;) let imageView = UIImageView(image: image) PlaygroundPage.current.liveView = imageView 在 Xcode playground 中，如果引入 PlaygroundSupport 库，赋值 PlaygroundPage.current.liveView，可以将视图显示在右侧的预览框，也就是 Live View 中。 另外不只是 UIView，UIViewController 及其子类也是可以的，PlaygroundPage.current.liveView = controller 即可。 ","link":"https://blog.rakuyoo.top/preview-in-xcode-playground/"},{"title":"epoxy源码笔记2：在扩展中定义存储属性","content":"常规的在扩展中定义存储属性的方法是借助 Objective-C 的 runtime 进行属性关联。但是这个方法仅限于 ObjC 类，那么纯 Swift 类，比如结构体该怎么办呢？ 在 epoxy 这个库中发现了解决办法。 Objective-C runtime 先说一下用 Objective-C runtime 的实现方式，比如下面的代码： private var loadingViewKey: Void? extension HUDProtocol { public var loadingView: LoadingView { get { if let view = objc_getAssociatedObject(self, &amp;loadingViewKey) as? LoadingView { return view } loadingView = LoadingView() return loadingView } set { objc_setAssociatedObject(self, &amp;loadingViewKey, newValue, .OBJC_ASSOCIATION_RETAIN_NONATOMIC) } } } 使用 loadingViewKey 关联 loadingView 属性，同时 get 方法内还做了一次懒加载。对于 Key 的定义形式多种多样，这里就不做过度赘述。 值得一提的是，翻看 epoxy 代码中发现，在使用关联属性给 ObjC 类增加存储属性时，还是用到了 @nonobjc。因为它是一个纯 Swift 库，所以使用 @nonobjc 来避免生成 objc 接口也是很合理的优化。 Epoxy 中的做法 让我们先看一下源码，比如 DidChangeStateProviding.swift 这个文件，其中内容如下： 我会省略掉一些和本文无关的注释和内容，完整的内容请点击上方链接查看原始代码。 extension CallbackContextEpoxyModeled { public typealias DidChangeState = (CallbackContext) -&gt; Void public var didChangeState: DidChangeState? { get { self[didChangeStateProperty] } set { self[didChangeStateProperty] = newValue } } private var didChangeStateProperty: EpoxyModelProperty&lt;DidChangeState?&gt; { .init(keyPath: \\Self.didChangeState, defaultValue: nil, updateStrategy: .chain()) } } 可以看到上述代码扩展了 CallbackContextEpoxyModeled，并在其中定义了存储属性 didChangeState。 细看 didChangeState，发现用到了 subscript 语法。接着查看 CallbackContextEpoxyModeled 的声明： public protocol CallbackContextEpoxyModeled: EpoxyModeled { associatedtype CallbackContext } 发现仅仅是一个协议。接着往下看，它所遵循的 EpoxyModeled 在这里进行定义。 关键代码如下： public protocol EpoxyModeled { /// The underlying storage of this model that stores the current property values. var storage: EpoxyModelStorage { get set } } extension EpoxyModeled { /// Stores or retrieves a value of the specified property in `storage`. public subscript&lt;Property&gt;(property: EpoxyModelProperty&lt;Property&gt;) -&gt; Property { get { storage[property] } set { storage[property] = newValue } } } 从这里感觉EpoxyModeled就是一个壳，用来封装 storage 这个属性。上面提到的 subscript 语法其实也是对 storage 的 subscript 的调用。 但是这里就复杂了一些，同时出现了 EpoxyModelStorage 和 EpoxyModelProperty 两个类型。让我们先看一下 EpoxyModelStorage。 EpoxyModelStorage 该类型在这里进行定义。 依然贴出来一些关键代码： public struct EpoxyModelStorage { public init() { } /// Stores or retrieves the value of the specified property. public subscript&lt;Property&gt;(property: EpoxyModelProperty&lt;Property&gt;) -&gt; Property { get { guard let propertyStorage = storage[property.keyPath] else { return property.defaultValue() } // This cast will never fail as the storage is only settable via this subscript and the `KeyPath` key is unique for any provider and value type pair. // swiftlint:disable:next force_cast return propertyStorage.value as! Property } set { // We first update the value without using the `updateStrategy` since the likely scenario // is that there won't be a collision that requires the `updateStrategy`, and we'll be able to // return without incurring the cost of another write. let propertyStorage = PropertyStorage(value: newValue, property: property) guard var replaced = storage.updateValue(propertyStorage, forKey: property.keyPath) else { return } // This cast will never fail as the storage is only settable via this subscript and the // `KeyPath` key is unique for any provider and value type pair. // swiftlint:disable:next force_cast replaced.value = property.updateStrategy.update(replaced.value as! Property, newValue) storage[property.keyPath] = replaced } } // MARK: Private /// The underlying storage for the properties, with a key of the `EpoxyModelProperty.keyPath` and /// a value of the property's `PropertyStorage`. /// /// Does not include default values. private var storage = [AnyKeyPath: PropertyStorage]() } // MARK: - PropertyStorage /// A value stored within an `EpoxyModelStorage`. private struct PropertyStorage { /// The type-erased value of the `EpoxyModelProperty`. var value: Any /// The property's corresponding `EpoxyModelProperty`, erased to an `AnyEpoxyModelProperty`. var property: AnyEpoxyModelProperty } 可以看到在 EpoxyModelStorage 中定义了一个关键的存储属性 storage，该属性是字典类型，使用 KeyPath 做 Key，Value 是一个自定义属性。但是这里其实 PropertyStorage 不是重点，因为用到 PropertyStorage.property 的代码并不在本文的范围之内，所以我们可以将 storage 进行简化，就当作 [AnyKeyPath: Any] 类型来对待。 再回看 EpoxyModelStorage 的 subscript 实现，至此其实我们已经能明白 Epoxy 在 extension 中定义存储属性的原理：其实就是用 KeyPath 做 key，将存储属性对应的值存储到内部的一个字典属性中。 看到这里会不会有点失望？有的人还会说这是脱裤子放屁，理由如下： 在需要 extension 定义存储属性的类型里手动定义一个 [String: Any]，然后在 extension 里操作这个字典不也能达到一样的效果吗？还至于费这么大劲写这么多封装？ 而且一点也不灵活，不像是ObjC一样随写随用，无需更改原类型的定义。 还有，因为 protocol 是 public 的，那么 storage 必然会被暴露给外界，造成一定程度的隐患。 疑问暂且按下不表，再来看看 EpoxyModelProperty 这个类型。 EpoxyModelProperty 先看定义： public struct EpoxyModelProperty&lt;Value&gt; { /// Creates a property identified by a `KeyPath` to its provided `value` and with its default value if not customized in content by consumers. /// /// The `updateStrategy` is used to update the value when updating from an old value to a new value. public init&lt;Model&gt;( keyPath: KeyPath&lt;Model, Value&gt;, defaultValue: @escaping @autoclosure () -&gt; Value, updateStrategy: UpdateStrategy) { self.keyPath = keyPath self.defaultValue = defaultValue self.updateStrategy = updateStrategy } /// The `KeyPath` that uniquely identifies this property. public let keyPath: AnyKeyPath /// A closure that produces the default property value when called. public let defaultValue: () -&gt; Value /// A closure used to update an `EpoxyModelProperty` from an old value to a new value. public let updateStrategy: UpdateStrategy } // MARK: EpoxyModelProperty.UpdateStrategy extension EpoxyModelProperty { /// A closure used to update an `EpoxyModelProperty` from an old value to a new value. public struct UpdateStrategy { public init(update: @escaping (Value, Value) -&gt; Value) { self.update = update } /// A closure used to update an `EpoxyModelProperty` from an old value to a new value. public var update: (_ old: Value, _ new: Value) -&gt; Value } } // MARK: Defaults extension EpoxyModelProperty.UpdateStrategy { /// Replaces the old value with the new value when an update occurs. public static var replace: Self { .init { _, new in new } } /// Chains the new closure value onto the old closure value, returning a new closure that first calls the old closure and then subsequently calls the new closure. public static func chain() -&gt; EpoxyModelProperty&lt;(() -&gt; Void)?&gt;.UpdateStrategy { .init { old, new in guard let new = new else { return old } guard let old = old else { return new } return { old() new() } } } /// Chains the new closure value onto the old closure value, returning a new closure that first calls the old closure and then subsequently calls the new closure. public static func chain&lt;A&gt;() -&gt; EpoxyModelProperty&lt;((A) -&gt; Void)?&gt;.UpdateStrategy { .init { old, new in guard let new = new else { return old } guard let old = old else { return new } return { a in old(a) new(a) } } } // Add more arities as needed } EpoxyModelProperty 有三个属性：keyPath、defaultValue 和 updateStrategy。 keyPath 和 defaultValue 配合范型可以很好的解决 objc_getAssociatedObject 中类型转换的问题，我们可以回看上面提到过的这个代码片段： // This cast will never fail as the storage is only settable via this subscript and the `KeyPath` key is unique for any provider and value type pair. // swiftlint:disable:next force_cast return propertyStorage.value as! Property 这也就解答了上面提到的第一个问题：如果仅仅定义一个 [String: Any]，那么 String 类型的 Key 和 Any 类型的 Value 明显无法保证对齐。 那么你可能想说改成 [KeyPath: Any] 呢？答案也是不行的。因为在调用 subscript 时，如果直接使用 KeyPath，则会触发系统默认的通过 KeyPath 取值的方法，不会走自定义的 subscript，所以 Map 的 Key 无论如何都需要自定义类型来包一层，既然要包一层，何不直接连 defaultValue 也封装一下呢？ 至于 updateStrategy 定义了属性赋值时的方法，是替换原值？还是两个值都执行？虽然它和本文内容无关，但是这个实用的属性确实也是 EpoxyModelProperty 的必要性之一。 解决疑问 针对上述三个问题： 为何不手动定义 [String: Any]？epoxy 属于过度封装 缺乏灵活性，而且需要更改原类型的定义。对于无法更改定义的类型，则无法使用这个方法。 因为 protocol 是 public 的，导致 storage 会被暴露给外界，造成一定程度的隐患。 针对第一个问题，用 protocol 规范属性定义在 Swift 中绝对不算是过度封装，而是很常见的方法；因为无法直接使用 KeyPath 类型作为 Map 的Key，为了保持类型安全，在上层调用中也无法直接使用 AnyKeyPath，所以必然需要自定义一个类型来做调用链中的 “索引”。 而且其他两个问题确实是实际存在的。特别是第二个问题，除非使用 objc_getAssociatedObject 来实现相关协议，否则则无法使用这套方法。 至于第三个问题，考虑到外部对该类型的扩展性，暴露 storage 属性给外界是必然的，否则外部如何给这个类型增加新的存储属性呢？除非你明确不允许外部给这个类型增加存储属性，那么你可以使用一个 internal type 包一层 Map。 简化代码 现在让我们学以致用，考虑一下如何简化代码。 关键类型是三个协议：EpoxyModeled、EpoxyModelStorage 和 EpoxyModelProperty，简化肯定也是针对这三个类型进行简化。 但是其实可以删减的空间并不多，仅仅在你不需要 updateStrategy 时，可以将实现简化为下面的这样： public struct ModelProperty&lt;Value&gt; { public init&lt;Model&gt;( keyPath: KeyPath&lt;Model, Value&gt;, defaultValue: @escaping @autoclosure () -&gt; Value ) { self.keyPath = keyPath self.defaultValue = defaultValue } public let keyPath: AnyKeyPath public let defaultValue: () -&gt; Value } public struct ModelStorage { private var storage = [AnyKeyPath: Any]() public init() { } public subscript&lt;Property&gt;(property: ModelProperty&lt;Property&gt;) -&gt; Property { get { guard let propertyStorage = storage[property.keyPath] else { return property.defaultValue() } return propertyStorage as! Property } set { storage[property.keyPath] = newValue } } } public protocol Modeled { var storage: ModelStorage { get set } } extension Modeled { public subscript&lt;Property&gt;(property: ModelProperty&lt;Property&gt;) -&gt; Property { get { storage[property] } set { storage[property] = newValue } } } 其实上述代码也就相当于 updateStrategy = .replace 的情况。不过，查看这份简化的代码是不是感觉整个逻辑都更清晰了呢😏 在调用上和原本实现也没有区别： struct Action: Modeled { var storage = ModelStorage() } extension Action { var testString: String { get { self[testStringProperty] } set { self[testStringProperty] = newValue } } private var testStringProperty: ModelProperty&lt;String&gt; { .init(keyPath: \\Self.testString, defaultValue: &quot;default&quot;) } } var testAction = Action() print(testAction.testString) // &quot;default&quot; testAction.testString = &quot;123&quot; print(testAction.testString) // &quot;123&quot; 对了，Modeled 中的 subscript 其实属于简化代码的操作，如果去掉这部分代码，那么在 testString 的 get 和 set 中，使用 self.storage[testStringProperty] 也是可以的，不影响主要逻辑。 ","link":"https://blog.rakuyoo.top/epoxy-source-code-notes-2/"},{"title":"Github Action：在步骤之间共享数据","content":"Github Action 各个 Setp 之间是互相独立的，所以假如我们在 A Step 中定义了一个环境变量，在接下来的 Step 中是无法使用的。 那么怎么共享呢？在最新的 Github Action 中，可以通过 Environment files 来实现。 Environment files 它的做法是通过一个环境变量配置文件，在各个Step之间共享自定义环境变量。 官方的例子如下所示： steps: - name: Set the value id: step_one run: | echo &quot;action_state=yellow&quot; &gt;&gt; &quot;$GITHUB_ENV&quot; - name: Use the value id: step_two run: | printf '%s\\n' &quot;$action_state&quot; # This will output 'yellow' echo &quot;action_state=yellow&quot; &gt;&gt; &quot;$GITHUB_ENV&quot; 这段就是关键代码了。 被抛弃的 set-env 如果你在 Google 上搜索过这个问题的话，你可能会搜到这篇文章：GitHub Actions 第15天：在步骤之间共享数据。 这篇文章中提到的 set-env 方法，在后续的 Github Action 中被禁止使用了，详见官方博文：GitHub Actions: Deprecating set-env and add-path commands 在本文撰写时，如果在 Github Action 中没有经过任何配置地去使用 set-env 的话，会直接报错，Step 执行失败。 “Environment files” 的做法也并不麻烦，反而觉得比 set-env 简单很多，所以就使用上面的方法吧。 ","link":"https://blog.rakuyoo.top/share-env-between-steps-in-github-action/"},{"title":"UIImage.size And CGImage.size","content":"记录一个最近发现的小细节：UIImage.size 和 CGImage.size 在一些情况下是不相等的。 如果你的图片是添加到 Assets.xcassets 并设置了 1x、2x 等不同规格，那么 UIImage.size 的大小将始终等于 1x 时候的尺寸，不论当前机型实际使用了哪种规格的图片。 而 CGImage.size 返回的则是 UIImage.size * ImageScale 之后的结果。也就是说如果该图片是 2x 图，那么 CGImage.size 就会是 UIImage.size 的二倍。 这一问题在使用 CGImage 画图会暴露出来，很多时候会使用 UIImage.size 或者 UIImageView.size 设置画布，然而因为忽略了 CGImage.size，就会导致画出来的图片尺寸偏大，出现显示的图片被剪裁的问题。 ","link":"https://blog.rakuyoo.top/uiimage-size-and-cgimage-size/"},{"title":"加速 git submodule","content":"iOS 中有一个第三方数据库封装：GRDB。该组件使用了 git submodule 来依赖 SQLiteLib。 这个时候如果我们只使用之前介绍过的 设置 SPM Mirror，那么这个子模块就会是一个漏网之鱼。 那么怎么为这个子模块设置镜像呢？我们可以使用 git config --global url.[New].insteadOf [Old] 命令来替换 url 中的某个部分。可以参考：Easier Git Repository Cloning with insteadOf New 是镜像 url，而 Old 是 github url，设置后我们可以通过 git config --global -l 或者 git config --global -e 命令来查看是否设置成功。 设置成功后不论是执行 git clone 或者 git submodule update --init，都会通过镜像 url 去执行了。 ","link":"https://blog.rakuyoo.top/speed-up-git-submodule/"},{"title":"提取ipa文件","content":"有的时候我们想要看看某个 App 的资源文件，或者单纯看看它引用了哪些三方库等。这些内容只要有一个 ipa 文件就可以看，也无需砸壳。 本文就记录一下如何简单的提取手机中 App 的 ipa 文件。 首先确保手机上已经安装了该 app。 随后在 mac 上下载 Apple 的官方软件 Apple Configurator 安装后打开，手机连接Mac后会在软件上显示当前设备，如下所示： 选中设备，随后点击右上角的 “添加” 按钮，选择 App： 在弹出的列表中选择要提取 ipa 的 App，随后点击 “添加” 按钮： 这一步有可能会提示你要登陆 Apple ID。出现这种情况要么是你的 Mac 没有登录，要么是你的手机和 Mac 登录的不是同一个 ID。按照提示登录即可。 因为我们的手机上已经安装了该 app，所以 Apple Configurator 肯定是装不上的，会弹出下面的弹窗： 此时不要操作 Apple Configurator！打开 Finder 访达 App，使用快捷键 Command + Shift + G 打开跳转弹窗，在弹窗中输入下面的路径： ~/Library/Group Containers/K36BKF7T3D.group.com.apple.configurator/Library/Caches/Assets/TemporaryItems/MobileApps/ 进到路径下，一层层点到最里面，就可以找到我们需要的 ipa 包了： Apple Configurator 弹窗关闭后，该 ipa 就会自动删除。所以请在关闭软件之前将 ipa 拷贝出来。 ","link":"https://blog.rakuyoo.top/extract-ipa-file/"},{"title":"Tuist 注意事项","content":"最近在学习使用 Tuist 生成项目，摆脱烦人的 .xcodeproj。但是 Tuist 好用虽然好用，但是因为最近文档正在迁移，加之一些东西只能从示例中发掘，整个学习过程有点费劲。所以开一篇文章记录一下。 UIKit 模版 在有的地方你可以看到 “通过 tuist init --template swiftui 创建 SwiftUI 项目”。也就是说默认是创建 UIKit 项目。 但是！UIKit 的模板已经在这个 PR 中被删除精简掉，并跟随 4.0.0 版本一起发布了。所以如果你使用的是 4.0+ 版本的 Tuist，那么执行 init 操作后默认生成的就是 SwiftUI 项目了。 官方认为大多数人已经迁移到SwiftUI了... 所以如果你想创建 UIKit 项目，那么你有两种（或者更多）选择： 手动把 UIKit 模板从该 PR 中找回来。 每创建一个项目都手动修改一下 Info.plist 以及添加 AppDelegate 等文件。 因为我是第一次使用，所以是手动添加的相关文件。 如果采用这种方法，那么有可能会遇到这个问题：解决从SwiftUI迁回UIKit时，SceneDelegate不执行的问题。之前已经为这个问题单独发过一片文章了，这里再重复提一下。 资源生成 Tuist 集成了 SwiftGen 来实现资源生成，所以 SwiftGen 的模板可以直接拿到 Tuist 里使用。 Tuist 的默认模块在这里：Templates。 以文件资源的生成为例，这个默认模板 和 SwiftGen 的 structured-swift5.stencil 模板几乎一样，只是多了一些 SwiftFormat 和 SwiftLint 的内容。 不包含目录层级 SwiftGen 对于一种资源有多个默认模版，比如文件资源还有 flat-swift5.stencil 这个不包含文件夹层级的模版。单独使用 SwiftGen 的话我们可以通过 --templateName 参数来使用该模板，但是 Tuist 里每种类型的资源只有一种模板。 所以如果我们想生成的资源不包含文件夹目录层级，只能参考Tuist官方文档的内容自定义模板： If you want to provide your own templates to synthesize accessors to other resource types, which must be supported by SwiftGen, you can create them at Tuist/ResourceSynthesizers/{name}.stencil, where the name is the camel-case version of the resource. Resource Template name strings Strings.stencil assets Assets.stencil plists Plists.stencil fonts Fonts.stencil coreData CoreData.stencil interfaceBuilder InterfaceBuilder.stencil json JSON.stencil yaml YAML.stencil files Files.stencil 注意，官方的这个方法其实是替换了默认实现，相关代码应该是这里。 如果你不想覆盖默认实现，想要自定义一个模板，可以参考app_with_plugins这个示例。 自定义解析类型 文档最后的部分有提到，可以通过 Project.resourceSynthesizers 属性来设置本项目自动为哪些类型的资源生成相应的代码。 这个属性是有默认值的，其默认值定义在这里： extension [ResourceSynthesizer] { public static var `default`: Self { [ .strings(), .assets(), .plists(), .fonts(), ] } } 可见使用的是默认模板，而且不包含 .files。如果有需要的话则需要手动添加。 禁用资源生成 虽然你大概率不需要，不过还是提一嘴。文档中也有说明，那就是可以通过设置 Project.Options.disableSynthesizedResourceAccessors 属性，来禁用资源的自动生成。 组件化 Tuist 应该是实施组件化的好手。 目录结构 首先让我们来讨论一下目录结构，这关系到我们如何组织主项目和各个组件。 在官方文档里我们能看到如下目录结构： Tuist/ Config.swift Package.swift ProjectDescriptionHelpers/ Projects/ App/ Project.swift Feature/ Project.swift Workspace.swift Tuist 文件夹是 Tuist 的一些配置，Workspace.swift 用来包含各个 Projects。 但是如果你仔细翻看过他们的示例的话，比如 ios_app_with_static_frameworks 和 ios_app_with_framework_and_resources，就会发现其实根目录下的内容是多变的。 如果你跟我一样好奇 “什么是最佳实践”，可以看这个讨论。然后结论就是：没有什么最佳实践，完全取决于你的个人用法和习惯。 Tuist 真的非常灵活，提供了很多便捷的写法，不同人用 Tuist 会写出不同的配置文件，也会有不同的用法。 Tuist vs SPM 对目录结构有了一些概念之后，就该考虑如何组织各个组件了。 官方文档里有一篇文章：Migrate local Swift Packages 讲的是如何将本地的 SPM 组件迁移到 Tuist，改为使用 Tuist 管理。 国外应该是已经没有什么人用 CocoaPods 做组件化管理了？... 这里我也推荐使用 Tuist + Multiple Projects 来做子组件。首先 SPM 要比 CocoaPods 更现代更官方，但是 SPM 本身有性能问题，再加上国内访问问题，所以真要实际用起来很麻烦。另外使用 Tuist 来管理项目，可以使用自带的 SwiftGen，不用再在 SPM 里进行相关配置。最后不得不提的是，用 Tuist 加载依赖是真的快... 单独运行组件 我个人对组件化的标准是每个子组件应该都能独立编译，进一步能独立运行。基于这个标准的话，会有一些问题。 善用软链接 项目根目录下的 Tuist/ProjectDescriptionHelpers 是不能被子项目读取的，比如前文提到的目录结构中： Tuist/ Config.swift Package.swift ProjectDescriptionHelpers/ Projects/ App/ Project.swift Feature/ Project.swift Tuist/ Config.swift Package.swift Workspace.swift 在 Projects/Feature 中执行 tuist generate 命令时，是读取不到根目录中 Tuist/ProjectDescriptionHelpers 里的公共方法的。 一个可行的方法是使用软链接，将 ProjectDescriptionHelpers 文件夹软链到 Projects/Feature/Tuist 里。 同理 Tuist/.swiftpm/configuration/mirrors.json 文件也可以这么做。 是否需要多个 Config.swift 经过进一步实践，以及相关 讨论，发现其实不建议 有多个 Config.swift 文件。所以 Feature/Tuist/Config.swift 文件应该是没有必要的。 我现在使用的目录结构如下所示： Tuist/ Config.swift Package.swift ProjectDescriptionHelpers/ Projects/ App/ Project.swift Components/ FeatureA/ Project.swift FeatureB/ Project.swift Workspace.swift 也就是说各个组件内完全没有 Tuist 文件夹（依赖部分在 Tuist/ProjectDescriptionHelpers 进行了封装） 这时假如我们在 Projects/Components/FeatureA 目录下执行 tuist generate，其实读取的是根目录中 Tuist 的配置，生成的是 App 项目而不是组件项目。 这个时候肯定是不能满足 “组件独立运行” 的，因为现在这个组件算是一个 lib，没有前端 AppDelegate 等相应入口去运行 App。 那么为什么还要改成这种方式呢？一是基于官方推荐的不要使用多个 Config.swift 的建议；二是和群友讨论后，发现一般测试一个 lib 时会单独建一个测试项目，比如 FeatureATest，该测试项目不在 FeatureA 下；三是理想很丰满现实很骨干，话是这么说，但是实际上几乎不会单独运行某个 lib。 所以基于以上三个理由，如果未来需要单独测试某个 lib，那么最佳实践应该是新建一个相关的 Test 项目。 ","link":"https://blog.rakuyoo.top/tuist-notes/"},{"title":"解决从SwiftUI迁回UIKit时，SceneDelegate不执行的问题","content":"最近在研究 Tuist，一个用来管理 Xcode 项目的工具。这个工具好像从 4.0 版本开始，创建新项目默认就是 SwiftUI 模版了，所以需要手动再从 SwiftUI 改回 UIKit。 在改动过程中发现 SceneDelegate 不执行，搜索了一番后找到了解决方案，在此记录一下。 具体的改动方法和流程可以参考：How to migrate from SwiftUI to UIKit App Delegate Life Cycle in Xcode 解决方案出自这里：App migrated to UIKit lifecycle doesn't call SceneDelegate 插一嘴，真没想到还会有其他人也遇到了这个问题... 如上述问题里所讲的那样，这个 bug 的根本问题可能是： do not turn off support multiple windows. It seems that disabling multiple windows prevents UIKit from launching a new scene when the previous scene is no longer available. 也就是说 SwiftUI 的 @main 入口没了，同时因为不支持多窗口，所以导致在当前场景不可用时，无法创建 SceneDelegate 的新场景。 解决方案除了把设备上的 app 删除重新安装之外，还可以把 Info.plist 中的 scene configurations manifest 删除，然后手动创建它： class AppDelegate: NSObject, UIApplicationDelegate { func application(_ application: UIApplication, configurationForConnecting connectingSceneSession: UISceneSession, options: UIScene.ConnectionOptions) -&gt; UISceneConfiguration { let configuration = UISceneConfiguration(name: nil, sessionRole: connectingSceneSession.role) if connectingSceneSession.role == .windowApplication { configuration.delegateClass = SceneDelegate.self } return configuration } } 注意，如果不删那么这个方法也是不会调用的，所以需要删除然后手动创建。 最后吐槽一下，真的没想到 iOS 就连这个也会有类似 “缓存” 的问题... 想到了 LaunchScreen ... ","link":"https://blog.rakuyoo.top/jie-jue-cong-swiftui-qian-hui-uikit-shi-scenedelegate-bu-zhi-xing-de-wen-ti/"},{"title":"CSS选择器","content":"CSS 有多种选择器，可以帮助我们针对不同的 HTML 标签设置样式。 选择器 通配符选择器 通配符选择器（*）可以选择任何元素，通常用于设置默认样式。 * { margin: 0; padding: 0; } 类型选择器 类型选择器（Type Selectors）直接使用 HTML 标签来选择选择元素： p { color: blue; } 上面的代码将所有的 &lt;p&gt; 标签文本渲染为蓝色。 class 选择器 个人理解 class 选择器代表着 “一类有着相同样式的标签”，所以该选择器可以用于多个 HTML 标签。 类选择器使用 . 开头，后接类名： &lt;style&gt; .first { font-weight: bold; text-decoration: line-through; } &lt;/style&gt; &lt;p class=&quot;first&quot;&gt;超越技术&lt;/p&gt; &lt;div&gt;哈哈.&lt;/div&gt; &lt;p&gt;一起学前端!&lt;/p&gt; 一个标签也可以包含多个 class，多个 class 之间使用空格分隔： &lt;!-- 包含两个 class：info 和 highlight --&gt; &lt;p class=&quot;info highlight&quot;&gt;...&lt;/p&gt; 此外，当你在不同的 HTML 标签中使用了相同的 class，然后还想选择某个具体的标签时，你可以像下面这样组合使用两个选择器： &lt;style&gt; p.first { color: red; } &lt;/style&gt; &lt;p class=&quot;first&quot;&gt;该颜色会是红色&lt;/p&gt; &lt;span class=&quot;first&quot;&gt;该颜色不会是红色&lt;/span&gt; id 选择器 个人理解这里的 id 在使用场景上就和数据库中的主键一样，可以用来定位某个唯一的 HTML 标签，所以该选择器或者说 id 属性的值，在 HTML 文档中需要是唯一的，不能出现在多个元素上。 id 选择器使用 # 号来定义： &lt;style&gt; #my-id { background-color: yellow; } &lt;/style&gt; &lt;p id=&quot;my-id&quot;&gt;超越技术&lt;/p&gt; &lt;div&gt;哈哈.&lt;/div&gt; &lt;p&gt;一起学前端!&lt;/p&gt; 因为 id 选择器的唯一性，所以就没必要像上面提到的 class 选择器一样，通过标签再进一步缩小选择范围了。 属性选择器 我们都知道可以在 html 标签上自定义任意的属性，比如下面的例子： &lt;!-- `data-rakuyo` 不是很好，因为它不明所以； 但是它又很好，可以一眼让你看出它是一个自定义属性。 --&gt; &lt;div data-rakuyo&gt;...&lt;/div&gt; 属性选择器使用 [] 中括号包裹属性名称。针对上面的代码，我们可以通过属性选择器来选择该 div 标签： /* 选择所有带有 `data-rakuyo` 属性的元素，不论其所属哪个 html 标签 */ [data-rakuyo] { font-weight: bold; } 再进一步缩小范围，属性选择器可以通过指定标签来筛选 “具有某些属性的标签”： /* 仅限带有 `data-style` 属性的 &lt;button&gt; 标签 */ button[data-style] { font-weight: bold; } 可以通过具体的属性值来做条件筛选： &lt;style&gt; [data-style=&quot;cancel&quot;] { color: gray; } [data-style=&quot;done&quot;] { color: black; } &lt;/style&gt; &lt;button data-style=&quot;cancel&quot;&gt;取消&lt;/button&gt; &lt;button data-style=&quot;done&quot;&gt;下单&lt;/button&gt; 属性选择器还可以借助一些匹配操作符，比如 $= 和 *= 来实现特定的功能： /* 选择 `src` 属性以 `https` 开头的所有图片 */ img[src^=&quot;https&quot;] { color: red; } /* 选择 `src` 属性以 `.jpg` 结尾的所有图片 */ img[src$=&quot;.jpg&quot;] { border: 3px solid black; } /* 选择 `href` 属性包含 `external` *字符串* 的所有链接 */ a[href*=&quot;external&quot;] { color: green; } /* 选择 `href` 属性包含 `external` *单词* 的所有链接 */ a[href~=&quot;external&quot;] { color: green; } 注意 *= 和 ~= 的区别。前者匹配字符串，而后者匹配的是一个完整的单词。 伪选择器 伪选择器包含 “伪类选择器” 和 “伪元素选择器” 两种。 伪类选择器 伪类选择器用于定义元素在特定状态下的样式，比如鼠标悬停时的样式。或者用于选择第n个子元素。 /* 设置表格中某一列的文字不换行 */ .nowrap-column { white-space: nowrap; } 对于特定状态，有以下几种： 名称 说明 示例 :hover 用于在用户将鼠标悬停在元素上时应用样式 a:hover { color: red; } :active 用于选取被用户激活（例如鼠标点击）的元素 button:active { background-color: gray; } :visited 用于选取用户已访问过的链接 a:visited { color: purple; } :focus 用于选取当前获取了焦点的元素通常在用户通过键盘或者鼠标进行交互时出现 input:focus { border-color: blue; } 对于选择子元素，有以下几种用法： 名称 说明 示例 :nth-of-type(n) 该选择器允许你选择相同类型的且特定位置的子元素请注意，n从1开始，且不能是负数 /* 这会使每隔两个段落文字变为红色 */ p:nth-of-type(2n) { color: red; } :nth-child(n) 该选择器允许你选择特定位置的子元素 /* 列表中的奇数项背景色变为浅灰色 */ li:nth-child(odd) { background-color: lightgray; } :nth-last-child(n) 该选择器与:nth-child(n)类似，但是它从元素的末尾开始计数。 /* * 这会使每个无序列表（ul）的 * 倒数第二个列表项（li）的文字颜色变为蓝色 */ ul li:nth-last-child(2) { color: blue; } :first-child“nth-child(1)” 该选择器选取某个元素的第一个子元素 /* * 这会使每个无序列表（ul）的第一个列表项（li）的文字加粗 */ ul li:first-child { font-weight: bold; } :last-child“nth-last-child(1)” 该选择器选取某个元素的最后一个子元素 /* * 这会使每个无序列表（ul） * 的最后一个列表项（li）的文字变为斜体 */ ul li:last-child { font-style: italic; } 我觉得 :nth-of-type 和 :nth-child 的概念比较接近，同时容易混淆，所以在这里特意将他们两个单独拿出来，用一个例子来看看这两个选择器之间的区别。 &lt;div class=&quot;container&quot;&gt; &lt;p&gt;Paragraph 1&lt;/p&gt; &lt;div&gt;Div 1&lt;/div&gt; &lt;p&gt;Paragraph 2&lt;/p&gt; &lt;p&gt;Paragraph 3&lt;/p&gt; &lt;div&gt;Div 2&lt;/div&gt; &lt;/div&gt; 针对上面这段 html，两个选择器的结果为： 选择器 结果 说明 .container p:nth-of-type(2) 选择到 &lt;p&gt;Paragraph 2&lt;/p&gt; 这个选择器将选择容器 .container 内的第二个 &lt;p&gt; 元素。在给定的 HTML 结构中，第二个 &lt;p&gt; 元素是 &quot;Paragraph 2&quot;，因此该选择器会影响到这个段落元素。 .container p:nth-child(2) 不会选择任何元素 这个选择器将选择容器 .container 内所有的 &lt;p&gt; 元素中的第二个子元素。在给定的 HTML 结构中，第二个子元素是 &quot;Div 1&quot;，而不是 &lt;p&gt; 元素。因此，这个选择器不会选择任何元素，因为在该结构中，第二个子元素不是 &lt;p&gt; 元素。 简而言之，nth-child(n) 会先按照顺序选择父视图的子元素，再看该子元素是否符合限制条件，如果符合则样式生效，否则不会生效；而 nth-of-type(n) 则相反，会先选择符合要求的元素，再按照顺序进行选择。 同理可得，因为 :first-child、:last-child 和 :nth-child(1)、:nth-last-child(1) 相同，所以假如使用 p:fist-child，但是第一个标签不是 &lt;p&gt;，那么该样式也不会生效。 伪元素选择器 伪元素选择器用于选择元素的特定部分而不是元素本身。伪元素选择器以双冒号 :: 开头。 下面是一些常见的伪元素选择器： /* 选择元素的第一行文本 */ p::first-line { font-weight: bold; } /* 选择元素的第一个字母 */ p::first-letter { font-size: 150%; } /* 在元素内容之前插入内容 */ p::before { content: &quot;前置内容 &quot;; } /* 在元素内容之后插入内容 */ p::after { content: &quot; 后置内容&quot;; } /* 选择用户选中的文本部分 */ ::selection { background-color: yellow; color: black; } /* 选择输入框的占位符文本 */ input::placeholder { color: gray; } 除此之外还有一些不太常见的伪元素选择器： /* 选择列表项的标记部分（通常是列表项前面的符号，如圆点或数字） */ li::marker { color: red; } /* 选择元素的背景层，用于处理全屏元素的背景样式 */ dialog::backdrop { background-color: rgba(0, 0, 0, 0.5); } /* 选择拼写错误的文本部分 */ ::spelling-error { text-decoration: underline wavy red; } /* 选择语法错误的文本部分 */ ::grammar-error { text-decoration: underline dashed blue; } 组合选择器 组合选择器是 CSS 中的一种选择器，允许你针对同时满足多个条件的元素应用样式。 后代选择器 后代选择器（Descendant Selector）允许你选择某个元素内部的所有后代元素。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Descendant Selector Example&lt;/title&gt; &lt;style&gt; /* 选择 .container 内部的所有 p 元素 */ .container p { color: blue; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;p&gt;This is a paragraph.&lt;/p&gt; &lt;div&gt; &lt;p&gt;This is another paragraph.&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 在这个例子中，.container p 选择器会选择所有嵌套在 .container 内部的 &lt;p&gt; 元素，并将它们的颜色设为蓝色。即两个 &lt;p&gt; 标签都会变成蓝色。 子选择器 子选择器（Child Selector）用于选择某个元素的直接子元素。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Child Selector Example&lt;/title&gt; &lt;style&gt; /* 选择 .container 下的直接子元素 p */ .container &gt; p { font-weight: bold; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;p&gt;This is a paragraph.&lt;/p&gt; &lt;div&gt; &lt;p&gt;This is another paragraph.&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 这个例子中，.container &gt; p 选择器只会选择 .container 直接子元素中的 &lt;p&gt; 元素，并将它们的字体加粗。而里层的 This is another paragraph. 并不会被加粗。 对比 后代选择器 来看，后代选择器会一直查询到该叶子节点的最末端，渲染所有满足条件的标签，不管中间是否还有其他标签；而 子选择器 只会渲染下一个层级（直接）的子节点，并不会进一步深入。 相邻兄弟选择器 相邻兄弟选择器（Adjacent Sibling Selector）选择紧接在指定元素后的兄弟元素。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Adjacent Sibling Selector Example&lt;/title&gt; &lt;style&gt; /* 选择 .container 后面紧邻的 p 兄弟元素 */ .container + p { color: green; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;p&gt;This is a paragraph.&lt;/p&gt; &lt;/div&gt; &lt;p&gt;This is another paragraph.&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 在这个例子中，.container + p 选择器会选择紧接在 .container 元素后面的 &lt;p&gt; 元素，并将它们的颜色设为绿色。即 This is another paragraph. 会被渲染为绿色。 有以下几点需要注意： “相邻兄弟选择器” 强调 相邻。如果我们将代码进行修改： &lt;div class=&quot;container&quot;&gt; &lt;p&gt;This is a paragraph.&lt;/p&gt; &lt;/div&gt; &lt;span&gt;123&lt;/span&gt; &lt;p&gt;This is another paragraph.&lt;/p&gt; 此时 .container 不再有任何相邻的 &lt;p&gt; 节点，所以 .container + p 不会选择任何的标签进行渲染。 “相邻兄弟选择器” 只会渲染相邻的 一个 节点。如果我们将代码进行修改： &lt;div class=&quot;container&quot;&gt; &lt;p&gt;This is a paragraph.&lt;/p&gt; &lt;/div&gt; &lt;p&gt;This is another paragraph. 1&lt;/p&gt; &lt;p&gt;This is another paragraph. 2&lt;/p&gt; 那么只有相邻的第一个 &lt;p&gt; 标签，即 This is another paragraph. 1 会被渲染为绿色，另外一个 &lt;p&gt; 标签仍为黑色。 通用兄弟选择器 通用兄弟选择器（General Sibling Selector）选择与指定元素相邻的所有兄弟元素。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;General Sibling Selector Example&lt;/title&gt; &lt;style&gt; /* 选择 .container 后的所有 p 兄弟元素 */ .container ~ p { font-style: italic; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;p&gt;This is a paragraph.&lt;/p&gt; &lt;/div&gt; &lt;p&gt;This is another paragraph.&lt;/p&gt; &lt;p&gt;This is yet another paragraph.&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 在这个例子中，.container ~ p 选择器会选择紧跟在 .container 元素后的所有 &lt;p&gt; 元素，并将它们的字体样式设为斜体。很容易看出来，该选择器和 相邻兄弟选择器 互为一对。 组合选择器总结 后代选择器（ ） 和 子选择器（&gt;） 互为一对：同样是选择子元素，前者会深入到层级的最末端，而后者只会选择下一个层级，点到为止。 相邻兄弟选择器（+） 和 通用兄弟选择器（~） 互为一对：同样是选择相邻元素，前者只选择同层级内相邻的节点，而后者会选择同层级内所有符合条件的节点。 课后思考 现在我们提出来这么一个需求：从接口处获取商品的价格（忽略接口请求步骤），得到一个价格字符串，比如 &quot;¥35.66&quot;。针对该字符串进行渲染，要求如下： 文字颜色均为红色。 ¥ 和 .66 部分样式一致：15号字。但是需要注意 ¥ 符号并不一定存在。 35 部分加粗，18号字。 使用 js+html+css，留几秒钟思考给出答案。 ... ... ... ... ... 参考答案如下： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;style&gt; /* 样式1：¥符号 15 号字，红色 */ .currency-sign, .after-dot { font-size: 15px; } /* 样式2：¥ 和 . 之间的内容，18号字，加粗，红色 */ .between { font-size: 18px; font-weight: bold; } .currency-sign, .after-dot, .between { color: red; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;span class=&quot;currency-value&quot;&gt;&lt;/span&gt; &lt;!-- 使用 JavaScript 定义变量 --&gt; &lt;script&gt; // 定义变量，代替接口请求的步骤 const currencyValue = &quot;¥35.66&quot;; // 获取 span 标签 const spanElement = document.querySelector('.currency-value'); // 检查 span 标签是否存在 if (spanElement) { // 检查 currencyValue 是否包含 &quot;¥&quot; 符号 if (currencyValue.includes('¥')) { // 渲染 ¥ 符号 const currencySignSpan = document.createElement('span'); currencySignSpan.innerText = '¥'; currencySignSpan.classList.add('currency-sign'); spanElement.appendChild(currencySignSpan); } // 删去 &quot;¥&quot; 符号后的值 let valueWithoutSign = currencyValue.replace('¥', ''); // 按 &quot;.&quot; 分隔值 const [beforeDot, afterDot] = valueWithoutSign.split('.'); // 渲染 &quot;.&quot; 之前的内容 const beforeDotSpan = document.createElement('span'); beforeDotSpan.innerText = beforeDot; beforeDotSpan.classList.add('between'); spanElement.appendChild(beforeDotSpan); // 渲染 &quot;.&quot; 符号 和 &quot;.&quot; 之后的内容 const afterDotSpan = document.createElement('span'); afterDotSpan.innerText = '.' + afterDot; afterDotSpan.classList.add('after-dot'); spanElement.appendChild(afterDotSpan); } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 然后我们可以再进一步，如果改成 vue3 + TypeScript 呢？ &lt;template&gt; &lt;span class=&quot;currency-value&quot;&gt; &lt;span v-if=&quot;hasCurrencySign&quot; class=&quot;currency-sign&quot;&gt;¥&lt;/span&gt; &lt;span class=&quot;between&quot;&gt;{{ beforeDot }}&lt;/span&gt; &lt;span class=&quot;after-dot&quot;&gt;.{{ finalAfterDot }}&lt;/span&gt; &lt;/span&gt; &lt;/template&gt; &lt;script setup lang=&quot;ts&quot;&gt; import { ref } from 'vue'; const currencyValue = ref&lt;string&gt;(&quot;¥35.66&quot;); const hasCurrencySign = currencyValue.value.includes('¥'); const [beforeDot, afterDot] = currencyValue.value.replace('¥', '').split('.'); const finalAfterDot = afterDot || '00'; &lt;/script&gt; &lt;style scoped&gt; /* 样式1：¥符号 15 号字，红色 */ .currency-sign, .after-dot { font-size: 15px; } /* 样式2：¥ 和 . 之间的内容，18号字，加粗，红色 */ .between { font-size: 18px; font-weight: bold; } .currency-sign, .after-dot, .between { color: red; } &lt;/style&gt; 可见因为 vue 中的模版可以直接引用变量，为我们减少了大量的 DOM 操作，代码量得以减少了不少。 ","link":"https://blog.rakuyoo.top/css-selector/"},{"title":"HTML 元素显示模式","content":"记录前端的学习过程。 本篇文章是最基础的 HTML 部分。 元素显示模式 HTML 元素一般分为 “块元素” 和 “行内元素”。 块元素 &lt;div&gt; 是最典型的块元素。其余的还有 &lt;h1&gt; ~ &lt;h6&gt;、&lt;p&gt;、&lt;ul&gt;、&lt;ol&gt;、&lt;li&gt; 等。 特性： 独占一行 高度、宽度、外边距和内边距都可以控制 宽度默认是容器（父级宽度）的 100% 是一个容器及盒子，里面可以放行内或者块级元素 注意： 文字类元素内部不能使用块级元素 &lt;p&gt; 标签主要用于存放文字，因此 &lt;p&gt; 里面不能放块级元素，特别是不能放 &lt;div&gt; 同理，&lt;h1&gt; ~ &lt;h6&gt; 等都是文字类块级标签，里面也不能放其他块级元素 行内元素 是最典型的行内元素。其余的还有 &lt;a&gt;、&lt;strong&gt;、&lt;b&gt;、&lt;em&gt;、&lt;i&gt;、&lt;del&gt;、&lt;s&gt;、&lt;ins&gt;、&lt;u&gt;等。 有的地方也将行内元素成为内联元素。 特性： 相邻行内元素在一行上，一行可以显示多个 宽、高直接设置是无效的 默认宽度就是它本身内容的宽度 行内元素只能容纳文本或其他行内元素。 注意： 链接里不能再放链接 特殊情况链接 &lt;a&gt; 里面可以放块级元素，但是给 &lt;a&gt; 转换成块级模式最安全 示例 下面这段代码可以作为一个简单的示例。 &lt;body&gt; &lt;h1&gt;《前端小课》&lt;/h1&gt; &lt;h2&gt; 一本帮你入门与进阶的前端书 &lt;!-- h2 和 p 都是块级元素，内部可以直接包含其他元素，比如 &lt;hr&gt; --&gt; &lt;!-- html 标签之间，默认好像是会有一些间距的。所以这个 &lt;hr&gt; 如果写在 &lt;p&gt; 外层，会有不一样的 ui 效果 --&gt; &lt;hr&gt; &lt;/h2&gt; &lt;!-- 用 div 这个块级元素包一下，可以保证代码占整行 不用 div 包裹，那么这个元素的大小就是 code 的大小 --&gt; &lt;div class=&quot;code-bg&quot;&gt; &lt;code&gt; const p = document.querySelector('p'); p.onclick = function() { alert('噢，噢，噢，别点我了。'); } &lt;/code&gt; &lt;/div&gt; &lt;/body&gt; ","link":"https://blog.rakuyoo.top/html-element-display-mode/"},{"title":"Jellyfin + tinymediamanager + TMM 刮削","content":"使用 tinymediamanager 配合 TMM（themoviedb）实现 Jellyfin 刮削。 网上现有的教程都比较老了，所以开一篇帖子记录一下自己配置的过程。 TMM API Key 因为是使用 TMM 来实现刮削，所以我们先上官网 申请一下 API Key。 首先你需要注册一个账号，注册账号比较简单，本篇不作介绍。 在初次登录，未配置过 API 的情况下，有两种方法让我们进入到 API 申请页面： 直接拉到页面最底部，点击 API 。 点击自己的头像，进入账户设置页面，然后点击列表左侧的 API 选项。 注意 申请过 API 之后就不能使用第一种方法了，会进入文档页面。只能使用第二种方法查看已经申请的 API。 在 API 选项页面，我们选择 Developer 类型，创建 API Key。 进入到信息填写页面，这里我借用一张别人的图做示例： 经过实际测试，有以下几点需要注意： 应用信息部分直接按照上图所示填写即可，一模一样就行。 姓名必须要使用英文。 地址信息找一个随机地址生成器生成一下即可。注意 地址1 和 地址2 都要有，可以是中文，两个一样也可以。 点击提交后即可完成申请，申请是秒过的，在新页面可以立刻查看到我们申请的 key： 有的文章附图里，标题显示的是 “API密钥（v3 auth）”。在 TMM 最新版里直接显示 “API 密钥” 了，其实是一回事。 NAS 配置 回到群晖 NAS 上，首先需要通过 docker 安装 tinymediamanager docker-compose 省流版，我做了一份 docker-compose 文件，如果您有编程经验可以直接参考使用： version: '3.8' services: tinymediamanager: container_name: tinymediamanager-tinymediamanager image: tinymediamanager/tinymediamanager:latest command: /app/tinyMediaManager -Dtmm.contentfolder=/data extra_hosts: - &quot;www.themoviedb.org:8.67.111.128&quot; - &quot;www.themoviedb.org:18.154.144.22&quot; - &quot;www.themoviedb.org:99.86.199.23&quot; - &quot;image.tmdb.org:84.17.46.53&quot; - &quot;image.tmdb.org:89.187.162.242&quot; - &quot;image.tmdb.org:138.199.46.66&quot; - &quot;api.themoviedb.org:13.33.33.60&quot; - &quot;api.themoviedb.org:13.224.167.10&quot; - &quot;api.themoviedb.org:99.84.192.81&quot; - &quot;api.thetvdb.org:192.241.234.54&quot; ports: - 4000:4000 volumes: - /volume1/video:/media:rw - /volume1/docker/tiny-media-manager/config:/config:rw - /volume1/docker/tiny-media-manager/data:/data:rw environment: PATH: &quot;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot; LANG: &quot;en_US.UTF-8&quot; LC_ALL: &quot;en_US.UTF-8&quot; USER_ID: &quot;0&quot; GROUP_ID: &quot;0&quot; APP: &quot;tinyMediaManager&quot; UMASK: &quot;0022&quot; ALLOW_DIRECT_VNC: &quot;true&quot; LC_TIME: &quot;C.UTF-8&quot; ENABLE_CJK_FONT: &quot;1&quot; restart: always privileged: true network_mode: bridge 该文件设置了以下内容： 容器名：tinymediamanager-tinymediamanager 配置了 hosts，解决 TMDB 访问问题 启用 “自动重新启动” 使用高级权限执行容器 端口号 4000 挂载以下路径，均为读写权限 本地 /volume1/video，挂载到容器内 /media 本地 /volume1/docker/tiny-media-manager/config，挂载到容器内 /config 本地 /volume1/docker/tiny-media-manager/data，挂载到容器内 /data 手动安装 如果不想使用 docker-compose 安装，可以手动安装 安装 tinymediamanager 在注册表中搜索 tinymediamanager，这里我们选择第二个官方镜像。 大部分教程不是选择第一个 star 最多的，就是选择第三个所谓 “中文更友好” 的。其实在 2024 年，官方的用起来才是最简单的。 下载完成之后，我们先不要打开，进入后续的配置流程。 创建 tinymediamanager 容器 首先通过 ssh 登录群晖，然后通过下面的命令运行 tinymediamanager docker。 这一步可以直接添加 host，解决 tinymediamanager 无法访问的问题。避免我们在后续进入 docker 容器内部修改 host。 但是主要注意一点的是，如果在 DSM 里手动关闭容器再重新启动，那么 host 配置就失效了。因为 TMM 容器内没有 vi，同时考虑以后再次修改，个人还是建议将 /etc/hosts 文件挂载出来，然后在文件内添加下列 host。 docker run \\ --name=tinyMediaManager \\ --add-host=www.themoviedb.org:8.67.111.128 \\ --add-host=www.themoviedb.org:18.154.144.22 \\ --add-host=www.themoviedb.org:99.86.199.23 \\ --add-host=image.tmdb.org:84.17.46.53 \\ --add-host=image.tmdb.org:89.187.162.242 \\ --add-host=image.tmdb.org:138.199.46.66 \\ --add-host=api.themoviedb.org:13.33.33.60 \\ --add-host=api.themoviedb.org:13.224.167.10 \\ --add-host=api.themoviedb.org:99.84.192.81 \\ --add-host=api.thetvdb.org:192.241.234.54 \\ tinymediamanager/tinymediamanager:latest 运行到下面这一步就 ok 了： 此时容器已经创建好，我们可以 ctrl+c 停止运行，然后回到 NAS 上停止该容器，准许后续的编辑。 配置 tinymediamanager 容器 在 docker 文件夹下新建一个 TinyMediaManager 目录，然后新建 data 文件夹。 在容器内找到刚才新创建好的容器，点击 详情-&gt;设置 进入配置。 端口号使用默认或根据你的实际情况填写。 文件夹挂载需要挂载两个，一个是刚才创建的 data 文件夹，另一个是你当前 存储影片 的文件夹。 环境变量需要注意以下几点： USER_ID 和 GROUP_ID 修改为 0（root用户）。 PASSWORD 可以直接删掉。 增加 ENABLE_CJK_FONT 这个 key，值为 1。 对于 ENABLE_CJK_FONT，老版的教程里都需要添加，为了切换为中文后正常显示。我在装最新版的时候直接加上了，没有测试不加可以不可以。 填完后我们就可以运行容器了。 官方镜像较其他镜像的优势 截止到本文发布，官方镜像已经来到了 5.x 的版本，而其他两个镜像还是 3.x 的版本。 相比较老版，新版的挂载目录从 /config 变为了 /data，默认端口从 5800 变为了 4000。 在对中文的支持上，最新的官方镜像对中文的支持已经很好了，不需要额外的配置。而其他两个镜像版本对中文的支持比较麻烦： 教程中往往提到我们需要将 /etc/cont-init.d/10-cjk-font.sh 文件中的 http://dl-cdn.alpinelinux.org 替换为 http://mirrors.tuna.tsinghua.edu.cn/。 此举是为了下载中文字体，然而如果我们使用的是 romancin 的镜像，那么就算替换了也没用，设置为中文依然会乱码。这是因为该字体在清华源下已经失效了（阿里云好像也失效了）。有网友提到华为云是有效的，经过测试确实可以。 最后，在刮削效率和结果上，也是新版更为出色。 tinymediamanager 配置 打开浏览器，输入 http://nas-ip:4000/ 进入 tinymediamanager。初始是一个英文的引导页面，我们一般直接 next 即可。 进入主页面后，我们进入设置，修改语言为中文。 ","link":"https://blog.rakuyoo.top/jellyfin-scraper-with-tmm/"},{"title":"群晖NAS公网访问配置（四）：配置云服务器","content":"假如我们没有公网 IP，或者公网 IP 出现故障暂时无法访问，那么我们可以借助云服务器+WireGuard的形式实现内网穿透。 本文为《群晖NAS公网访问配置》系列文章的第四篇。全部文章请参考： 群晖NAS公网访问配置（一）：配置DDNS 群晖NAS公网访问配置（二）：配置WireGurad 群晖NAS公网访问配置（三）：配置Nginx访问Docker服务 群晖NAS公网访问配置（四）：配置云服务器 我在腾讯云上有一台 Ubuntu 轻量级服务器，本文将以其为基础进行各种配置。 云服务器配置 增加记录 首先我们需要增加一条新的记录值，作为创建 WireGuard 隧道的入口。这里可以参考之前的流程：添加域名记录。 注意这里的记录值需要填写你服务器的公网 IP。 开放端口 接着去到服务器管理后台，需要在防火墙中开放 NAS 中 WireGuard 的端口。在前文示例中，该值为 51820。 在云服务器上配置 WireGuard 安装 WireGuard 服务 首先我们 ssh 到远端云服务器，然后安装 WireGuard 服务： apt update &amp;&amp; apt install wireguard -y # 先更新再安装 该过程可能会超时，可以试着修改 sources.list 源解决。 创建配置 然后我们创建并进入 wireguard 文件夹。 mkdir /etc/wireguard cd /etc/wireguard 接着按照 配置 WireGuard 服务端 的方式，创建公私钥。 注意这里我们需要创建两套客户端配置。因为现在我们是要将该云服务器作为 WireGuard 的服务端，NAS 和我们的操作终端（比如 Mac）都是客户端。 接着我们创建 wg0.conf 配置文件。 客户端配置 NAS 配置 通过 SSH 连接 NAS，进入 /etc/wireguard 文件夹，创建一个新的 wg1.conf 配置文件。 保存文件后，通过 wg-quick up wg1 命令启动配置。或者参考前文设置开机自启动。 客户端配置 客户端配置就简单很多了，和前文中的操作是一模一样的。 注意端口、IP 即可。 ","link":"https://blog.rakuyoo.top/synology-with-cloud/"},{"title":"群晖NAS公网访问配置（三）：配置Nginx访问Docker服务","content":"当我们配置玩 DDNS 和 WireGuard 之后，我们已经可以安全的访问我们 NAS 上的文件以及各种服务了。 但是如果你觉得通过端口访问 Docker 中各个服务太繁琐，或者 Docker 服务太多，要记的端口太多。那么我们可以通过配置 Nginx 的方式，来给各个 Docker 服务绑定一个域名。 本文为《群晖NAS公网访问配置》系列文章的第三篇。全部文章请参考： 群晖NAS公网访问配置（一）：配置DDNS 群晖NAS公网访问配置（二）：配置WireGurad 群晖NAS公网访问配置（三）：配置Nginx访问Docker服务 群晖NAS公网访问配置（四）：配置云服务器 在云平台添加记录值 前面几篇文章中，我们在腾讯云上设置过多条主机记录，这里我们需要再添加一条作为我们 Docker 服务的入口域名。 同样是在腾讯云 我的域名 页面，点击已注册域名，进入“记录管理”页面。 单击添加记录，根据你服务的需求添加一条主机记录，比如我们为 calibre-web 添加域名，那么主机记录可以写 calibre。 记录值和你 NAS 的内网 IP 相同。比如我们在上一篇文章中设置的 192.168.47.29。 配置 NAS 的 Nginx DSM 本身自带 Nginx，所以我们可以通过修改自带 Nginx 的方式来为 Docker 服务增加配置。 DSM 的 Nginx 每次启动时会根据模板文件重新创建，不过这里我们不修改文件本身，所以无碍。 通过 ps aux|grep nginx 命令我们可以看到 DSM 加载的是 /etc/nginx/nginx.conf.run，在该文件末尾有一行 include sites-enabled/*。这代表着我们可以将新增的配置放到 /etc/nginx/sites-enabled 文件夹下。 进入 sites-enabled 文件夹，然后通过 vim 新建一个配置文件： cd /etc/nginx/sites-enabled vim calibre.baidu.com.conf # 可使用你要配置的服务的域名作为文件名 在文件内填入下面的内容： server { listen 80; server_name calibre.baidu.com; # 服务的域名，根据实际情况替换 #charset koi8-r; #access_log /var/log/nginx/host.access.log main; location / { proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Scheme $scheme; proxy_redirect off; proxy_pass http://172.17.0.1:8083; # 填写群晖容器详情中设置的网关/IP地址+配置的端口 # 如果您要使用本地存储策略，请将下一行注释符删除，并更改大小为理论最大文件尺寸 client_max_body_size 2000m; } } 保存后，使用下面的命令告诉 Nginx 使用指定的配置文件启动，然后重载 Nginx 的配置文件。 /usr/bin/nginx -c /etc/nginx/nginx.conf.run -t /usr/bin/nginx -c /etc/nginx/nginx.conf.run -s reload 现在您应该已经可以使用 calibre.baidu.com 代替 sana.baidu.com:8083 来访问您的 calibre-web 服务了。 ","link":"https://blog.rakuyoo.top/synology-docker-public-access/"},{"title":"群晖NAS公网访问配置（二）：配置WireGurad","content":"因为配置了公网 ip，为了安全，使用 WireGuard 控制访问。 本文参考自：群晖DS220+安装 WireGuard 保姆级教程 本文为《群晖NAS公网访问配置》系列文章的第二篇。全部文章请参考： 群晖NAS公网访问配置（一）：配置DDNS 群晖NAS公网访问配置（二）：配置WireGurad 群晖NAS公网访问配置（三）：配置Nginx访问Docker服务 群晖NAS公网访问配置（四）：配置云服务器 安装 WireGuard 套件 开启 SSH 因为 WireGuard 安装后需要通过 SSH 执行相关命令，所以我们需要先开启群晖的 SSH 功能。 在群晖 “终端机和SNMP -&gt; 终端机” 中勾选 启动SSH功能，端口号使用默认即可。然后点击应用即可完成开启。 随后您可以尝试在终端中通过内网或公网ip/域名访问群晖。 如果您还没有公网ip，那么您需要在内网环境下完成后续操作，因为群晖的 QC 是不支持 SSH 访问的。 安装 WireGuard 套件 首先在 “套件中心 -&gt; 设置 -&gt; 套件来源” 中添加 spk7.imnks.com/ 矿神源。随后搜索 WireGuard，找到对应套件后点击安装。 安装完成后我们通过 SSH 访问群晖NAS。 我这里为了方便，首先执行了 sudo su 命令，避免后续权限问题。 SSH 登录群晖 NAS 后，我们执行下面的命令： # 赋予Wireguard套件权限，在安装群晖套件时，我们在简介处也看到了该命令。 sudo sed -i 's/package/root/g' /var/packages/WireGuard/conf/privilege 至此 WireGuard 套件安装完成。 配置 WireGuard 服务端 依次执行下面的命令进入 WireGuard 配置文件夹： # 创建相关目录，该目录可能已经存在，无视相关报错即可。 mkdir /etc/wireguard/ # 进入Wireguard文件夹，后续操作都将在该文件夹中进行。 cd /etc/wireguard/ 创建公私钥 在该文件夹中，我们需要生成服务端公私钥以及客户端公私钥： #生成服务器端私钥 wg genkey &gt; server_privateKey #生成服务器端私钥对应的公钥 wg pubkey &lt; server_privateKey &gt; server_publicKey # 生成客户端私钥及对应的公钥 wg genkey | tee client_privateKey | wg pubkey &gt; client_publicKey # 使用 cat 命令查看对应内容。 cat server_privateKey cat server_publicKey cat client_privateKey cat client_publicKey 复制好这些秘钥，后面配置文件时需要用到。 创建服务端配置文件 按照注释，将下面配置中的内容替换为您在上一步中生成的内容。 [Interface] PrivateKey = serverprivatekey # 替换为服务器私钥 Address = 10.8.0.1/24 PostUp = iptables -A FORWARD -i %i -j ACCEPT; iptables -A FORWARD -o %i -j ACCEPT; iptables -t nat -A POSTROUTING -o eth+ -j MASQUERADE PostDown = iptables -D FORWARD -i %i -j ACCEPT; iptables -D FORWARD -o %i -j ACCEPT; iptables -t nat -D POSTROUTING -o eth+ -j MASQUERADE ListenPort = 51820 # 端口默认 51820，也可以自定义 MTU = 1420 [Peer] PublicKey = clientpublickey # 替换为客户端公钥 AllowedIPs = 10.8.0.2/32 说明： 上述配置文件中的 Address 和 AllowedIPs，前三位需要在同一局域网内对齐。最后一位详见后文 添加新的客户端 一节。 编辑后内容后回到终端，使用 vim 或其他手段在 /etc/wireguard/ 路径下创建 wg0.conf 文件，其内容为上述配置。 启动服务 先回到群晖套件中心，启动 WireGuard 套件。 之前启动了也无所谓，顺序不重要 再回到SSH终端，使用下面的命令加载配置文件： # 使用 `up` 命令加载 wg0 配置 sudo wg-quick up wg0 # 使用 `down` 命令停止 wg0，当前不执行 # sudo wg-quick down wg0 随后我们使用 wg 命令即可查看当前状态： 说明： 有客户端连接的时候 peer 才会显示 keepalive，此时我们还没有配置客户端连接，能够展示出来对应的配置即可。 最后我们为 wg0 服务添加开机自启动： sudo wg-autostart enable wg0 # 开启自启动 # sudo wg-autostart disable wg0 # 关闭自启动 备注：群晖的 WireGuard 套件无法通过 systemctl 来配置开启自启动，不知道是 DSM 的问题还是套件的问题，这里没有进一步深究。 路由器设置监听端口号转发 为了更好的理解后面的操作，我们先大致讲一下借助 WireGuard 要做的事情： 我们之前在 群晖NAS配置DDNS 一文中配置了 DDNS，在后面的操作中，我们将借助上面的域名来构建 WireGuard 隧道。等到隧道建立好了之后，我们再借助端口转发，通过隧道走内网服务。 腾讯云上的配置 因为之前我们创建的记录被我们用来建立隧道，所以我们需要新建一条记录来作为 NAS 真正的入口。 所以这里我们新建一条记录，主机记录随你定，注意记录值需要填写为 NAS 在内网中的 IP 地址。 后文我们使用以下域名作为示例： 用于创建 WireGuard 隧道的域名：gwa.baidu.com，记录值为公网 ip（39.156.66.10） 作为 NAS 入口的域名：sana.baidu.com，记录值为 NAS 内网 ip（192.168.47.29） 路由器静态 IP 分配 因为路由器重启会导致 ip 变化，而我们需要 NAS 内网的 IP 值。好在现在大部分路由器都支持 DHCP 静态 IP 分配。 登录路由器后台，根据你的路由器的设置，将群晖对应设备的 IP 添加到 DHCP 静态 IP 列表，使其拥有固定的 IP 值。 通过 NAS 设置端口转发 我这里选择的方案是通过群晖设置端口转发，而不是通过路由器。如果你希望通过路由器进行转发，则可以在路由器后台上进行设置。 先留在路由器管理后台，我们需要开启路由器的 UPnP 功能，这样我们才能使用 NAS 来设置端口转发。 开启路由器的 UPnP 之后，我们回到 NAS，来到 “控制面板 -&gt; 外部访问 -&gt; 路由器配置” 页面，如下图所示： 点击新增按钮，选择 “自定义端口”，点击下一步。 在接下来的步骤中，通讯协议我们选择 UDP，端口设置为 创建服务端配置文件 一节中，ListenPort 的值。 最后点击完成。完成后我们可以回到路由器的 UPnP 页面，刷新看看是否有对应的记录。 配置 WireGuard 客户端 下载客户端 WireGuard 客户端下载参考：WireGuard客户端。Apple 平台均需要国外的 Apple ID。 创建客户端配置文件 安装客户端的间隙，我们先准备好客户端配置文件： [Interface] PrivateKey = clientprivatekey # 替换为客户端私钥 Address = 10.8.0.2/32 # 这里需要对应上文 [创建服务端配置文件] 一节中，peer.AllowedIPs 里对应的值 MTU = 1420 [Peer] PublicKey = serverpublickey # 替换为服务端公钥 Endpoint = gwa.baidu.com:51820 # 用于创建 WireGuard 隧道的域名，加上上文设置的 ListenPort 端口 AllowedIPs = 10.8.0.1/24, 192.168.47.29/24 # 分别是 [创建服务端配置文件] 一节中,Interface.Address，以及 NAS 内网 IP PersistentKeepalive = 25 将上述内容保存为 wgnas.conf（文件名随意）。之后我们打开 WireGuard 客户端，选择通过文件创建隧道，选择 wgnas.conf，即可完成配置设置。 至此，您的域名配置应该符合下面的情况： WireGuard 开启状态 gwa.baidu.com sana.baidu.com 开启 无法访问 能访问 NAS 关闭 无法访问 无法访问 即只有在开着 WireGuard 的前提下，可以通过 sana.baidu.com 访问您的 NAS 服务。 添加新的客户端 上面的步骤里我们只添加了一个客户端，因为同一时间 WireGuard 只能识别一个隧道，如果您有多台设备，或者多人公用同一台 NAS，则需要设置多个 WireGuard 客户端配置，不能多台设备同时使用同一个配置文件。 让我们打开 创建服务端配置文件 中的创建的配置文件。 其中 Peer 的部分代表着每个客户端。当我们需要新增客户端时，服务端需要添加一套新的 Peer 配置。 [Interface] PrivateKey = serverprivatekey Address = 10.8.0.1/24 ... ListenPort = 51820 MTU = 1420 # 上述内容保持不变 [Peer] PublicKey = clientpublickey AllowedIPs = 10.8.0.2/32 [Peer] # 新的 Peer 配置 PublicKey = clientpublickey01 # 一套新的客户端公钥 AllowedIPs = 10.8.0.3/32 # 注意这里需要修改 ip 地址最后一位，一般+1即可 随后按照 创建客户端配置文件 中的方法，在新的客户端中加载新的配置文件即可。 ","link":"https://blog.rakuyoo.top/synology-with-wireguard/"},{"title":"群晖NAS公网访问配置（一）：配置DDNS","content":"本文使用DSM 7.0。请您确保已经获取了公网 ip，并且已经购买了域名。 因为我的域名在腾讯云上，所以为了方便 DDNS 使用腾讯云的服务，步骤参考：群晖（Synology）NAS 启用腾讯云 DDNS 并安装免费证书 本文为《群晖NAS公网访问配置》系列文章的第一篇。全部文章请参考： 群晖NAS公网访问配置（一）：配置DDNS 群晖NAS公网访问配置（二）：配置WireGurad 群晖NAS公网访问配置（三）：配置Nginx访问Docker服务 群晖NAS公网访问配置（四）：配置云服务器 获取腾讯云 API 密钥 登录 腾讯云 API 密钥 ，新建腾讯云 API SecretId 及 SecretKey 密钥信息。如下图所示： 复制好您的 Id 以及 Key，点击确定后 key 将无法查看。 添加域名记录 在 我的域名 页面，点击已注册域名，进入“记录管理”页面。 单击添加记录，添加一条主机记录为任意，记录值为任意 IP 的 A 记录。如下图所示： 说明： 假如您的域名为 baidu.com，主机记录为 abc，那么对应的域名就是 abc.baidu.com。所以本步骤中的主机记录请根据您的实际情况填写。 记录值可以填写为任意 IP 地址（比如0.0.0.0），最后 DDNS 绑定完成后，该值会自动更新为正确的公网 IP 地址，所以现在填的内容无所谓。 群晖配置 DDNS 首先按照下图所示，进入群晖添加 DDNS 的面板 外部地址应当就是您的公网 ip 地址。 其余各字段为： 服务供应商：腾讯云。 主机名称：请填写上一步中您添加的域名名称。比如 abc.baidu.com。 用户名/电子邮件：请填写您获取到的 SecretId 信息。 密码/密钥：请填写您获取到的 SecretKey 信息。 从 Tencent Cloud 获取证书，并将其设置为默认证书：勾选选项后，可自动为您申请腾讯云 TrustAsia SSL 免费证书并替换 NAS 的默认 SSL 证书。 备注： 如果您不需要 https，那么这个证书不勾选也可以。 此时可以单击测试联机，测试是否能联机成功。如状态栏显示为正常，则代表联机成功。 最后单击确定，即可完成设置。等待解析生效后（解析生效时间一般需要 10分钟），即可使用域名（abc.baidu.com:5000，需要携带端口）访问NAS。 手动更新 DDNS（可选） 完成设置后，单击群晖面板上的立即更新，系统会更新最新的 DDNS 解析记录，并确认状态是否显示为正常。如下图所示： 返回 我的域名 页面，单击域名，即可查看记录值是否已变更为公网 IP 地址。 ","link":"https://blog.rakuyoo.top/synology-config-ddns/"},{"title":"Package.swift 降级问题排查","content":"过去 Package.swift 没有好好写，toolchain 版本跟着 Xcode 走，没有兼容不同的版本。最近研究用 SPM 代替 CocoaPods，所以认真的研究折腾了一下。 本文总结把 Package.swift 从 5.9 降至 5.1 过程中遇到的一些问题。 本文不讲解基础语法。 版本号前的空格 之前 5.9 的时候是这么写的： // swift-tools-version: 5.9 直接将 5.9 改成 5.1 之后报错了： horizontal whitespace sequence [U+0020] immediately preceding the version specifier is supported by only Swift ≥ 5.4; consider removing the sequence for Swift 5.1 原因是 version: 和 5.1 之间有一个空格。而这个空格是 Swift 5.4 时才支持的特性... 所以改成下面这样就可以了： // swift-tools-version:5.1 // ⬆️注意这里没有空格 参考自：Swift Package Tools Version 的写法 资源的引用 像我一样没有持续关注 SPM 发展的开发者可能不知道，在 SPM 中引用资源是 5.3 开始才支持的特性。 所以如果你的包使用了 Resource bundle 或者 Binary Framework，那么你就不能降至 5.1 了，最低也要 5.3 版本才行。 省略 target.path 我没能找到这个的提案，可能是 Allow sources anywhere in ./Sources when only one target is present 这个。如果哪位明确知道麻烦在评论区告知。 在 5.9 版本上，如果我们的代码都在 Sources 目录下，且只有一个 Target，那么我们可以不显式指定 target.path 属性。 但是在 5.1 版本上不行，所以我们还是需要显式地指定 path 路径。 ","link":"https://blog.rakuyoo.top/troubleshooting-package_swift-downgrade-issues/"},{"title":"解决重置SPM缓存失败的问题","content":"相信经常使用 SPM 的小伙伴，应该都遇到过使用 Reset Package Caches 时报错：An unknown error occurred. reference 'refs/remotes/origin/main' not found (-1)，或者其他分支。 关于这个问题在 stackoverflow 上有比较多的讨论，例如这个 SPM unknown error reference not found when changing branch。 思来想去决定根据上面的回答，记录一下解决方案。 在我的场景下（Xcode 15），仅仅删除 ~/Library/Caches/org.swift.swiftpm/repositories 下对应的目录即可解决问题，之后重新 Rest 即可。 问题的发生 链接中提到了两种观点。一开始 @mrwest09 提到，如果使用 ssh（git@）引入依赖，则有可能会产生该问题。实际上这也符合我的使用场景（不过我没有试 https）。 但是后来 @Ivan Vavilov 也提到，他使用的 https，但是也依然出现了该问题。 所以怎么说好呢，这个问题的发生未必可以都归结到 ssh，至于真正的原因仅从上述回答中可能暂时无从得知... 问题的解决 直接方式 删除 ~/Library/Caches/org.swift.swiftpm/repositories 下的内容即可。 除此之外，回答中还提到了一个 “Swift package caches both in the derived data directory of your project”。该缓存的实际目录在 ~/Library/Developer/Xcode/DerivedData/$project/SourcePackages/repositories。 我的场景下仅删除 org.swift.swiftpm 中的内容即可。如果你仅删除它无效，可以看再试试 一并 SourcePackages 下的内容。 自动化处理 回答中还有好心的大佬写了2个自动删除缓存的脚本，一个是： #!/bin/bash if [[ $# -eq 0 ]] ; then echo 'Please call the script with the name of your project as it appears in the derived data directory. Case-insensitive.' echo 'For example: ./fix-spm-cache.sh myproject' exit 0 fi # Delete all directories named &quot;remotes&quot; from the global Swift Package Manager cache. cd ~/Library/Caches/org.swift.swiftpm/repositories for i in $(find . -name &quot;remotes&quot; -type d); do echo &quot;Deleting $i&quot; rm -rf $i done # Find derived data directories for all projects matching the script argument, and # delete all directories named &quot;remotes&quot; from source package repositories cache for those projects. cd ~/Library/Developer/Xcode/DerivedData/ for project in $(find . -iname &quot;$1*&quot; -type d -maxdepth 1); do for i in $(find &quot;$project/SourcePackages/repositories&quot; -name &quot;remotes&quot; -type d); do echo &quot;Deleting $i&quot; rm -rf $i done done 这个脚本删除了上面提到的两个路径下的缓存，使用时需要 sh ./fix-spm-cache.sh myproject。 另外一个大佬使用了另外一个思路，编写了一个 python 脚本： # Sometimes Xcode cannot resolve SPM(File -&gt; Packages -&gt; Resolve Package versions) if the dependency url is ssh # This script is a workaround to resolve package versions. # Usage: # python spmResolve.py # or # python3 spmResolve.py import os.path import subprocess import glob import json def main(): package_file = &quot;xcshareddata/swiftpm/Package.resolved&quot; xcodeproj = glob.glob('*.xcodeproj') xcworkspace = glob.glob('*.xcworkspace') spmproj = glob.glob('Package.resolved') package_resolved = &quot;&quot; if xcodeproj: package_resolved = xcodeproj[0] + f&quot;/project.xcworkspace/{package_file}&quot; elif xcworkspace: package_resolved = xcworkspace[0] + f&quot;/{package_file}&quot; elif spmproj: package_resolved = spmproj[0] else: print(f&quot;😱 Cannot find *.xcodeproj, *.xcworkspace or Package.resolved file&quot;) exit(-1) update_package_resolved(package_resolved) def update_package_resolved(package_resolved): if not os.path.exists(package_resolved): print(f&quot;😱 Package.resolved file doesn't exit: {package_resolved}&quot;) exit(-1) print(f&quot;Found: {package_resolved}&quot;) f = open(package_resolved) content = json.load(f) f.close() for pin in content[&quot;pins&quot;]: url = pin[&quot;location&quot;] if &quot;branch&quot; in pin[&quot;state&quot;]: branch = pin[&quot;state&quot;][&quot;branch&quot;] commit_hash = get_git_revision_hash(url, branch) print(f&quot;{url}, {branch}, {commit_hash}&quot;) pin[&quot;state&quot;][&quot;revision&quot;] = commit_hash elif &quot;version&quot; in pin[&quot;state&quot;]: version = pin[&quot;state&quot;][&quot;version&quot;] commit_hash = get_git_revision_by_tag(url, version) print(f&quot;{url}, {version}, {commit_hash}&quot;) pin[&quot;state&quot;][&quot;revision&quot;] = commit_hash with open(package_resolved, &quot;w&quot;) as output: json.dump(content, output, indent=4) # resolve SPM subprocess.run(['xcodebuild', '-resolvePackageDependencies']) print('🎉 Well done') def get_git_revision_hash(url, branch) -&gt; str: command = f'git ls-remote {url} refs/heads/{branch} | cut -f 1' return get_git_command_output(command) def get_git_revision_by_tag(url, version) -&gt; str: command = f'git ls-remote {url} -t {version} | cut -f 1' return get_git_command_output(command) def get_git_command_output(command) -&gt; str: return subprocess.check_output(command, stderr=subprocess.STDOUT, shell=True).decode('ascii').rstrip() if __name__ == '__main__': main() 使用方式为在包含 *.xcodeproj 或 *.xcworkspace 文件的路径下，调用 python spmResolve.py。 ","link":"https://blog.rakuyoo.top/fix-spm-cache/"},{"title":"移除字符串中的�","content":"一个非常非常非常常见的需求，一个限制输入长度的输入框，同时不限制用户输入字符的类型。 这里我们先假定一个需求： 一个最多输入6个字符的输入框，不限制用户输入的字符类型，即可以输入空格、中文英文、标点符号、数字以及 Emoji。 在这个需求下考虑下面这个场景： 输入框上已经有了文字：&quot; g,5就&quot;，用户即将输入一个 🉑️。 这时，你的程序很可能就会出问题了。 字符长度 我们大家应该都知道 Swift.String 的 count 属性和 ObjC 的 length 属性获取的结果不同。 比如下面的代码，实际输出结果如注释所述。 let string = &quot; g,5就🉑️&quot; print(string.count) // 6 print((string as NSString).length) // 8 回到需求和场景上，我相信你早就知道，在做这种截取的时候，不能直接用 string.count 判断长度。 这种时候我们一般会用 utf16 编码来获取长度： let string = &quot; g,5就🉑️&quot; print(string.count) // 6 print(string.utf16.count) // 8 print((string as NSString).length) // 8 直接截取 搞定了长度，剩下的就是截取了： extension String { func prefixed(_ maxLength: Int) -&gt; String { let sequence = utf16 guard sequence.count &gt; maxLength else { return self } let startIndex = sequence.startIndex let endIndex = sequence.index(startIndex, offsetBy: maxLength) let result = String(sequence[startIndex ..&lt; endIndex]) // 以防万一，借助 Objective-C 的能力进行截取 return result ?? (self as NSString).substring(to: maxLength) } } 因为 String 的 init?(_ codeUnits: Substring.UTF16View) 构造器返回可能为空，保险起见最后还是借用了一下 ObjC 的方法来做截取。 好了，到目前为止是我写这篇博客之前的理解和做法。后面开始说问题。 半个 emoji 对上述的场景应用该方法后，我们得到的截取结果其实是有问题的： &quot; g,5就🉑️&quot;.prefixed(6) // g,5就� 6的长度限制正好卡在 🉑️ 的编码上，导致最后遗留下来半个 emoji。 如果仅仅是展示还好，但是如果拿这个字符串在 iOS 13 上，使用 JSONEncoder 去编码，就会造成闪退，而且不论是通过 try catch 也好，try? 也好，都无法捕获到该异常（EXC_BAD_ACCESS）。 解决问题 通过断点可知，原本方法的 result 属性是 nil，最终是通过 ObjC 的 substring 方法得到了目标字符串。 很明显这个问题是 emoji 截取不全导致的，这种情况下我们应该删除整个 emoji，而不是残留半个。 进一步搜索，我找到了这篇文章：Swift 字符串 截取 半个表情emoji \\u0000fffd 的处理 原文解决方法如下所示，通过实践，该方法确实可以解决问题。 // text:Optional(&quot;123456789😒&quot;) var newText = (text as NSString).substring(to: 10) newText = (text as NSString).substring(to: maxLength) // 有可能会截取到半个表情，所以这里剔除掉半个表情的情况 if let data = newText.data(using: .utf8), let temp = NSString(data: data, encoding: String.Encoding.utf8.rawValue), temp.contains(&quot;\\u{0000fffd}&quot;) { newText = temp.replacingOccurrences(of: &quot;\\u{0000fffd}&quot;, with: &quot;&quot;) as String } 进一步优化 其实上面的方法无需将 data 转为 NSString，直接使用 String 去 contains 也是可以的，这个暂且按下不表。 但是对于无法预测的用户输入，每一次截取都要先将 text 转为 data，再转回 string，最后才能做判断，我是不太想接受的。 所以我直接将这个答案丢给了 ChatGPT，结果一系列的调教和实践，最终得到了如下版本的方法： extension String { func prefixed(_ maxLength: Int) -&gt; String { let sequence = utf16 guard sequence.count &gt; maxLength else { return self } let startIndex = sequence.startIndex var endIndex = sequence.index(startIndex, offsetBy: maxLength) while endIndex &gt; startIndex &amp;&amp; UTF16.isTrailSurrogate(sequence[endIndex]) { endIndex = sequence.index(before: endIndex) } let result = String(sequence[..&lt;endIndex]) return result ?? (self as NSString).substring(to: maxLength) } } 一些 UTF-16 的概念 如果你对 “为什么” 不感兴趣，那么现在你已经得到了答案，可以关闭掉这个页面了。 下面的内容将先介绍一些和 UTF-16 有关的概念。 UTF-16 UTF-16编码的字符可以是1个或2个16位码元。 那些只需要1个16位码元的字符被称为BMP（基本多文本平面）字符，如英文字母，数字，标点符号等。 而那些需要2个16位码元的字符被称为非BMP字符，如某些emoji。 Surrogate Pairs 在 Unicode标准中，还包含 &quot;Low surrogate&quot; 和 &quot;High surrogate&quot; 两个概念，或者也称为前导代理（lead surrogate）和 尾随代理（trail surrogate）。 它们共同组成了 &quot;surrogate pairs&quot;，即一个代理对。 它被用来表示在 UTF-16 编码中，不能用单个16位编码单元所表示的字符，取值范围在 U+10000 至 U+10FFFF 之间。 &quot;High surrogate&quot; 是一个代理对中的第一个16位编码单元，其范围从 U+D800 到 U+DBFF。 &quot;Low surrogate&quot; 是一个代理对中的第二个16位编码单元，其范围从 U+DC00 到 U+DFFF。 例如，emoji &quot;🉑️&quot; 在UTF-16编码下，是由两个16位码元组成的：0xD83D 和 0xDD91。这两个码元就是一个代理对，其中 0xD83D 是前导代理，0xDD91 是尾随代理。 回到需求和场景 对于字符串 &quot; g,5就🉑️&quot;，当我们的最大长度为 6 位时，截取的为止恰好在 0xD83D 和 0xDD91 的中间。此时 endIndex 指向的是第7位，即 0xDD91 尾随代理。 所以我们用 UTF16.isTrailSurrogate 方法判断，如果截取的末尾是一个尾随代理，则向前移动一位，将整个 emoji 舍掉。 一些其他的想法 其实其他方法还有很多，比如： 通过文档可知，init?(_ codeUnits: Substring.UTF16View) 当 codeUnits 非法时返回 nil。所以也可以通过这点来编写递归/循环，递减 endIndex。 提前判断所要截取的字符是否是 emoji，如果是，则整个 emoji 截掉。 从 &quot; g,5就�&quot; 中判断是否包含 � 这个字符，如果有就全局替换。 其中第三个方法我还具体实践了一下。 首先我们没有办法通过 utf16 直接得到 String 对象，因为 � 这个符号会导致初始化失败。所以只能通过 NSString 来拿到目标字符串。 其次，当我们拿到了 NSString 对象后，直接调用 .contains(&quot;�&quot;)，返回值居然是 false。 let string = &quot; g,5就🉑️&quot; let original = (string as NSString).substring(to: 6) print(original.contains(&quot;�&quot;)) // false 此时，只要向文中提到的第一种方法那样，对 string 转一次 data 即可判断成功。 let string = &quot; g,5就🉑️&quot; let original = (string as NSString).substring(to: 6) let utf8Data = original.data(using: .utf8)! if let test = String(data: utf8Data, encoding: .utf8) { print(test.contains(&quot;�&quot;)) // true } 但是这一套下来确实有点得不偿失了。 但是，为什么是 false？ 经过翻阅资料，怀疑这是因为 NSString 和 String 的底层处理不同导致的。 对于 NSString，允许存在无效字符，所以 &quot; g,5就�&quot; 中的 � 和我们手写的 � 并非是统一个含义，后者代表一个 “Unicode替换字符”，它用来替换无法识别或无效的Unicode字符。而 NSString 中的 � 就只是一个无效的 Unicode，所以这两个才会不匹配。 这其实也能回答最开始的那个方案，为什么需要先转 data，再转一次 string，最后才能判断成功。 ","link":"https://blog.rakuyoo.top/remove-illegal-characters-from-string/"},{"title":"记 podspec 转 podspec.json","content":"如果你像我一样使用 Xcode 14.3 &amp; CocoaPods 12.4.1，那么恭喜你，你很有可能遇到跟我一样问题：Xcode 14.3 has pod lib lint fail。 如果你正在开发的是一个私有 pod，那还好说，可以直接将 podspec 文件 push 到自己的 git spec 上。 但是如果你像我一样，私有 spec repo 中存储的是 podspec.json，那么接下来的这个命令也许会帮到你： pod ipc spec Name.podspec &gt;&gt; Name.podspec.json 使用该命令可以将 podspec 文件转换为 podspec.json 文件，之后你就可以将 json 文件推到 git spec repo 里了。 ","link":"https://blog.rakuyoo.top/ji-podspec-zhuan-podspecjson/"},{"title":"CGO 与 WireGuardKit 编译","content":"CGO 是一种在 iOS 平台上运行 Go 代码的方案。而 WireGuard 一种 VPN 技术，其中包含了一部分 Go 代码，同时项目提供了一个 Makefile 脚本，使用 CGO 来将相关代码编译成 iOS 静态库。 写这篇文章的契机是，因为希望使用 Mac Catalyst 将内部工具带到 macOS 平台，我又回过头去看一年前（恰巧是22年3月）研究 WireGuard 的过程。 发现虽然当时的研究成功，.xcframewrok 文件还在，但是过程已经模糊不清了。另外还需要针对 Mac Cataglyst 构建出新的静态库，所以又要从头进行梳理不过好在是 “模糊不清”，而不是 “一干二净”，多少还记得一些。 Makefile 我对 Go 语言几乎可以说是一窍不通的。 而对于 Makefile 也只有很少很少的了解。 想要执行 Makefile 文件中的脚本，就在命令行中，在进入对应目录后执行以下命令： # 前提是说，电脑上要安装 make。一般安装了 Xcode 命令行的话都是有的。 make 这里我将该 Makefile 先贴过来： # These are generally passed to us by xcode, but we set working defaults for standalone compilation too. ARCHS ?= x86_64 arm64 PLATFORM_NAME ?= macosx SDKROOT ?= $(shell xcrun --sdk $(PLATFORM_NAME) --show-sdk-path) CONFIGURATION_BUILD_DIR ?= $(CURDIR)/out CONFIGURATION_TEMP_DIR ?= $(CURDIR)/.tmp export PATH := $(PATH):/usr/local/bin:/opt/homebrew/bin export CC ?= clang LIPO ?= lipo DESTDIR ?= $(CONFIGURATION_BUILD_DIR) BUILDDIR ?= $(CONFIGURATION_TEMP_DIR)/wireguard-go-bridge CFLAGS_PREFIX := $(if $(DEPLOYMENT_TARGET_CLANG_FLAG_NAME),-$(DEPLOYMENT_TARGET_CLANG_FLAG_NAME)=$($(DEPLOYMENT_TARGET_CLANG_ENV_NAME)),) -isysroot $(SDKROOT) -arch GOARCH_arm64 := arm64 GOARCH_x86_64 := amd64 GOOS_macosx := darwin GOOS_iphoneos := ios build: $(DESTDIR)/libwg-go.a version-header: $(DESTDIR)/wireguard-go-version.h REAL_GOROOT := $(shell go env GOROOT 2&gt;/dev/null) export GOROOT := $(BUILDDIR)/goroot $(GOROOT)/.prepared: [ -n &quot;$(REAL_GOROOT)&quot; ] mkdir -p &quot;$(GOROOT)&quot; rsync -a --delete --exclude=pkg/obj/go-build &quot;$(REAL_GOROOT)/&quot; &quot;$(GOROOT)/&quot; cat goruntime-*.diff | patch -p1 -f -N -r- -d &quot;$(GOROOT)&quot; touch &quot;$@&quot; define libwg-go-a $(BUILDDIR)/libwg-go-$(1).a: export CGO_ENABLED := 1 $(BUILDDIR)/libwg-go-$(1).a: export CGO_CFLAGS := $(CFLAGS_PREFIX) $(ARCH) $(BUILDDIR)/libwg-go-$(1).a: export CGO_LDFLAGS := $(CFLAGS_PREFIX) $(ARCH) $(BUILDDIR)/libwg-go-$(1).a: export GOOS := $(GOOS_$(PLATFORM_NAME)) $(BUILDDIR)/libwg-go-$(1).a: export GOARCH := $(GOARCH_$(1)) $(BUILDDIR)/libwg-go-$(1).a: $(GOROOT)/.prepared go.mod go build -ldflags=-w -trimpath -v -o &quot;$(BUILDDIR)/libwg-go-$(1).a&quot; -buildmode c-archive rm -f &quot;$(BUILDDIR)/libwg-go-$(1).h&quot; endef $(foreach ARCH,$(ARCHS),$(eval $(call libwg-go-a,$(ARCH)))) $(DESTDIR)/wireguard-go-version.h: go.mod $(GOROOT)/.prepared sed -E -n 's/.*golang\\.zx2c4\\.com\\/wireguard +v[0-9.]+-[0-9]+-([0-9a-f]{8})[0-9a-f]{4}.*/#define WIREGUARD_GO_VERSION &quot;\\1&quot;/p' &quot;$&lt;&quot; &gt; &quot;$@&quot; $(DESTDIR)/libwg-go.a: $(foreach ARCH,$(ARCHS),$(BUILDDIR)/libwg-go-$(ARCH).a) @mkdir -vp &quot;$(DESTDIR)&quot; $(LIPO) -create -output &quot;$@&quot; $^ clean: rm -rf &quot;$(BUILDDIR)&quot; &quot;$(DESTDIR)/libwg-go.a&quot; &quot;$(DESTDIR)/wireguard-go-version.h&quot; install: build .PHONY: clean build version-header install 这个脚本分为以下几个部分： 定义变量：最开始的几行都是定义变量，其中 ?= 语法则是设置默认值，意思是可以从外部设置该值。 定义目标：此后脚本定义了4个目标，分别是 build、version-header、clean 和 install。其中 version-header 目标内还定义了一个函数：libwg-go-a。 目标的执行顺序：最后的 .PHONY 用来定义目标执行顺序，脚本将按照该值的顺序去执行目标。 看完大块我们来看细节。 定义变量 在此不解释每个变量的作用，先重点关注下面几个： ARCHS ?= x86_64 arm64 PLATFORM_NAME ?= macosx SDKROOT ?= $(shell xcrun --sdk $(PLATFORM_NAME) --show-sdk-path) GOARCH_arm64 := arm64 GOARCH_x86_64 := amd64 GOOS_macosx := darwin GOOS_iphoneos := ios 上面已经提到了，这个 Makefile 是用来构建 iOS 静态库的。 那么 ARCHS 这个变量就代表着这个库所支持的架构。默认是 x86_64 和 arm64 两个。 PLATFORM_NAME 和 SDKROOT 要一起看，根据指定的平台获取对应 SDK 的路径，即用何种 SDK 来构建静态库。 PLATFORM_NAME 可选的值包括： 值 含义 iphoneos iOS macosx macOS iphonesimulator iOS 模拟器 后面几个变量则是定义了一些 CGO 的参数，注意这里是没有 iphonesimulator 对应的参数的，只有 iOS 和 macOS。 libwg-go-a 函数 前几行是使用 export 来定义一些环境变量，CGO_CFLAGS 和 CGO_LDFLAGS 算是比较重要的两个 CGO 参数，用来指定 C 编译器和链接器的选项，后面还会提及。 函数内的 $(1) 指的是该方法的第一个参数。在 libwg-go-a 函数的下一行是一个 foreach 语句，它的作用是遍历 ARCHS，再将每一个 ARCH 作为 libwg-go-a 函数的参数传入，来调用 libwg-go-a 函数。所以这里的 $(1) 就是我们在最上面定义的 ARCHS 里的内容。 我们还可以注意到 $(GOOS_$(PLATFORM_NAME)) 这里，代码借助 PLATFORM_NAME 变量套了一层，来拼接获取 GOOS_macosx 或者 GOOS_iphoneos 的值。 其中比较关键的 go build 命令，就是真正负责构建静态库的命令。最后生成的静态库文件名则是 libwg-go-$(1).a。 小结 到这里 Makefile 大致就算是说完了，弄明白了这个文件的大致结构与各部分的作用，后面才好动手对文件进行修改。 通过修改 ARCHS 和 PLATFORM_NAME 的值，如果一切顺利的话，我们可以得到 iOS 和 macOS 平台的静态库，大体上工作也就结束了。 但是往往还会有些额外工作要处理。 编译支持模拟器的静态库 虽然 WireGuard VPN 本身不支持模拟器，但是跳出这个话题，上面有提到，这个脚本现在是不支持 iphonesimulator 的，如果想要支持模拟器该怎么办呢？ 其实不支持的原因很简单：因为不存在 GOOS_iphonesimulator 变量（想一想 $(GOOS_$(PLATFORM_NAME))）。 所以我们可以手动定义该变量。通过查阅资料，模拟器对应的 GOOS 也为 ios，所以变量定义如下： GOARCH_arm64 := arm64 GOARCH_x86_64 := amd64 GOOS_macosx := darwin GOOS_iphoneos := ios +GOOS_iphonesimulator := ios 之后再执行 make 命令，就可以得到支持 iOS 模拟器的静态库了。 编译支持 Mac Cataglyst 的静态库 回归业务，本次我的工作是要编译支持 Mac Cataglyst 的静态库，那么该怎么做呢？ x86_64-apple-ios13.0-macabi 通过查找资料，我了解到 -target x86_64-apple-ios13.0-macabi 这个用于描述特定操作系统和处理器架构的标识符： x86_64 表示处理器架构为 64 位的 Intel 或 AMD 处理器； apple 表示运行在苹果操作系统上； ios13.0 表示操作系统版本为 iOS 13.0； macab 表示使用的是 Mac 上的应用程序二进制接口（Mac Application Binary Interface），即我们想要使用的 Mac Cataglyst。 通过使用这个标识符，我们就可以构建出支持 Mac Cataglyst 的静态库。 接着通过这个回复得知，该值需要赋值给 CGO_CFLAGS 变量。回到脚本中我们可以发现，CGO_CFLAGS 上使用 CFLAGS_PREFIX 进行封装。 在这一步我遇到了2个问题： 不要直接将 -target x86_64-apple-ios13.0-macabi 写在 CFLAGS_PREFIX 的末尾。 省略一些代码后，把两行相关代码放在一起看： CFLAGS_PREFIX := -isysroot $(SDKROOT) -arch $(BUILDDIR)/libwg-go-$(1).a: export CGO_CFLAGS := $(CFLAGS_PREFIX) $(ARCH) 可以看到，实际上 export 的内容是 -isysroot $(SDKROOT) -arch x86_64。 如果我们直接在 CFLAGS_PREFIX 的末尾添加，那么就会把 -arch x86_64 隔开，继而报错。所以添加到 -arch 前即可。 找不到 x86_64-apple-ios13.0-macabi。 相关的问题在 golang/go 的 github 上是可以搜到的，可惜这个问题是针对 go-mobile 的，但是可以注意到回复中的，-iosversion=14 字样。 于是将其改为 x86_64-apple-ios14.0-macabi，果断解决问题。 编译 Mac Cataglyst 虽然操作的是 iOS App，但是最终还是运行在 macOS 上，所以还是要使用 macosx 的 sdk 进行构建。 修改代码如下： ARCHS ?= x86_64 arm64 PLATFORM_NAME ?= macosx SDKROOT ?= $(shell xcrun --sdk $(PLATFORM_NAME) --show-sdk-path) -CFLAGS_PREFIX := $(if $(DEPLOYMENT_TARGET_CLANG_FLAG_NAME),-$(DEPLOYMENT_TARGET_CLANG_FLAG_NAME)=$($(DEPLOYMENT_TARGET_CLANG_ENV_NAME)),) -isysroot $(SDKROOT) -arch +CFLAGS_PREFIX := $(if $(DEPLOYMENT_TARGET_CLANG_FLAG_NAME),-$(DEPLOYMENT_TARGET_CLANG_FLAG_NAME)=$($(DEPLOYMENT_TARGET_CLANG_ENV_NAME)),) -isysroot $(SDKROOT) -target x86_64-apple-ios14.0-macabi -arch 但是运行代码后会发现 arm64 架构的包打不出。 Warning 其实到这里，有关 WireGuard 的相关工作已经 “结束” 了。因为虽然最后我打出了包，但是截止到本文发布，我还未能成功将项目运行起来，所以并不知道接下来的操作是否正确。 通过将 GOOS_macosx 对应的值修改为 ios 可以解决这个问题。所以最终修改为： ARCHS ?= x86_64 arm64 PLATFORM_NAME ?= macosx SDKROOT ?= $(shell xcrun --sdk $(PLATFORM_NAME) --show-sdk-path) -CFLAGS_PREFIX := $(if $(DEPLOYMENT_TARGET_CLANG_FLAG_NAME),-$(DEPLOYMENT_TARGET_CLANG_FLAG_NAME)=$($(DEPLOYMENT_TARGET_CLANG_ENV_NAME)),) -isysroot $(SDKROOT) -arch +CFLAGS_PREFIX := $(if $(DEPLOYMENT_TARGET_CLANG_FLAG_NAME),-$(DEPLOYMENT_TARGET_CLANG_FLAG_NAME)=$($(DEPLOYMENT_TARGET_CLANG_ENV_NAME)),) -isysroot $(SDKROOT) -target x86_64-apple-ios14.0-macabi -arch GOARCH_arm64 := arm64 GOARCH_x86_64 := amd64 -GOOS_macosx := darwin +GOOS_macosx := ios GOOS_iphoneos := ios GOOS_maccatalyst := ios GOOS_iphonesimulator := ios 参考 golang/go with issue #36856 golang/go with issue #47228 Re: Support for M1 MacBook Simulators ","link":"https://blog.rakuyoo.top/cgo-and-wireGuardkit-compilation/"},{"title":"epoxy 源码笔记1：Diffing 算法","content":"最近开始阅读学习 epoxy 的源码，开个新的系列来记录一下学习成功。 本系列文章不对 epoxy 是什么进行讲解，直接讲解其中的部分源码内容。 如果相比较文字，您更喜欢直接阅读代码+注释，那么您可以跳到文章末尾的 总结 一节，该小节包含了一个完整的，带注释讲解的源码。 目录 源码 ContiguousArray 预填充数组 entries 记录新元素 Entry 对象和 trackNewIndex(_:) 方法 记录旧元素 NewRecord &amp; OldRecord 确定元素变动 中场休息 删除、新增与移动 删除 新增和移动 总结 源码 本文主要讲解 Collection+Diff.swift 文件中的 makeChangeset(from:) 方法，该方法可以快速比较出两个集合之间的区别，同时返回增删改的索引集合。 首先贴一下相关的源码： // MARK: - Collection extension Collection where Element: Diffable, Index == Int { /// Diffs two collections (e.g. `Array`s) of `Diffable` items, returning an `IndexChangeset` /// representing the minimal set of changes to get from the other collection to this collection. /// /// - Parameters: /// - from other: The collection of old data. public func makeChangeset(from other: Self) -&gt; IndexChangeset { // Arranging the elements contiguously prior to diffing improves performance by ~40%. let new = ContiguousArray(self) let old = ContiguousArray(other) /// The entries in both this and the other collection, keyed by their `dataID`s. var entries = [AnyHashable: Entry](minimumCapacity: new.count) var duplicates = [Entry]() var newResults = ContiguousArray&lt;NewRecord&gt;() newResults.reserveCapacity(new.count) for index in new.indices { let id = new[index].diffIdentifier let entry = entries[id, default: Entry()] if entry.trackNewIndex(index) { duplicates.append(entry) } entries[id] = entry newResults.append(NewRecord(entry: entry)) } var oldResults = ContiguousArray&lt;OldRecord&gt;() oldResults.reserveCapacity(old.count) for index in old.indices { let id = old[index].diffIdentifier let entry = entries[id] entry?.pushOldIndex(index) oldResults.append(OldRecord(entry: entry)) } for newIndex in new.indices { let entry = newResults[newIndex].entry if let oldIndex = entry.popOldIndex() { let newItem = new[newIndex] let oldItem = other[oldIndex] if !oldItem.isDiffableItemEqual(to: newItem) { entry.isUpdated = true } newResults[newIndex].correspondingOldIndex = oldIndex oldResults[oldIndex].correspondingNewIndex = newIndex } } var deletes = [Int]() var deleteOffsets = [Int]() deleteOffsets.reserveCapacity(old.count) var runningDeleteOffset = 0 for index in old.indices { deleteOffsets.append(runningDeleteOffset) let record = oldResults[index] if record.correspondingNewIndex == nil { deletes.append(index) runningDeleteOffset += 1 } } var inserts = [Int]() var updates = [(Int, Int)]() var moves = [(Int, Int)]() var insertOffsets = [Int]() insertOffsets.reserveCapacity(new.count) var runningInsertOffset = 0 for index in new.indices { insertOffsets.append(runningInsertOffset) let record = newResults[index] if let oldArrayIndex = record.correspondingOldIndex { if record.entry.isUpdated { updates.append((oldArrayIndex, index)) } let insertOffset = insertOffsets[index] let deleteOffset = deleteOffsets[oldArrayIndex] if (oldArrayIndex - deleteOffset + insertOffset) != index { moves.append((oldArrayIndex, index)) } } else { inserts.append(index) runningInsertOffset += 1 } } EpoxyLogger.shared.assert( old.count + inserts.count - deletes.count == new.count, &quot;Failed sanity check for old count with changes matching new count.&quot;) return IndexChangeset( inserts: inserts, deletes: deletes, updates: updates, moves: moves, newIndices: oldResults.map { $0.correspondingNewIndex }, duplicates: duplicates.map { $0.newIndices }) } // MARK: - Entry /// A bookkeeping refrence type for the diffing algorithm. private final class Entry { // MARK: Internal private(set) var oldIndices = [Int]() private(set) var newIndices = [Int]() var isUpdated = false /// Tracks an index from the new indices, returning `true` if this entry has previously tracked /// a new index as a means to identify duplicates and `false` otherwise. func trackNewIndex(_ index: Int) -&gt; Bool { let previouslyEmpty = newIndices.isEmpty newIndices.append(index) // We've encountered a duplicate, return true so we can track it. if !previouslyEmpty, newIndices.count == 2 { return true } return false } func pushOldIndex(_ index: Int) { oldIndices.append(index) } func popOldIndex() -&gt; Int? { guard currentOldIndex &lt; oldIndices.endIndex else { return nil } defer { currentOldIndex += 1 } return oldIndices[currentOldIndex] } // MARK: Private private var currentOldIndex = 0 } // MARK: - OldRecord /// A bookkeeping type for pairing up an old element with its new index. private struct OldRecord { var entry: Entry? var correspondingNewIndex: Int? = nil } // MARK: - NewRecord /// A bookkeeping type for pairing up a new element with its old index. private struct NewRecord { var entry: Entry var correspondingOldIndex: Int? = nil } makeChangeset(from:) 方法是 Collection&lt;Diffable&gt; 的一个扩展，实际使用时你可以简单的理解为一个 [Diffable]。方法接收一个同类型的集合，返回一个 IndexChangeset 类型的结构体。 返回值暂且忽略，咱们直接来看函数体。 ContiguousArray let new = ContiguousArray(self) let old = ContiguousArray(other) 函数体内首先将 self 和 other 转换为 ContiguousArray 类型的数组。从变量名上我们可以得知，self 代表着新的集合，而 other 代表着旧的的集合，也就是被比较的集合。 ContiguousArray 和 Array 类似，区别在于 ContiguousArray 能保证子元素在内存中是连续存储的，也就是说它是一块连续的内存，这就允许 CPU 通过指针进行连续访问，大幅提升性能。而 Array 我们大家都知道，它的内部使用了 “缓冲区”，逻辑上是连续的，但是内存上未必是连续的。 因为在后续的算法中，self 和 other 的大小是固定的，不会发生变化，所以这里将其转换为 ContiguousArray 是更好的选择。 通过源码中的注释我们也能知道，将 self 和 other 转换为 ContiguousArray 类型，可以提升大约 40% 的性能。 后文中，将使用 new 代表 self，使用 old 代表 other。和这里的变量声明保持同步。 预填充数组 毕竟是一个讲究效率的算法，后文中随处可见 .init(minimumCapacity:) 、 reserveCapacity(_:) 方法，这些方法的作用是一样的：设置数组的长度。 我们都知道 Swift 数组扩容通常是直接 *2。上一节中我们有提到，整个算法中数据源的大小是已知的，那么作为一个讲究效率的算法，我们可以在创建数组的同时就设定好数组的大小，避免在后续操作中触发数组的自动扩容，减少因为扩容而带来的性能损耗。 entries var entries = [AnyHashable: Entry](minimumCapacity: new.count) entries 这个字典变量的作用是，将 new 和 old 中，使用相同 id 的元素索引值对应起来。 现在这么讲可能比较抽象，后面结合逻辑一起来谈。 记录新元素 var newResults = ContiguousArray&lt;NewRecord&gt;() newResults.reserveCapacity(new.count) for index in new.indices { let id = new[index].diffIdentifier let entry = entries[id, default: Entry()] if entry.trackNewIndex(index) { duplicates.append(entry) } entries[id] = entry newResults.append(NewRecord(entry: entry)) } 代码首先使用新序列的索引进行遍历，使用对应元素的 id，尝试去 entries 中查找元素。 这里使用了一个小技巧：Dictionay 的 default。当不存在 id 对应的元素时，将返回 default 对应的内容。这里即是返回一个空的 Entry 对象。 稍后讲解 Entry 对象和 trackNewIndex(_:) 方法的具体内容，先大致说一下： Entry 对象用来记录 “拥有同一个 id 的两个元素，其在新、旧两个数组中的位置”。 trackNewIndex(_:) 方法接收索引作为参数，并存储到 Entry 对象中。同时该方法会返回这个 Entry 对象是否已经在之前出现过（相当于一个重复检查）。 现在我们就可以知道这个 for 循环大致的含义和作用了： 它遍历新数组，首先根据 id 将数组元素存储到 entries 对象中，其次对该数组做一个 “重复检查”，并记录下重复的次数。 Entry 对象和 trackNewIndex(_:) 方法 Entry 对象是一个结构体，它的完整声明比较长，这里我就不再重复贴了，读者可以翻到最上面 自行查看。 我们先把目光集中在 newIndices 这个属性以及 trackNewIndex(_:) 方法上。 trackNewIndex(_:) 方法的实现为： /// Tracks an index from the new indices, returning `true` if this entry has previously tracked a new index as a means to identify duplicates and `false` otherwise. func trackNewIndex(_ index: Int) -&gt; Bool { let previouslyEmpty = newIndices.isEmpty newIndices.append(index) // We've encountered a duplicate, return true so we can track it. if !previouslyEmpty, newIndices.count == 2 { return true } return false } 该方法将参数存储到 newIndices 里。这是它的作用之一：记录该 id 在新数组（new）中的位置。 然后判断，如果 newIndices 中的元素等于 2，则意味着出现了重复。这很好理解，newIndices 大于 1 意味着同一个 id 出现了两次。不过截止到发文我也没能理解，为什么是 == 2 而不是 &gt;= 2。结合后文推断，猜测是不希望 duplicates 中出现重复的元素。 记录旧元素 var oldResults = ContiguousArray&lt;OldRecord&gt;() oldResults.reserveCapacity(old.count) for index in old.indices { let id = old[index].diffIdentifier let entry = entries[id] entry?.pushOldIndex(index) oldResults.append(OldRecord(entry: entry)) } 记录旧元素的逻辑比记录新元素的逻辑要简单一些：当我们通过 id，如果在 entries 映射表中查到对应元素时（意味着该 id 存在对应的新元素），则存储该元素在旧数据中的索引值。否则不进行存储（因为 entries 的意思是存储 “新-旧” 的对应关系，不存在新，那么旧就没有意义）。 NewRecord &amp; OldRecord 在遍历新集合和旧集合的循环中，末尾都是创建了一个对应的 XXRecord 对象。这两个类型的声明比较相似，除了存储对应的 Entry 之外，还带有一个 Int? 类型的 correspondingXXXIndex 属性，该属性默认是 nil。 correspondingOldIndex 意味着在新集合中，该元素在旧集合中的位置。 correspondingNewIndex 意味着在旧集合中，该元素在新集合中的位置。 如果是 nil，则意味着该元素在另外的集合中不存在。 这两个属性都在后面的算法中起到了重要的作用。 确定元素变动 for newIndex in new.indices { let entry = newResults[newIndex].entry if let oldIndex = entry.popOldIndex() { let newItem = new[newIndex] let oldItem = other[oldIndex] if !oldItem.isDiffableItemEqual(to: newItem) { entry.isUpdated = true } newResults[newIndex].correspondingOldIndex = oldIndex oldResults[oldIndex].correspondingNewIndex = newIndex } } 这个对新集合的遍历，确定了两个集合之间元素的变动。 首先是对新集合的遍历，因为 newResults 可以说就是 new 通过 map 得到的，所以可以使用 newIndex 直接从 newResults 中进行取值，而不用担心是否会越界。 你应该还记得，entry 对象中存储着该 id 对应的元素在新、老集合中对应的索引。如果在新、老集合中不存在，那么对应的索引也就不存在。所以通过 popOldIndex() 方法（通过方法名也能看出它的作用），可以通过 entry 对象判断是否存在旧的元素。 到这一步我们应该能知道：如果 newResults 中的某一个元素的 correspondingOldIndex 是 nil，那么该元素就是新增的。那么反过来，oldResults 中的逻辑也是一样的。 实际上上一节中，关于 correspondingOldIndex 和 correspondingNewIndex 这两个属性的作用，也是我通过这个循环推断出来的。 接着往下看。如果存在旧的元素，那么我们就要比较新旧两个元素是否一致，如果不一致，则通过 entry.isUpdated 记录该元素发生了更新。 最后在 newResults 和 oldResults 中记录该元素在另外一个数组中的位置。 中场休息 到了这里，其实我们可以小结一下，先总结一下 newResults、oldResults 和 entries 三个变量的作用。 entries 的主要就是将新旧两个数组，通过相同的 id 做一个匹配，同时记录相应的索引。匹配到一起之后用来创建 newResults 和 oldResults 对象。该变量主要作用于算法的前半部分，为创建 newResults 和 oldResults 而生，创建完之后它的任务就结束了。 newResults 和 oldResults 这两个变量最主要的作用，按我的理解就是：“通过一个Int 类型的可选值，记录了 entry 的前世今生”。 correspondingXXXIndex 的存在有两个含义： 是否为空意味着有前世，或者有今生 不只是有，还能拿到对应的位置 感慨一下如果没有 “可选值” 这个概念，则需要借助 Bool + Int 两个变量来完成这个工作。或者判断一下 nil？ 删除、新增与移动 在得到 newResults 和 oldResults 两个对象后，要计算出两个集合之间的差异就比较简单了。 删除 后面的算法首先处理的是删除操作。 var deletes = [Int]() var deleteOffsets = [Int]() deleteOffsets.reserveCapacity(old.count) var runningDeleteOffset = 0 for index in old.indices { deleteOffsets.append(runningDeleteOffset) let record = oldResults[index] if record.correspondingNewIndex == nil { deletes.append(index) runningDeleteOffset += 1 } } 其实上文已经做了解释：如果 correspondingNewIndex 是 nil，则意味着该元素是被删除的元素。所以这次是对 old 进行遍历，而不是遍历 new 。 除了将被删除的元素记录到 deletes 之外，该循环还将 “在这个位置之前，有多少个被删除了多少个元素” 记录到了 deleteOffsets 数组中。 例如 [1, 2, 3, 4, 5, 6, 7] 和 [2, 3, 5, 7] 这两个集合做比较，那么 deleteOffsets 的值就是 [0, 1, 1, 1, 2, 2, 3]。代表着 “5这个元素之前，有两个元素被删除掉了”。 该算法是先将 runningDeleteOffset 添加到 deleteOffsets 里，再做递增操作。所以记录的是 “本元素之前，被删除了多少个元素”。 新增和移动 var inserts = [Int]() var updates = [(Int, Int)]() var moves = [(Int, Int)]() var insertOffsets = [Int]() insertOffsets.reserveCapacity(new.count) var runningInsertOffset = 0 for index in new.indices { insertOffsets.append(runningInsertOffset) let record = newResults[index] if let oldArrayIndex = record.correspondingOldIndex { if record.entry.isUpdated { updates.append((oldArrayIndex, index)) } let insertOffset = insertOffsets[index] let deleteOffset = deleteOffsets[oldArrayIndex] if (oldArrayIndex - deleteOffset + insertOffset) != index { moves.append((oldArrayIndex, index)) } } else { inserts.append(index) runningInsertOffset += 1 } } 首先我们发现遍历的开头，用了 record.correspondingOldIndex 来做判断，意味着 “该元素有没有对应的老元素”。 然后从下往上看 else 的逻辑，和删除的时候一样，这次循环通过 inserts 记录了 “该元素之前，插入了多少个元素”。这里我就不用具体的例子举例了，大家应该可以明白。 那么再回到 if 里的逻辑，首先 isUpdated 是之前已经判断过了的。 那么 (oldArrayIndex - deleteOffset + insertOffset) != index 该怎么理解呢？ 首先我们明确每个参数的含义： index 是某个元素在 “新集合” 中的位置。 oldArrayIndex 是该元素在 “旧集合” 中的位置。 deleteOffset 意味着该元素之前删除了几个元素。 insertOffset 意味着该元素之前添加了几个元素。 那么我们就可以理解了：对于旧集合而言，如果去掉被删除的，再加上新增的，如果索引位置不变，那么该元素的位置没有发生移动。 通过具体的例子来看一下： [1, 2, 3, 4, 5, 6, 7] 和 [2, 3, 7, 5]。我们遍历的是后者，即新集合。deleteOffsets 是 [0, 1, 1, 1, 2, 2, 3]。 假设此时我们遍历到了新集合中的 3。 那么 index 是 1，oldArrayIndex 是 2，deleteOffset 是 1，insertOffset 是 0。表达式为 2 - 1 - 0 == 1，不符合条件（注意代码中用的是 != 号），那么则不会添加到 moves 里，意味着 3 这个元素没有被移动。 再假设此时我们遍历到了新集合中的 7。 那么 index 是 2，oldArrayIndex 是 6，deleteOffset 是 3，insertOffset 是 0。表达式为 6 - 3 - 0 != 2，符合条件，所以判断 7 发生了移动。 最后遍历到 5 的时候， index 是 3，oldArrayIndex 是 4，deleteOffset 是 2，insertOffset 是 0。表达式为 4 - 2 - 0 != 3，符合条件，所以判5 也是发生了移动。 这样，我们就可以筛选出哪些元素发生了移动。 总结 epoxy 的 Diffing 算法大体可以分为一下几个部分： 将输入转换为 ContiguousArray 类型，提升效率。 使用哈希表，将同一个 id 的元素从新旧两个集合中摘出来，做匹配，同时记录原本的位置。 利用这个哈希表，配合 LCS 算法，找出哪些元素被删除，哪些元素是新增的。 根据需求，进一步将第三步的结果进行处理。 最后贴上一下我自己对源代码做的注释： /// 对两个 `Diffable` 元素集合（例如 `Array`）进行差异化处理，返回一个 `IndexChangeset`，表示从 `other` 到此集合的最小更改集合。 /// /// - Parameters: /// - from other: 旧数据集合。 public func makeChangeset(from other: Self) -&gt; IndexChangeset { // 在进行差异化处理之前将元素连续排列可以提高大约40%的性能。 let new = ContiguousArray(self) let old = ContiguousArray(other) // 通过 `dataID`，将 `self` 和 `other` 的对应元素存储到 `entries` 里。 var entries = [AnyHashable: Entry](minimumCapacity: new.count) var duplicates = [Entry]() // 用来记录新元素（`self`）和旧索引的一个对应关系 var newResults = ContiguousArray&lt;NewRecord&gt;() newResults.reserveCapacity(new.count) // for index in new.indices { // `new` 其实就是 `self`，从 `self` 里拿标识符 let id = new[index].diffIdentifier let entry = entries[id, default: Entry()] // 1. 记录这个新元素的位置 // 2. 判断当前数组的重复性，因为是数组，所以内部数据有可能会有重复的情况。 if entry.trackNewIndex(index) { duplicates.append(entry) } entries[id] = entry // `correspondingOldIndex` 默认是 `nil` newResults.append(NewRecord(entry: entry)) } // 用来记录旧元素（`other`）和新索引的一个对应关系 var oldResults = ContiguousArray&lt;OldRecord&gt;() oldResults.reserveCapacity(old.count) for index in old.indices { // 从 `other` 里拿标识符 let id = old[index].diffIdentifier // 用 `other` 的 `id`，去 `self` 里找对应的值 let entry = entries[id] // 如果找到的话，就将旧的索引存储到 `entry` 里。 // `entry` 里既存储了新（`self`）的索引，又存储了旧（`other`）的索引。 // 因为 `id` 是一样的，所以就通过 `id` 把新旧两个元素的索引对应起来了。 entry?.pushOldIndex(index) // `correspondingNewIndex` 默认是 `nil` oldResults.append(OldRecord(entry: entry)) } for newIndex in new.indices { // `newResults` 是通过遍历 new 得到的 // 所以 `index` 是一致的，可以直接用 `new` 的 `index` 拿到 `newResults` 的元素 let entry = newResults[newIndex].entry // 如果存在新元素对应的老元素的话，可能对应更新操作 if let oldIndex = entry.popOldIndex() { let newItem = new[newIndex] let oldItem = other[oldIndex] // 如果两个对象不相等，则是更新操作 if !oldItem.isDiffableItemEqual(to: newItem) { entry.isUpdated = true } // 记录两个元素相对的位置 // 可能从 `old` 更新到 `new`，所以索引是有需要的 newResults[newIndex].correspondingOldIndex = oldIndex oldResults[oldIndex].correspondingNewIndex = newIndex } } // 删除操作 var deletes = [Int]() var deleteOffsets = [Int]() deleteOffsets.reserveCapacity(old.count) var runningDeleteOffset = 0 for index in old.indices { deleteOffsets.append(runningDeleteOffset) let record = oldResults[index] // 这里等于 `nil`，意味着在上一个循环中，没有匹配到对应的 `new` 元素 // 所以意味着在 `new` 数组中，没有该元素存在，所以该元素被删除了 if record.correspondingNewIndex == nil { deletes.append(index) runningDeleteOffset += 1 } } var inserts = [Int]() var updates = [(Int, Int)]() var moves = [(Int, Int)]() var insertOffsets = [Int]() insertOffsets.reserveCapacity(new.count) var runningInsertOffset = 0 for index in new.indices { insertOffsets.append(runningInsertOffset) let record = newResults[index] // 有新，有老 if let oldArrayIndex = record.correspondingOldIndex { if record.entry.isUpdated { // 更新，记录元素的对应关系 updates.append((oldArrayIndex, index)) } // `insertOffsets` 和 `deleteOffsets` 里的值，类似于 `[0, 0, 1, 1, 1]` 这种形式 // 其长度分别等于 `new` 和 `old`，所以直接使用对应的 `index` 取值不会导致溢出 let insertOffset = insertOffsets[index] let deleteOffset = deleteOffsets[oldArrayIndex] // 旧位置 - 删除了的元素个数 + 新增了的元素个数 != 新位置 -&gt; 移动了 if (oldArrayIndex - deleteOffset + insertOffset) != index { moves.append((oldArrayIndex, index)) } } // 有新，没老 else { // 意味着新的元素相对于老的元素来说是插入进来的 inserts.append(index) runningInsertOffset += 1 } } EpoxyLogger.shared.assert( old.count + inserts.count - deletes.count == new.count, &quot;Failed sanity check for old count with changes matching new count.&quot;) return IndexChangeset( inserts: inserts, deletes: deletes, updates: updates, moves: moves, newIndices: oldResults.map { $0.correspondingNewIndex }, duplicates: duplicates.map { $0.newIndices }) } 后记 文章算是写完了，但是感慨自己虽然花了很多时间，算是 “弄明白” 了本算法，但是也仅限于看懂，然后感慨它的精妙。甚至不敢肯定以后遇到相似的需求时，能用上该算法。哎，希望今后还能有所长进。 ","link":"https://blog.rakuyoo.top/epoxy-source-code-notes-1/"},{"title":"加速 Swift Package Manager","content":"虽然国内实际开发用 Swift Package Manager（后称 SPM）的比较少，但是国外的一些开源库里却经常用到。所以经常遇到项目 clone 下来之后，SPM 加载失败导致项目无法运行的问题。 网上关于 SPM 加速的文章也有很多，方法也是五花八门，本文挑选几个进行记录。 根本问题 根本问题还是 Xcode 内部服务无法连接代理，导致访问 Github 经常超时。 所以解决方案还是要从代理入手。 解决方案 先列举一下本文记录的几种解决方案： 路由器端直接设置代理 通过命令行直接拉取 ClashX 增强模式 代理 Xcode 设置 SPM Mirror 以上方法在我看来谈不上哪个更好。开发应当在合适的时候选择合适的方案。 路由器端直接设置代理 在路由器上直接设置代理，从网络源头解决问题。但是哪怕是在一些公司，也不太方便添加软路由等方法做这些操作。有条件的个人可以搞一下。 通过命令行直接拉取 参考 如何让swift package manager走代理 具体方法： 首先是打开终端，然后在终端内按照 “为终端设置代理” 的方法，设置 https_proxy 、 http_proxy 和 all_proxy 在 项目根目录下 执行下列命令： xcodebuild -resolvePackageDependencies -scmProvider system 通过命令行直接拉取 SPM 依赖，执行完成后打开项目即可。 有的文章可能提到可以为 git config 设置代理，其命令为： # 需要将端口替换成自己的端口 git config --global http.proxy 'http://127.0.0.1:1080' git config --global https.proxy 'http://127.0.0.1:1080' 这里我没有进行尝试，有想法的读者可以自行尝试。 ClashX 增强模式 ClashX Pro 的增强模式可以穿透绝大多数软件，包括终端、Xcode。开启后直接使用 Xcode 即可下载依赖。 这个方案的缺点也比较明显：增强模式会导致一些内网服务不可用，所以建议仅在需要时临时打开，不建议常驻使用。所以你需要记得在 Fetch 成功后关闭增强模式。 如果好奇 ClashX 做了什么，可以参考：请问下增强模式是做了什么处理 代理 Xcode 如果你没有或者不想使用 ClashX，那么可以通过 Proxifier 进行拦截，然后再走代理。（不过虽然 Proxifier 提供了免费试用，但仍然算是收费那一档的） 有条件的伙伴可以查看 Xcode设置SPM代理 这篇文章，里面有详细的介绍。 设置 SPM Mirror 介绍和使用方法 最近偶然间发现，SPM 在 Swift 5 提供了一个 Mirror 镜像功能，提案在这里：Package Manager Dependency Mirroring 即如下命令： swift package config set-mirror --original https://github.com/QMUI/LookinServer.git --mirror http://git.aaaaaa.top/LookinServer.git --original 是原地址，而 --mirror 则是镜像仓库的 url。 所以有条件的通过可以在内网 Git 上 Fork Github Repo，或者在国内找寻现有镜像，然后通过 Mirror 下载依赖。 不过有一点需要注意：提案中有如下这么一句话： The Package.resolved file will contain the mirror URLs that were used during dependency resolution. 但是在 Xcode 15 上实践后发现 Package.resolved 显示的还是 Original URL，不是 Mirror URL。 搜索后发现有这么一个 issue：SwiftPM: mirrored URLs end up in Package.resolved file。也就是说 Package.resolved 文件中显示 Original URL 在现在是正确行为。至于 Fetch 时使用的哪个 url，可以在 Report navigator 中查看具体的 log。 Package.swift 如果你开发的是一个 Swift 框架，要管理 Package.swift 中的依赖（使用该文件打开项目）， 那么可以直接在项目根目录下执行上述命令。 xcodeproj 但是如果你是想为 xcodeproj 中添加的依赖设置 mirror，那么在项目根目录下使用 swift package config set-mirror 命令是会报错的：error: Could not find Package.swift in this directory or any of its parent directories. 通过报错可知该方法仅适用于 Package.swift 管理的项目。但是别着急。 在 Apple 文档 Adding package dependencies to your app 中有这么一小段描述： You can find the Package.resolved file inside your .xcodeproj directory at [appName].xcodeproj/project.workspace/xcshareddata/swiftpm/Package.resolved. 通过这段描述我们可以知道，project.workspace 里面有一个 swiftpm 目录，进入后会发现该目录下就有一个 configuration 文件夹。 所以我们可以直接将 set-mirror 命令生成的 mirrors.json 文件放到该文件夹下，即可完成镜像设置。 注意：一般情况下我们的 .gitignore 文件配置会导致该路径不会被提交到 git 上。这点请您注意。 此时回到 Xcode 中添加依赖，就会发现速度 ... 好像没有变化。这就十分尴尬了... 通过进一步观察、查看 log 以及搜索相关资料。我进一步确定：mirror 这个配置仅适用于 Package.swift 软件包。所以如果我们直接在 Xcode 里通过一个 github 的 url 来添加依赖，那么它是不会走 mirror 配置的。但是该依赖所依赖的其他组件，又能走 mirror 配置，因为它是一个 Package.swift 软件包。 所以回到这小节讨论的问题上：你只能使用上面提到的其他方法，来解决在 Xcode 里向 project 添加依赖的问题。 我们要放弃吗？并不是，我想到了一个折中/取巧的方法来解决该问题。详见我在 stackoverflow 上的回答。 总结 让我们回到实际场景下来看看上述提到的几个解决方案： 你的 CI/CD 只能访问内部网络： 不论你是在开发应用程序，还是你或你的公司在开发 SPM 软件包。在只能访问内部网络，完全无法访问 Github 的情况下，你只能通过 mirror 的方式来使用 SPM。 你的公司没有那么多要求，而且人均具备搭梯子的能力/你是具有搭梯子能力的个人开发者： 那么其他几种方法都可以满足你的需求。 ","link":"https://blog.rakuyoo.top/accelerated-swift-package-manager/"},{"title":"圆角 & 离屏渲染实践","content":"下文主要针对各种加圆角的情况进行实践，看看会不会出现离屏渲染的情况。 测试条件 测试平台：iPhone 12，iOS 16.3.1，Xcode 14.2。 测试方法：运行项目后，通过 Xcode 设置 “Debug -&gt; View Debugging -&gt; Rendering -&gt; Color Off-screen Rendered” 来打开离屏渲染检测。 主要测试点： 是否开启 masksToBounds 是否设置图片 是否设置背景色” 父视图是否具有透明度 结论 这里先把结论放到最前面，后面您可以跳过实践过程，直接切到解决方案一节。 ✅ 代表不会触发离屏渲染；❌ 代表会触发离屏渲染。 UIView UIImageView UIButton（只有文字） UIButton（图片/背景图） 直接设置 ✅ ✅ ✅ ❌ 背景色（非透明） ✅ ❌ ✅ ❌ 父视图具有透明度（alpha） ❌ ❌ ❌ ❌ 下面重点说一下 UIImageView 和 UIButton 的测试过程： UIImageView iOS 9 对 UIImageView 进行了一系列优化，相比较过去而言，触发离屏渲染的场景要小了不少 直接设置 lazy var testView = UIImageView().then { $0.image = UIImage(named: &quot;Forms/share-cover&quot;) $0.layer.masksToBounds = true $0.layer.cornerRadius = 30 } 一个设置了图片的 UIImageView。示例中同时设置了 masksToBounds 和 cornerRadius。从图片上可以看出来，并不会触发离屏渲染： UIImageView 不设置 masksToBounds，只设置 cornerRadius 的话不会显示圆角。 添加背景色 那如果我们手贱再给它添加一个背景色呢？ lazy var testView = UIImageView().then { $0.image = UIImage(named: &quot;Forms/share-cover&quot;) $0.layer.masksToBounds = true $0.layer.cornerRadius = 30 $0.backgroundColor = .white // 添加一个白色的背景色 } 果然手贱是没有好处的，设置了背景色后则会触发离屏渲染。 UIButton UIButton 默认也是没有背景色的，需要同时考虑文字和图片两种情况。 文字 如果不设置背景色的话，只有文字的 UIButton 对象是显示不出来圆角的，不过我也是分别测了一下。 lazy var testView = UIButton(type: .custom).then { $0.setTitle(&quot;这是一个标题&quot;, for: .normal) $0.layer.cornerRadius = 30 } 结论是：不论设置不设置背景色，只有文字的 UIButton 对象添加圆角后都不会触发离屏渲染。 同时只需要设置 cornerRadius，不需要开启 masksToBounds 就可以显示出来圆角。 图片 &amp; 背景图 因为现象一致，所以图片和背景图在这里归位一类进行讨论。 带图片的 UIButton 是重点测试对象，分下面几种情况： 直接设置 lazy var testView = UIButton(type: .custom).then { $0.setTitle(&quot;这是一个标题&quot;, for: .normal) $0.layer.masksToBounds = true $0.layer.cornerRadius = 30 $0.setImage(UIImage(named: &quot;Forms/share-cover&quot;), for: .normal) } 如果 UIButton 只设置 cornerRadius 而不开启 masksToBounds，那么图片是不会显示出圆角的。 从图上看，是会触发离屏渲染。 尝试解决离屏渲染问题 实践了哪些情况会触发离屏渲染，接下来就想办法尝试解决这些问题。 用父视图进行包裹 有的文章会提到用一个父视图包裹需要添加圆角的视图，然后将圆角添加到父视图上。 实践发现该方法并不能解决离屏渲染问题。 避免开启 masksToBounds UIImageView 视图可以在不开启 masksToBounds，仅设置 cornerRadius 的情况下显示圆角，只包含文字的 UIButton 对象也一样。 所以在这种情况下，不开启 masksToBounds 也可以避免触发离屏渲染。 为图片添加圆角 直接为图片添加圆角是比较常用的避免离屏渲染的方法。只不过现在比较常用的 UIImageView 视图已经不会触发离屏渲染了，但是 UIButton 依然可以这么做。 下面提几点实际需求里可能会遇到的问题： “拼接图片” 例如微信的群聊头像，可能涉及到多个图片在一个视图控件中进行展示。 这个时候最好将多张图片拼到一起，然后对这张图片整体设置圆角。而不是在一个 UIView 中尝试添加多个 UIImageVIew，再对 UIView 设置圆角。 视图尺寸不固定 一般 UIButton 会遇到 “尺寸不固定 + 需要圆角 + 背景色” 的情况。 例如页面某个位置有一个 “距离屏幕两侧 10px，可用状态背景色为蓝色，不可用状态下为灰蓝色” 的按钮。 此时可以考虑找 UI 切一个带圆角的纯色图片直接用作底色，但是我们开发也可以自己生成这样一张图片，然后通过拉伸来达到相同的效果。 首先我们先找喵神借用一个非常好用的枚举，来表示圆角： extension UIImage { enum Radius { /// 圆角半径应该按照图片**宽度**的比例计算。 /// 通常关联的值应该在0和0.5之间，其中0表示没有圆角，0.5表示使用图片宽度的一半作为圆角半径。 case widthFraction(CGFloat) /// 圆角半径应该按照图片**高度**的比例计算。 /// 通常关联的值应该在0和0.5之间，其中0表示没有圆角，0.5表示使用图片高度的一半作为圆角半径。 case heightFraction(CGFloat) /// 使用一个固定的点值作为圆角半径。 case point(CGFloat) func compute(with size: CGSize) -&gt; CGFloat { let cornerRadius: CGFloat switch self { case .point(let point): cornerRadius = point case .widthFraction(let widthFraction): cornerRadius = size.width * widthFraction case .heightFraction(let heightFraction): cornerRadius = size.height * heightFraction } return cornerRadius } } } 之后生成纯色图片： extension UIImage { static func color( _ color: UIColor, size: CGSize = .init(width: 1, height: 1), radius: Radius? = nil ) -&gt; UIImage { let cornerRadius = radius?.compute(with: size) let renderer = UIGraphicsImageRenderer(size: size) let image = renderer.image { _ in let rect = CGRect(origin: .zero, size: size) let path: UIBezierPath if let cornerRadius = cornerRadius { path = .init(roundedRect: rect, cornerRadius: cornerRadius) } else { path = .init(rect: rect) } color.setFill() path.fill() } guard let cornerRadius = cornerRadius else { return image } let insets = { UIEdgeInsets(top: $0, left: $0, bottom: $0, right: $0) }(cornerRadius) return image.resizableImage(withCapInsets: insets, resizingMode: .stretch) } } 你还可以扩展这个方法，配置需要圆角的位置，而不是为四个边都添加圆角，比较简单，这里就不再赘述了。 ","link":"https://blog.rakuyoo.top/off-screen-rendering-practice/"},{"title":"iOS自编笔试题","content":"最近要负责面试，于是各处搜罗了一些面试题，用于笔试（不包含算法），也当作自己的一个复习。 面试题部分请参考：iOS自编面试题 规则： 40分钟作答时间。 禁止使用手机查阅答案。禁止使用 ChatGPT 类软件查阅答案。 类名、变量名以及方法名，不记得全拼的允许使用缩写。 注： 本题目多数由 ChatGPT 生成，对应答案已记录在册。 Swift Swift中的let和var有什么区别？何时应该使用let？ Swift中的属性（Property）有哪些类型？它们的作用是什么？ Swift的常量（static）在什么时候确定？ 在Swift中，switch case 一个 NSObject 子类时，比较的是什么？ 请解释 Swift 中的范型擦除（Generic Erasure）是什么，并提供一个范型擦除的例子。 iOS 开发 你在实际工作中使用过UICollectionViewCompositionalLayout吗？如果使用过，请详细描述一下实现的功能。 请列举5-10个你最常用的三方库，并选择一个你最喜欢的进行介绍，阐述原因。 架构相关： 什么是单例模式？在iOS开发中，如何实现一个单例？ 代码格式规范 请列出你认为的 Swift 代码格式规范，包括但不限于缩进、空格、命名等方面。 在你的项目中，你如何确保代码格式的一致性？请举例说明。 请设计一个小模块，尽可能全面地向我展示你自己的编码风格。 ","link":"https://blog.rakuyoo.top/ios-self-paced-test-questions/"},{"title":"iOS自编面试题","content":"最近要负责面试，于是各处搜罗了一些面试题，用于当面面试使用（非笔试题），也当作自己的一个复习。同时提供了一个我自己角度的评判，仅供参考。 笔试题部分请参考：iOS自编笔试题 以下所以答案，如果面试时未能回答，作为补充问题回答正确后，相应分值 - 1。 回答了其他答案，正确且合理的情况下，酌情给分。 Swift 相关 主要考察Swift语法相关内容 基础 什么是Swift方法默认值？什么情况下会使用它？ 得分 分值 答案 1 在定义函数时给参数赋一个默认值，调用该函数时可以不传该参数值 3 减少函数重载的需要 1 避免在调用函数时多次输入相同的值 什么是Optional类型，它的作用是什么？如何使用Optional类型？ 得分 分值 答案 2 用来表示一个值可能存在，也可能不存在的情况 1 Optional 类型的作用是为避免因为没有处理 nil 而导致程序崩溃的问题 1 Optional 类型可以通过在类型名后加一个 ? 来定义 2 如果一个 Optional 类型的变量有值，那么可以使用可选绑定 （if let）将其取出 3 在使用 Optional 类型时，尽量避免使用强制解包 3 Optional 的实际实现是一个枚举 Swift中的struct和class有什么区别？什么情况下应该使用struct？ 区别： 得分 分值 答案 备注 1 class 支持继承，而 struct 不支持继承 - 1 class 支持类型转换，而 struct 不支持类型转换 这里的类型转换指的是子类和父类之间的隐式类型转换 1 class 是引用类型，而 struct 是值类型 - 使用情况： 得分 分值 答案 1 如果对象的复杂度较高，并需要支持继承和类型转换，应该使用 class 1 如果对象比较简单，并且需要高性能，可以考虑使用 struct 什么是 Swift 中的访问控制（Access Control）？它有哪些级别？ 得分 分值 答案 备注 1/3 Open: 可以被同一模块内和外部模块的代码访问，允许被继承和重写 提到外部模块计3分，否则1分 1/3 Public: 可以被同一模块内和外部模块的代码访问，但是在外部模块不能被重写或继承，内部模块可以 提到外部模块计3分，否则1分 1/3 Internal: 只能被同一模块内的代码访问，不能被外部模块访问（默认访问级别） 提到是默认权限计3分，否则1分 1 fileprivate: 只能被同一源文件内的代码访问 - 1 private: 只能在所定义的作用域内访问（比如函数、方法、类、结构体等），不能被同一文件中的其他作用域访问。 - 2 Xcode 生成的 struct 的初始化方法是 Internal 属性，有外部访问需求的话要手动实现 init 方法 - 什么是 Swift属性观察器（Property Observer）？ 得分 分值 答案 备注 1 知道属性观察器是 willSet 和 didSet - 1 只能应用于存储属性，而不能应用于计算属性 - 2+1 如果属性是在初始化期间（init和定义时赋值）设置的，则不会调用 willSet 和 didSet 观察器 回答 init，2分，回答定义时，1分，总分3分 Swift中一个方法如何返回多个值？ 得分 分值 答案 1 可以使用元组（Tuple）来实现一个方法返回多个值的效果 0 自定义类型、数组、字典等 什么是 Swift 中的 Extension（扩展）？如何使用 Extension？ 得分 分值 答案 1 允许开发者向已有的类型添加新的方法、计算属性等，而无需继承子类或使用 Objective-C runtime 1 不能添加存储属性或属性观察器 1 扩展中的方法不能和已有方法重名 2 使得代码更加模块化，易于维护 2 也可以对第三方类进行扩展，而无需改动原代码，更加方便地满足自己的需求 Swift中的协议（protocol）是什么？它有什么作用？ 如果回答中包含了协议中的范型等内容，参考 什么是范型 一题中的分值。 得分 分值 答案 备注 1 协议定义了一组方法、属性 - 1 可以被类、结构体和枚举类型实现，然后实现方就可以使用协议中提供的内容 - 3 提高代码的模块化程度、可重用性和可维护性，减少代码的耦合性 - 1/2 可以扩展协议，为协议添加默认实现 如果面试者没有提，可以进行提问“Swift 协议如何做默认实现？” 5 习惯使用扩展遵循协议，而不是在声明类型时 - -5 习惯在声明类型时遵循协议 - 1/3/10 提到了面向协议编程 仅仅提到，计1分；有对应描述、解释，计3分；描述详细，并配合示例，计10分 什么是泛型（Generic）类型？它们在Swift中有什么作用？ 笔试题中包含范型擦出，所以本题主要考察面试者有没有 “用范型提高代码可读性、维护性” 的意识。 在这里不必回答范型擦出。回答范型擦出不额外计分。 得分 分值 答案 1 可以用于定义函数、类、结构体、枚举等多种类型的通用类型机制 2 泛型类型可以用于消除代码重复，提高代码的可读性和可维护性 1 定义协议时，可以使用关联类型来实现更加灵活的数据处理 什么是Swift字面量协议？ 得分 分值 答案 1 ExpressibleByNilLiteral 1 ExpressibleByIntegerLiteral：允许类型从整数字面量创建实例。 1 ExpressibleByFloatLiteral：允许类型从浮点数字面量创建实例。 1 ExpressibleByBooleanLiteral：允许类型从布尔字面量创建实例。 1 ExpressibleByStringLiteral：允许类型从字符串字面量创建实例。 1 ExpressibleByArrayLiteral：允许类型从数组字面量创建实例。 1 ExpressibleByDictionaryLiteral：允许类型从字典字面量创建实例。 只要提到有这么几个协议（不用说出具体的名字），可以通过数字、字符串、Bool、数组、字典字面量来初始化对应的类型即可。 什么是延迟加载（懒加载，Lazy Loading）？在Swift中你一般什么时候使用它？ 得分 分值 答案 备注 1 在Swift中，延迟加载可以通过使用 lazy 关键字来实现 - 1 lazy 关键字可以用于属性 - 1 在第一次访问该变量或属性时，系统会执行相应的代码进行初始化 - 5 几乎无脑使用懒加载来定义任何的属性 - Swift中的高阶函数（Higher Order Function）有哪些？请分别说明它们的作用。 主要包含以下几个即可，其余的例如 contains、allSatisfy 等说了也计1分。 如果只说出了函数名，没有说明作用，依然得分。或者能说出来功能，具体函数名拼不全也可。 如果下面这些没有说全，面试官可提示 “还有没有了？” 得分 分值 答案 备注 1 map：将一个集合中的每个元素通过一个函数映射为另一个元素，返回一个新的集合 - 1 filter：过滤一个集合中符合特定条件的元素，返回一个新的集合 - 1 reduce：通过对一个集合中的所有元素进行累加或累积操作，返回一个最终的结果 - 1 flatMap：将一个集合中的每个元素通过一个函数映射为另一个集合，然后将所有集合中的元素合并为一个新的集合 - 1 compactMap：对一个序列进行变换操作，并返回一个新的序列，该序列将所有的 nil 元素去除 - 1 sorted：对一个集合中的元素进行排序，返回一个新的排序后的集合 - 1 forEach：对一个集合中的每个元素执行一段特定的代码 - flatMap 和 compactMap 这两个之间有什么区别？ 得分 分值 答案 备注 1 flatMap 用于高维数组的降维，例如二维数组拍平为一维数组 - 1 compactMap 用于过滤数组中的可选值，去掉所有返回 nil 的元素 - 3 Swift 4.2 中将这两个函数拆开，不可混用 提到不可混用即可 进阶 在Swift中如何实现一段代码在整个程序的生命周期内只会执行一次？ 得分 分值 答案 备注 0 dispatch_once 不得分，Swift 3 及以上版本已废弃 0 单例 不得分，题目要求的是 “一段代码”，而不是一个对象 3 (lazy var)/static + Void 类型的属性，定义时使用 {}() 包括需要执行的代码。借助了懒加载的特性 Swift中的类型推断（Type Inference）是什么？请说明它的作用 得分 分值 答案 备注 2 编译器能够推断出变量或常量的类型而不需要显式声明其类型 - 2 使代码更加简洁，减少了类型声明的冗余，同时也减少了因类型声明错误而引起的编译错误的可能性 - -10 不建议使用 如果面试者说建议显式声明类型（除非是为了解决Xcode代码提示的bug），否则扣10分 Swift中的final关键字是什么意思？它的作用是什么？ 得分 分值 答案 备注 1+2+2 final 关键字可以修饰类、方法和变量 提到类计1分；提到方法、变量每个2分，总分5分 1 final 修饰后不可集成、不可重写 - 3 private 的类型，其内的属性和方法会在编译时自动添加 final - Swift中的String类型和ObjC中的NSString类型有什么区别？ 得分 分值 答案 1 底层实现不同，Swift 的 String 类型是一个值类型，而ObjC的 NSString 类型是一个类 1 Swift的 String 类型可以无缝地与ObjC中的 NSString 类型互相转换 2 Swift中的字符串是Unicode兼容的，可以直接使用Unicode字符和表情符号，而ObjC中的字符串是基于ASCII编码的，无法直接处理Unicode字符和表情符号 Swift中的枚举相比较ObjC中的枚举有什么优势？ 得分 分值 答案 2 每个枚举成员可以有自己的关联值，这使得枚举更加灵活。而ObjC中的枚举只能包含整数 3 枚举是一等公民，它和类、结构体等类型一样，可以有自己的方法，甚至遵循协议。 Swift中的延迟（Defer）语句有什么作用？ 得分 分值 答案 备注 0/2/3 Defer语句可以用来在函数/作用域执行完毕之前执行一些清理工作 回答 “函数” 0分，“作用域” 2分，能给出作用域的例子，例如 if 中使用的情况，3分。如果面试者没提到作用域问题，则可以当作进阶问题抛出 1 Defer语句可以用来执行一些清理工作 - 1 无论函数是正常返回还是抛出异常，都会执行 - 1 虽然形式上像是闭包，但更像是语法糖，所以不会捕获变量 - 2 当函数内有多个 defer 语句时，将按照倒序的顺序执行，即最后一个 defer 先执行 如果面试者没回答，则可以当作进阶问题抛出 什么是Swift方法派发？有哪几种？ 方法调度和方法派发是一回事，不同的翻译 得分 分值 答案 备注 1 宏观上分为静态（直接）派发和动态派发两种 - 3 其中动态派发又包含两种：表派发/函数表派发和消息派发 - 5/6 静态派发：编译时找到指令所在的位置。所以执行速度快，还允许编译期做各种优化，例如内联 提到内联，额外加1分，共6分 5/6 表派发：运行时决定实现方式，理论上速度也很快，编译期决定函数表 提到编译期决定寒暑表，额外加1分，共6分 5 消息派发：Objective-C 的逻辑，可以在运行时修改消息接收对象 - 5 会通过看 SIL 确定派发方式 - 请说明Swift中Array类型的底层实现方式 总分值10分 Array 使用了一个名为“缓冲区”（buffer）的数据结构来存储元素。 缓冲区由三个部分组成： 指向元素存储位置的指针 缓冲区的容量大小 缓冲区的元素个数 Swift的switch语法和ObjC的switch语法，在底层实现方式上有什么区别？ 总分值10分 ObjC 的 switch 还是某种意义上的 goto 语法，命中的时候会跳到对应的代码的地址，这段代码是连续的，需要 break 来决定执行到哪里。这种实现方式主要是为了方便从早期 C 语言中继承而来。 而 swift 的 switch 会被编译成类似 if else 的语法，作用域更明确。 SIL是什么？怎么将Swift代码转换为SIL代码？ 得分 分值 答案 备注 1 SIL是Swift中间语言，是源代码和机器代码之间的一种中间代码 - 1/2 编译器会将Swift代码编译成SIL，然后对SIL进行优化和转换，最后将其编译成机器代码 提到编译器对 SIL 进行优化，计2分，否则计1分 3 使用 swiftc -emit-sil + &lt;file_name.swift&gt; 将 swift 文件转换为 SIL 代码 - 请简述 Swift extension 的实现原理 总分10分 在 Swift 内部，每个类或结构体都有一个名为 vtable（虚函数表）的表格，其中记录了类或结构体的方法的地址。当 Swift 调用一个方法时，它会先检查类或结构体的类型，然后查找该类型的 vtable 表格，以获取该方法的地址并调用它。 当我们在 Extension 中定义一个新方法时，Swift 编译器会将其添加到 vtable 表格中，并根据需要重新生成 vtable 表格，以确保所有方法都在正确的位置。这就是 Swift Extension 实现的底层原理。 iOS 开发相关 主要考察 iOS 开发相关知识点，和具体开发语言没有太大的关系。 基础 请简述iOS开发中，APNS的推送机制 总分5分 APNS的推送机制包括以下几个步骤： 应用程序在设备上注册远程通知。注册成功后，设备会产生一个唯一的令牌（device token），用于标识该设备。 应用程序将令牌发送给后台服务器，后台服务器将令牌与设备绑定起来。 当需要向设备发送通知时，后台服务器发送一个推送通知请求到APNS服务器。 APNS服务器将推送通知发送到指定的设备上。 设备接收到推送通知后，根据推送通知的内容执行相应的操作，例如打开应用程序、显示提醒等。 常见的触发离屏渲染的场景有哪些？ 总分10分 进阶 离屏渲染是什么？为什么会触发离屏渲染 总分15分 什么是RunLoop？RunLoop的运行模式有哪几种？ 总分10分 RunLoop是iOS中的一个事件循环机制，负责处理用户事件，如触摸事件、定时器事件、网络请求事件等，同时还要处理UI更新、线程通信等任务。 RunLoop会将事件源分发到相应的处理器进行处理，如果RunLoop没有事件需要处理，那么它会进入休眠状态，直到有新的事件到来。 常见的RunLoop运行模式有以下几种： DefaultRunLoopMode：默认模式，处理UI事件、定时器、网络事件等。 UITrackingRunLoopMode：处理UIScrollView滑动过程中的事件，优先级高于DefaultRunLoopMode。 CommonModes：是一个集合模式，可以添加多个模式，包括DefaultRunLoopMode和UITrackingRunLoopMode等，用于处理需要同时响应多个模式下的事件。 在运行RunLoop时，需要指定一个运行模式，如果没有指定，则会使用DefaultRunLoopMode。 iOS开发中的响应链机制是什么？请举例说明 总分15分 在iOS应用中，将用户的触摸事件（touch event）传递到正确的视图（view）或者控制器（controller）的过程就是响应链。 当用户在屏幕上进行触摸时，触摸事件会被UIWindow捕获，并从UIWindow开始向下传递，直到找到合适的响应者处理事件为止。 当用户触摸到界面上的按钮时，iOS系统会将此事件封装成一个 UIEvent 对象，并通过 UIApplication 对象将该事件发送给当前 UIWindow 对象。接着，该 UIWindow 对象会将该事件发送给最前端的 UIResponder 对象，即当前展示在屏幕上的 UIViewController 的 view 属性对应的 UIView 对象。这一过程即为响应链的开始。 接着，该 UIView 对象会通过 hitTest:withEvent: 方法判断当前触摸点是否在该 UIView 对象内。如果在，则该 UIView 对象会将该事件传递给自己的 touchesBegan:withEvent: 方法进行处理。如果不在，则该 UIView 对象会将该事件传递给其子视图进行处理。这一过程就是响应链的传递过程。 当子视图接收到事件后，会按照相同的方式进行处理。如果该子视图的 userInteractionEnabled 属性为 NO，则该视图将不会响应该事件，并将该事件传递给下一个响应者。如果子视图的 userInteractionEnabled 属性为 YES，则该视图会先进行 hitTest:withEvent: 方法的判断，如果触摸点在该视图内，则该视图将该事件传递给自己的 touchesBegan:withEvent: 方法进行处理，否则将该事件传递给下一个响应者。 最终，如果所有的子视图都没有处理该事件，则该事件会传递给该 UIView 对象的父视图进行处理，一直传递到 UIWindow 对象和 UIApplication 对象。如果该事件都没有被处理，则该事件将被丢弃。 架构相关 主要考察架构、设计能力 基础 什么是MVC架构？它的组成部分是什么？在iOS开发中，如何实现MVC架构？ 总分10分 什么是MVVM架构？它的组成部分是什么？在iOS开发中，如何实现MVVM架构？ 总分15分 什么是装饰器（Decorator）模式？在Swift中如何使用？ 得分 分值 答案 1 装饰器模式允许开发者在不修改对象结构的情况下，动态地添加行为。 3 在 Swift 中，装饰器模式可以通过使用协议和扩展来实现。 5 具体来说，可以定义一个协议来表示被装饰者的基本行为，然后创建一个装饰器协议，该协议继承自被装饰者协议，并添加了额外的行为。最后，可以使用一个类来实现装饰器协议，该类通过存储被装饰者对象的引用来实现对被装饰者对象的包装。 进阶 什么是尾递归优化（Tail-Call Optimization）？在Swift中如何实现尾递归优化？ 得分 分值 答案 2 尾递归优化是一种优化技术，它可以避免在递归算法中出现栈溢出的问题 3 在递归函数的最后一个操作是调用自身，并且没有其他操作时，尾递归优化可以将递归转换为循环，避免了栈的增长 什么是函数柯里化（Function Currying）？在Swift中如何实现函数柯里化？ 得分 分值 答案 2 函数柯里化是一种将多个参数的函数转换为一系列只有单个参数的函数的技术 3 在swift中，可以通过将函数返回值声明为闭包类型，将原本需要的参数放到返回值的闭包中，来实现函数柯里化 设计 在你的项目中，你是如何划分模块（Module）和层级（Layer）的？请举例说明。 总分10分 开放式题目。 不用 target-action 的方式如何设计一个路由组件？ 总分20分 开放式题目。 当你从ObjC转到Swift之后，你最大的感触是什么？ 总分20分 开放式题目。 当你从ObjC转到Swift之后，你做了哪些事让你的Swift代码看上去不那么ObjC？ 总分30分 开放式题目。下面提供几个示例： 使用Swift的数据结构和类型：使用Swift的Array、Dictionary等数据结构，避免使用NSArray和NSDictionary等。 使用Swift的可选型（Optional）：使用可选型来处理变量是否存在的情况，而不是定义0，空字符串，或者使用ObjC中的nil或NSNotFound等。 使用Swift的语言特性：使用Swift中的高阶函数和闭包等语言特性，避免使用ObjC中的循环和函数指针等。 减少使用全局变量：尽量避免使用全局变量，而采用更具体和局部的方式来传递数据。 减少使用强制类型转换：尽量避免使用强制类型转换，而采用更安全和优雅的方式来处理类型转换。 ","link":"https://blog.rakuyoo.top/ios-self-paced-interview-questions/"},{"title":"Python：Celery 的简单使用","content":"最近写的后端项目需要用到队列，其中有一些东西折腾了好一会儿，在这里记录一下。 Celery 是一个开源的分布式任务队列，可实现异步任务调度、定时任务、任务结果处理等功能。 本文基于 Celery 5.2.7 版本编写。 概览 Celery 其实包含了几个概念：Celery 客户端、消息中间件 Broker、结果存储 Backend 以及 任务执行单元 Worker。 大致的流程是：Celer 客户端发起任务 -&gt; 相关信息存储到消息中间件 Broker 中 -&gt; 任务执行单元 Worker 从 Broker 中读取任务（Task）然后执行 -&gt; 将执行结果存储到 Backend 中 -&gt; Celery 客户端从 Backend 中读取结果。 Celery 支持多种消息中间件和结果存储，本文主要使用 Redis 作为中间件和结果存储。 Celery 对象的初始化 &amp; 配置 在 Celery 类用 __init__ 方法初始化之后，有两种配置方式： __init__ 可以在初始化 Celery 对象的同时传入对应的配置。有以下几个比较常用的参数： main：主模块的名称 broker：消息中间件存储的访问地址 backend：结果存储服务的访问地址（可选的） 例如说一个可能的 Celery 对象的初始化代码为： from celery import Celery celery = Celery('flaskr', broker='redis://localhost:6379/0', backend='redis://localhost:6379/0') 可以使用同一个 Redis 服务同时作为中间件和结果存储。 flaskr 是包含 Celery 客户端的 Python 程序的名称，如果使用 Flask 框架开发，那么应当是和初始化 Flask 对象时使用的名称一致。 上文有提到 backend 是可选的，如果不传该参数，那么就无法通过 Celery 查询到任务的执行结果。 config_from_object Celery 类还提供了一个 config_from_object 方法，支持通过 “Python 配置文件” 进行配置。使用上代码类似下面这样： from celery import Celery celery = Celery('flaskr') celery.config_from_object('flaskr.tools.celery_config') celery_config 是文件名。flaskr.tools.celery_config 是这个文件的 “路径”，或者说当我们想要在代码中 import 该 python 文件时使用的路径。 celery_config.py 文件中的内容为： from os import environ CELERY_REDIS_URL = &quot;redis://&quot; + \\ &quot;:&quot; + \\ environ.get(&quot;REDIS_PASSWD&quot;) + \\ &quot;@&quot; + \\ environ.get(&quot;REDIS_HOST&quot;) + \\ &quot;:&quot; + \\ environ.get(&quot;REDIS_PORT&quot;) + \\ &quot;/&quot; + \\ environ.get(&quot;REDIS_DATABASE&quot;) BROKER_URL = CELERY_REDIS_URL CELERY_RESULT_BACKEND = CELERY_REDIS_URL 在该文件中，我们可以从环境变量中读取配置，或者直接写死了我们所需要的配置字段。 注意 Celery 对象的初始化以及配置必须要放在顶层，下面的代码是不行的： from celery import Celery celery = Celery('flaskr') def init_app(app): celery.config_from_object('flaskr.tools.celery_config') 因为后续 Worker 将会根据配置的路径，寻找 Celery 对象，从该对象中获取相应的配置。 该过程可以理解为：“不是获取一个已经初始化好了的对象，而是根据配置的路径，找到对应的文件/模块，重新初始化 Celery 对象”。 该过程只会执行顶层属性、方法，也就是说它不会调用你的 init_app 方法，所以这么写之后 Worker 侧的 Celery 对象属于只是被初始化但是没有被配置过的状态，所有的配置项都会是默认值。 Worker Worker 服务是独立于 Celery 客户端程序的，需要单独另起一个服务。 在终端执行下面的命令启动 Worker 服务： celery -A flaskr.libs.system worker -l info 其中 -A 参数后面接着的 flaskr.libs.system 是 Celery 对象所在的模块/文件路径。和 config_from_object 一样，这里也是 “当我们想要在代码中 import 该 python 文件时使用的路径”。要确保该路径下包含着 Celery 对象。 -l 参数是日志等级，示例中指定到 info 级别。 Celery 的使用 下面简单的介绍一下 Celery 框架的使用方法。 上文中有提到，Worker 会在运行时读取 Celery 客户端中的 Task 任务并执行。 定义任务 下面是一个简单的 Task 的定义： # in tasks.py from flaskr.libs.system import celery @celery.task def add(x, y): return x + y 你可以将其定义为顶层/全局方法，也可以将其包裹在类中。 如果包裹在类中，会涉及到 self 参数问题，请参考后面的小节：任务中的 self 上文我们在 flaskr.libs.system 模块下定义了 celery 对象，然后就可以在 tasks.py 文件中使用 @celery.task 装饰器，使一个方法成为 Celery 任务。 注意：如果你的 Celery 对象不叫 celery 而是其他名字，例如 app。那么你的装饰器应该是 @app.task —— task 是 Celery 对象的方法。 在 Task 任务内，return 结果代表着 “任务执行成功”，通过 raise 抛出异常意味着 “任务执行失败。” 执行任务 对任务方法调用 delay 方法以传递参数并执行任务： # 使用参数 4，5 调用任务 add result = add.delay(4, 5) # 对执行结果调用 get() 方法以获取任务执行结果 print(result.get()) get() 方法获取的是任务执行成功之后的结果，即 return 的结果。 如果要获取 raise 抛出的异常，我们可以使用 result.result 方法获取异常。 判断状态 在获取任务的执行结果之前，我建议您先判断当前任务的执行状态。 Celery 框架提供了 AsyncResult 类来查询任务执行状态： def exec_task(self): &quot;&quot;&quot;执行任务，并返回任务 ID&quot;&quot;&quot; result = add.delay(4, 5) task_id = result.task_id return task_id def check_status(self, task_id): &quot;&quot;&quot;根据任务 ID 查询任务状态&quot;&quot;&quot; from flaskr.libs.system import celery result = celery.AsyncResult(task_id) 有一些文章会执行使用 AsyncResult 类，而不是通过 celery 对象调用 AsyncResult。 但是在我实际操作过程中发现，不通过 celery 对象调用的话会找不到 Backend，怀疑也是和配置有关。 result 对象有一个 task_id 属性，使用该属性值作为参数初始化 AsyncResult 对象，就可以查询该任务的状态： result.state：获取当前任务的状态（字符串） result.ready()：判断任务是否已经结束（成功 or 失败） result.successful()：判读任务是否成功 result.get()：和上文提及的一样，获取执行成功的任务的结果（return） result.result：和上文提及的一样，获取执行失败的任务抛出的异常（raise） 一种有可能的处理流程如下： def check_status(self, task_id): # 查询任务状态 from flaskr.libs.system import celery result = celery.AsyncResult(task_id) logging.info(f&quot;查询任务结果，任务ID（{task_id}）对应的状态为：{result.state}&quot;) # 任务仍在执行中 if not result.ready(): return { &quot;code&quot;: &quot;105&quot;, &quot;message&quot;: &quot;任务仍在执行中&quot; } # 任务失败 if not result.successful(): error = result.result return { &quot;code&quot;: &quot;9999&quot;, &quot;message&quot;: f&quot;{str(error)}&quot; } # 获取任务执行结果 task_result = result.get() return { &quot;code&quot;: &quot;200&quot;, &quot;data&quot;: task_result, &quot;message&quot;: &quot;任务执行成功&quot; } 任务中的 self .task() 方法有一个 bind 参数，它的默认值是 False。该参数可以控制是否将任务绑定到实例对象上。这关乎到 self 参数的具体值。 定义在类中的任务 如果你的任务定义是包裹在类中，像是这样： from flaskr.libs.system import celery class Tasks(object): def __init__(self, value): self.value = value @celery.task def add(self, x): return x + self.value 那么此时需要注意，因为 bind 参数的默认值是 False，所以此时 add 任务没有被绑定到 Tasks 类实例上，所以此时 self 参数指的是任务本身，而不是 Tasks 类的实例对象。此时在 add 方法中，你将无法获取到 self.value 的值。 如果你想在 add 方法中使用 self.value，你需要将 bind 参数设置为 True，像是这样： ... @celery.task(bind=True) def add(self, x): return x + self.value ... 此时你可以顺利的获取到 self.value 的值。 定义在顶层的任务 如果任务直接定义在文件中，类似下面这样： from flaskr.libs.system import celery @celery.task def add(x, y): return x + y 那么首先，此时 bind 参数的值是 False。这个时候您无法在 add 方法的参数列表中添加 self，也无法在方法实现内使用 self 参数，这会导致编译失败。 如果你将 bind 设置为 True，那么就可以添加 self 参数了，例如下面这样： from flaskr.libs.system import celery @celery.task(bind=True) def add(self, x, y): return x + y 那么此时 self 代表什么呢？ 上文有提到，bind 参数用于将任务绑定到类实例。 实际上，此时 Celery 会在后台自动将该任务转换为一个带有实例方法的类，使你可以在任务函数中访问实例属性和方法。在这种情况下，self 参数表示当前任务的实例对象，就像在类中定义任务一样。 重试 Celery 框架本身支持 “重试” 功能，包含自动重试和手动重试两种方法。这里简单介绍一下手动重试的用法。 retry 方法的调用 # in tasks.py from flaskr.libs.system import celery @celery.task(bind=True) def add(self, x, y): try: # 某些可能会抛出异常的方法 return __some_method_may_throw_exceptions() except Exception as e: # 出错每15秒尝试一次，总共尝试3次 raise self.retry(exc=e, countdown=15, max_retries=3) finally: pass 该例子中，我们在文件内直接定义了一个任务，而且 bind 参数被设置为了 True。此时我们要通过 self 参数来调用 retry 方法，执行手动重试。 那如果 bind 是 False 的情况呢？此时我们可以使用 add.retry(...) 来触发手动重试。 如果任务定义在类中： 如果 bind 是 False，则可以直接使用 self.retry(...) 触发手动重试。 如果 bind 是 True，则需要使用 add.retry(...) 触发手动重试。 总结一下不同的场景： 任务定义在类中： 如果 bind 是 False，则可以直接使用 self.retry(...) 触发手动重试。 如果 bind 是 True，则需要使用 add.retry(...) 触发手动重试。 任务定义在文件中： 如果 bind 是 False，则可以直接使用 add.retry(...) 触发手动重试。 如果 bind 是 True，则需要使用 self.retry(...) 触发手动重试。 可以说定义在类中和定义在文件中，对于相同的 bind 参数，调用方式是相反的。 retry 方法的参数 说完了调用，我们来说一下参数。 countdown 定义重试的间隔，max_retries 定义最多重试几次。 exc 参数是一个可选参数，它代表着 “当前任务失败时产生的异常”。通过将 e 参数传递到 retry 方法中，可以让重试失败后抛出最开始的异常。您也可以自定义该异常参数。 在使用 retry 方法时，如果没有指定 exc 参数，Celery 框架将默认将任务的异常信息传递给 retry 方法。如果指定了 exc 参数，则会将指定的异常对象传递给 retry 方法。 retry 方法的结果 在上面的例子中，我们使用了 raise 将 retry 失败后的异常抛出，意味着任务失败。 同时我们还可以不使用该参数，在重试失败之后手动处理异常，例如： # in tasks.py from flaskr.libs.system import celery @celery.task(bind=True) def add(self, x, y): try: return __some_method_may_throw_exceptions() except Exception as e: max_retries = 3 # 超过最大次数，返回错误信息 if self.request.retries &gt;= max_retries: return __create_error_response() self.retry(exc=e, countdown=15, max_retries=max_retries) finally: pass 在这个例子中，如果超过了最大重试次数，因为我们没有将重试的异常抛给外界，所以在最后一次重试失败之后会再次触发 except，此时我们可以判断是否超过了最大重试次数，意味着重试失败。 当重试失败后，我们可以根据需求进行失败处理。 ","link":"https://blog.rakuyoo.top/simple-use-of-python-celery/"},{"title":"可组合的 UICollectionView 布局：UICollectionViewCompositionalLayout","content":"UICollectionViewCompositionalLayout 是 Apple 在 iOS 13 引入的，用于构建基于组合的 UICollectionView 布局的类。它允许开发者根据一系列的组合布局，更轻松、更灵活地创建复杂的 UICollectionView 布局。 本文主要围绕 UICollectionViewCompositionalLayout 中 “可组合” 这个特性进行讨论。 本文建立在您已经大致了解过 UICollectionViewCompositionalLayout，知道它是什么，以及基础的用法。下文将不再对其进行讲解。 组合类 FlowLayout 布局 在上一篇文章 NSCollectionLayoutGroup 之子视图的填充 的最后有提到一个场景，这里复用一下这个场景： 在前文中，我有说中间的 “工具Group” 不能使用 subitems 的形式进行初始化，应该使用 subitem + count 的形式初始化 —— 其实这不完全对。 实际需求上，如图这种类 FlowLayout 的布局往往会要求 “每行X个”，即平分展示。 此时如果你们需要考虑下面的场景： 屏幕旋转。 iPad 等屏幕尺寸会发生变化的情况。 AutoLayout 侧不想要获取屏幕尺寸去计算出 cell 宽度。 那么 subitem + count 就没法做了：subitem + count 会忽略布局方向上的尺寸，所以此时很难单纯用 AutoLayout 做出平分的效果，或者说为了实现平分，需要多次刷新页面布局。 此时有一种用 subitems 实现的方式：以每行/列作为一个 Group，Group 内使用 subitems。大致的代码如下所示： let itemSize = NSCollectionLayoutSize( widthDimension: .fractionalWidth(1/4), heightDimension: .estimated(69) ) let normalLayoutSize = NSCollectionLayoutSize( widthDimension: .fractionalWidth(1), heightDimension: .estimated(500) ) let toolsListGroup = NSCollectionLayoutGroup.horizontal( layoutSize: normalLayoutSize, subitems: [ .init(layoutSize: itemSize) ] ) let rows = 5 let toolsGroup = NSCollectionLayoutGroup.vertical( layoutSize: normalLayoutSize, subitems: [ [toolsTitleItem], Array(repeating: toolsListGroup, count: rows), [ toolsFooterItem, sectionPaddingItem ], ].flatMap { $0 } ) 上面的代码首先定义了2个 Size，一个是 Item 的尺寸，另外一个算是一个 “占位符”。 然后是2个 Group： toolsListGroup 以行为单位展示 cell。 toolsGroup 则是最外面的 Group，它的 subitems 包含多个不同的 Group。其中的 Array(repeating: toolsListGroup, count: $0) 则是根据行数生成对应数量的 Group。 这种写法有一个注意点还有一个疑惑： 注意点是：当 cell 的数量不是行的整数倍的时候，需要手动创建占位 cell。 举例来说，cell 有 5 个，对应的就是2行，cell 分布是 4 + 1。此时因为后面还有其他等待被填充的 Item/Group，如果没有创建占位 cell，则后面的 cell 会被提前，使用 toolsListGroup 里的 Item 布局。 疑惑的是：我并不知道为什么这么做能生效。 按理说 subitems 的布局方式是不会限制内容的数量的，那么为什么它能每行正好装4个（就这个例子来说，每个Cell的宽度是屏幕的1/4），下一行的 Cell 则使用下一个 Group 的布局？ 有关于 UICollectionViewCompositionalLayout 组合复杂布局的文档还是太少，目前还没找到这么做能生效的原因。 ","link":"https://blog.rakuyoo.top/composable-uicollectionview-layout-uicollectionviewcompositionallayout/"},{"title":"NSCollectionLayoutGroup 之子视图的填充","content":"本篇主要讲解 NSCollectionLayoutGroup 内 “子视图” 的填充方式。 算是为 UICollectionViewCompositionalLayout 的讲解做一些铺垫，毕竟把 Item 的填充方式了解清楚了之后，才能组合多种 Group 来进行更复杂的布局。 NSCollectionLayoutGroup 不考虑方向的话，有两种填充子视图的方法。 概览 通过头文件您能查到如下几个初始化方法： open class func vertical(layoutSize: NSCollectionLayoutSize, subitems: [NSCollectionLayoutItem]) -&gt; Self @available(iOS, introduced: 13.0, deprecated: 16.0) open class func vertical(layoutSize: NSCollectionLayoutSize, subitem: NSCollectionLayoutItem, count: Int) -&gt; Self @available(iOS 16.0, *) open class func vertical(layoutSize: NSCollectionLayoutSize, repeatingSubitem subitem: NSCollectionLayoutItem, count: Int) -&gt; Self @available(iOS, introduced: 16.0, deprecated: 16.0, renamed: &quot;vertical(layoutSize:repeatingSubitem:count:)&quot;) public class func verticalGroup(with size: NSCollectionLayoutSize, repeatingSubitem subitem: NSCollectionLayoutItem, count: Int) -&gt; NSCollectionLayoutGroup 第三个方法是 iOS 16 新出的，同时废弃了第二个方法，而第四个方法在 iOS 16 引入同时又在 iOS 16 废除。 后文将围绕前两个方法展开讨论，不涉及到后两个方法。 subitem + count 这种初始化方式将在每个 Group 中重复 count 个 item。使用这种方法进行初始化时，在不同的方向上，layoutSize 会有不同的表现： vertical func vertical(layoutSize: NSCollectionLayoutSize, subitem: NSCollectionLayoutItem, count: Int) -&gt; NSCollectionLayoutGroup 在纵向上，NSCollectionLayoutItem 的 widthDimension 生效，但是heightDimension 将被忽略。 Item 的实际高度会是 .fractionalHeight(1/count)。 假设现在有下面这些代码： let itemSize = NSCollectionLayoutSize(widthDimension: .fractionalWidth(1/3), heightDimension: .absolute(100)) let item = NSCollectionLayoutItem(layoutSize: itemSize) let groupSize = NSCollectionLayoutSize(widthDimension: .fractionalWidth(1), heightDimension: .absolute(100)) let group = NSCollectionLayoutGroup.vertical(layoutSize: groupSize, subitem: item, count: 2) 此时 Item 的实际高度会是 50，相当于一个高度为 100 的 Group 内有2个高度为 50 的 Item。 horizontal func horizontal(layoutSize: NSCollectionLayoutSize, subitem: NSCollectionLayoutItem, count: Int) -&gt; NSCollectionLayoutGroup 和 vertical 时的情况相对应： 在横向上，NSCollectionLayoutItem 的 heightDimension 生效，但是widthDimension 将被忽略。 Item 的实际宽度会是 .fractionalWidth(1/count)。 这里就不再用代码举例说明了。 subitems 和上一种初始化方法相比，使用 subitems 的方式来进行初始化要简单的多，因为它内部的 Item 的大小完全取决于 Item 自身。考虑如下代码： let itemSize = NSCollectionLayoutSize(widthDimension: .fractionalWidth(1/3), heightDimension: .absolute(100)) let item = NSCollectionLayoutItem(layoutSize: itemSize) let groupSize = NSCollectionLayoutSize(widthDimension: .fractionalWidth(1), heightDimension: .absolute(300)) let group = NSCollectionLayoutGroup.vertical(layoutSize: groupSize, subitems: [item]) 该示例中，每个 Item 的高度就是 100，而宽度是 Group 的 1/3。每个 Group 中有多少个 Item 取决于数据源传递给 UICollectionView 的数量。 有一点需要注意的是，Group 只是用来辅助布局的，它本身并不会生成任何视图。所以尽管在本示例中它的高度只有 300，不足 UICollectionView 的高度，但是 Item 依然会充满整个 UICollectionView，而不是仅仅在高度为 300 的范围内进行滑动。 我并不能肯定这种现象可以称之为 “忽略 Group 的 layoutSize”，所以没有使用这种表述。 总结 这两种初始化方式各有各的用途： 在不考虑嵌套布局（Group 中嵌套 Item 和 Group）的情况下，这两种布局的使用场景大体上一致，只需要注意各自对 Item 大小的计算规则即可。绝大多数情况下我自己会选择 subitems 的初始化方式，因为 Item 的大小计算规则更为直观。 但是在嵌套布局的前提下，这两种初始化方式就会有比较大的差异。 首先嵌套布局的最外层只能使用 subitems 的方式初始化，数组中包含多种不同的 Item 或者 Group。 其次如果需要指定 Item 的数量，那么就只能使用 subitem + count 的初始化形式。 考虑下图的场景： 如果现在要求顶部的标题、中间的工具和下方的灰色分隔条，三部分放到一个 NSCollectionLayoutGroup 对象中，可以使用 [标题Item + 工具Group + 灰条Item] 的组合布局形式。 此时 “工具Group” 就不能使用 subitems 的方式进行初始化了，必须要指定工具的数量，否则 UICollectionView 会把下方的灰条也融到工具 Group 中。 ","link":"https://blog.rakuyoo.top/notes-of-nscollectionlayoutgroup/"},{"title":"NSCollectionLayoutSection 注意事项之 orthogonalScrollingBehavior","content":"本篇文章记录使用 NSCollectionLayoutSection 类的 orthogonalScrollingBehavior 属性的过程中遇到的问题。 通过设置该属性可以控制对应 Section 的滑动效果。 在阅读以下内容时，我将默认您已经掌握了 UICollectionViewCompositionalLayout 的基础用法，不再对一些细节进行补充说明。 Orthogonal Scroll View 这一节我们会涉及到两个系统的私有类型：_UICollectionViewOrthogonalScrollView 和 _UICollectionViewOrthogonalScrollerEmbeddedScrollView 因为这两个类型的名称太长，同时会多次重复提及，故下文使用 _UIOrthogonalScrollView 代替。 这两个类型可以看作是一个，早期 Apple 使用的是 _UICollectionViewOrthogonalScrollerEmbeddedScrollView 这个名称，后期在某个版本中改为 _UICollectionViewOrthogonalScrollView。 orthogonalScrollingBehavior 的默认值是 .none，当我们将其设置为其他值后，系统就会在 UICollectionView 上添加一层类型为 _UIOrthogonalScrollView 的 UIScrollView 子类作为 Cell 的父视图，如下图所示： 此时 Cell 的父视图不再是 UICollectionVIew。 我们测试过以下情况： UICollectionViewCompositionalLayout 只有一种布局。 NSCollectionLayoutGroup 的滑动方向和 UICollectionView 的滑动方向一致或不一致。 NSCollectionLayoutSection 的尺寸和 UICollectionView 相等或不相等。 在这三种情况下，只要修改了 orthogonalScrollingBehavior 属性，就会添加 _UIOrthogonalScrollView 视图。 在正式展开说明之前插一句：本文后面所提及的内容，都是在下面这个布局的基础上进行修改的： let itemSize = NSCollectionLayoutSize( widthDimension: .fractionalWidth(1/3), heightDimension: .absolute(50)) let item = NSCollectionLayoutItem(layoutSize: itemSize) let group = NSCollectionLayoutGroup.horizontal( layoutSize: .init( widthDimension: .fractionalWidth(1), heightDimension: .fractionalHeight(0.5)), subitems: [item]) let section = NSCollectionLayoutSection(group: group) return section 获取时机 那么该如何获取该视图呢，经过不完全测试，列表不包含任何 Cell 时，不会添加该视图。 该视图可在 viewDidLayoutSubviews 方法中通过遍历子视图获得。 /// `orthogonalScrollView` 可能的类型 /// /// 目前尚无法确定哪个版本的系统使用了哪个类型，所以为了稳妥起见，使用数组进行判断 private var orthogonalScrollViewTypes: [String] { [ &quot;_UICollectionViewOrthogonalScrollView&quot;, &quot;_UICollectionViewOrthogonalScrollerEmbeddedScrollView&quot; ] } var orthogonalScrollView: UIScrollView? { subviews.first { orthogonalScrollViewTypes.contains(&quot;\\(type(of: $0))&quot;) } as? UIScrollView } clipsToBounds _UIOrthogonalScrollView 的 clipsToBounds 属性默认是 false，这会导致一个问题： 如果您的 Section 设置了 contentInsets 之类的属性，导致比 UICollectionView 小，那么在滑动 _UIOrthogonalScrollView 的时候，其内容会超出 Section 的范围。 iOS 15 及以上 _UIOrthogonalScrollView 是严格跟着 Section 范围走的，例如下图： 蓝色选中的范围是 _UIOrthogonalScrollView，可以看到滑动的时候 Cell 明显超出了它的范围。 上文有提到获取 _UIOrthogonalScrollView 的时机，您可以在获取后通过手动将 clipsToBounds 设置为 ture 来解决该问题。 iOS 15 以下 经不完全测试，iOS 14.7.1 及以下版本符合该小节内容。iOS 14.7.1 - iOS 15 之间的版本没有经过测试，不确定符合上一小节还是该小节。 _UIOrthogonalScrollView 的范围是跟着 UICollectionView 走的，由下图所示： 和上一张图对比之后，可以很明显的发现区别（代码相同）。值得一提的是此时 _UIOrthogonalScrollView 的 contentInset 是 .zero 此时设置 clipsToBounds 就没有用了。 跟随滑动 如果您准备用 UICollectionViewCompositionalLayout 实现类似如上图的效果，那么您需要确保滑块是添加到 _UIOrthogonalScrollView 上。 考虑到该视图的获取时机，我建议您还是改用 UICollectionViewFlowLayout 实现。 .continuous 原本以为配合 UICollectionLayoutSectionOrthogonalScrollingBehavior.continuous，最终可以达到和 UICollectionViewCompositionalLayout 一样的效果，但是事实是并不会。 本文使用的例子里包含一个横滑的 group，item 的宽度是 group 的 1/3，group 的宽度和 UICollectionView 宽度一致。但是如果把 item 的宽度改为某个固定的值，例如 50，那么就会发现：屏幕上只会显示完整的 Cell。如下图所示： 右侧剩余的宽度不够第四个 Cell 显示出来，那么它就会隐藏掉，在后面再显示： 如果不修改 orthogonalScrollingBehavior（即值为 .none），则不会有该问题，但是 Cell 在超出屏幕后会换行展示，因为没有 _UIOrthogonalScrollView ... 所以建议这种需求还是使用 UICollectionViewFlowLayout 组合实现。 或者您知道什么更好的方式，请在评论区留言告诉我，谢谢。 ","link":"https://blog.rakuyoo.top/note-of-orthogonalscrollingbehavior/"},{"title":"fastlane match error: 503","content":"使用 match 命令更新开发证书的时候，遇到了 503 Service Temporarily Unavailable 的报错，搜到解决方案后想着还是记录一下吧。 本文转载自 Fastlane 503 Service Temporarily Unavailable 究其原因是因为 match 命令调用 Apple 服务太频繁/量过大，导致 503 服务暂时不可用。 此时可以使用下面的命令，清除 fastlane spaceship 的 cookie 来达到重制的目的： rm $HOME/.fastlane/spaceship/*/cookie 之后重新调用 fastlane match 命令即可。 ","link":"https://blog.rakuyoo.top/fastlane-match-error-503/"},{"title":"VPN 配置在 iOS 和 macOS 下的区别","content":"最近尝试使用 Mac Catalyst 将 App 移植到 macOS 上，打包时遇到了该问题，故记录一下。 在 .entitlements 文件中，需要使用 key com.apple.developer.networking.networkextension 来标记需要 VPN 权限。 但是这个 key 的值在 iOS 和 macOS 上是不同的： iOS：packet-tunnel-provider macOS：packet-tunnel-provider-systemextension 区别就在于 macOS 下多了 -systemextension 这部分，所以如果 App 提供 VPN 功能，那么 Mac Catalyst 和非 Mac Catalyst 的 Settings 就不能使用同一份 .entitlements 文件了。 ","link":"https://blog.rakuyoo.top/difference-between-vpn-entitlement-config-in-ios-and-macos/"},{"title":"Combine 操作符速查表","content":"文章以图文的形式，记录 Combine 中各操作符的用法以及效果。下文为原文章内容的转载 + 翻译。 本文转载自 Cheat sheet on s for iOS development 点击查看原文以更好的效果查看内容。 allSatisfy(_:) Publishes true if all elements match the condition. Publishes false &amp; completes if it receives an element that does not match the condition. 如果所有的元素都符合条件，则返回 true。如果收到一个不符合条件的元素，则返回 false 并完成信号。 append(_:) Appends the specified elements after the upstream publisher completes. 在上游发布者完成后添加指定的元素。 collect(_:) Collects up to the specified number of elements and emits them in an array. 收集多达指定数量的元素，并将它们发射到一个数组中。 combineLatest(_:) Publishes a tuple of the most recent element from multiple publishers when any of them emits a value. 当任何一个发布者发出一个值时，发布一个来自多个发布者的最新元素的元组。 compactMap(_:) Transforms each element with the provided closure and publishes any returned non-nil optional result. 用提供的闭包对每个元素进行转换，并公布任何返回的非零的可选结果。 contains(_:) Publishes true &amp; completes after receiving a matching value, or false when upstream publisher completes without producing a matching value. 在收到一个匹配的值后发布真值&amp;完成，或者在上游发布者完成后没有产生一个匹配的值时发布假值。 count() Publishes the count of all received elements when the upstream publisher completes. 当上游发布器完成时，发布所有收到的元素的计数。 dropFirst(_:) Omits a specified number of elements, then republishes all remaining elements. 省略指定数量的元素，然后重新发布所有剩余的元素。 drop(while:) Omits elements until a given closure returns false, then republishes all remaining elements. 省略元素，直到一个给定的闭包返回错误，然后重新发布所有剩余的元素。 filter(_:) Republishes all elements that match a provided closure. 重新发布所有符合所提供的闭包的元素。 first() Publishes the first element of the upstream publisher, then completes. 发布上游发布器的第一个元素，然后完成。 first(where:) Publishes the first element of a stream that satisfies a condition, then completes. 发布一个满足条件的流的第一个元素，然后完成。 flatMap(maxPublishers:_:) Transforms all elements from an upstream publisher into a new publisher. 将上游发布器中的所有元素转化为一个新的发布器。 ignoreOutput() Ignores all elements and passes along only the upstream publisher's completion state. 忽略所有元素，只传递上游发布者的完成状态。 last() Publishes the last element of the upstream publisher after it completes. 在上游发布器完成后，发布它的最后一个元素。 last(where:) Publishes the last element that satisfies a condition after the upstream publisher completes. 在上游发布器完成后，发布满足条件的最后一个元素。 map(_:) Transforms each element it receives from the upstream publisher with the provided closure. 用所提供的闭包对它从上游发布者那里收到的每个元素进行转换。 max() Publishes the maximum value received after the upstream publisher completes. 在上游发布者完成后，发布收到的最大值。 merge(with:) Publishes an element whenever any of the upstream publishers emits an element. 每当任何一个上游发布者发出一个元素，就发布一个元素。 min() Publishes the minimum value received after the upstream publisher completes. 发布上游发布者完成后收到的最小值。 output(at:) Republishes an element specified by its position, or completes if upstream publisher completes before the specified element. 重新发布一个由其位置指定的元素，如果上游发布者在指定的元素之前完成，则完成。 output(in:) Republishes elements specified by a range of positions. 重新发布由某个位置范围指定的元素。 prefix(_:) Republishes elements up to a specified maximum count. 重新发布元素，直到指定的最大数量。 prefix(while:) Emits values while elements meet the specified condition, otherwise it completes. 当元素满足指定的条件时发出数值，否则就会完成。 prepend(_:) Prepends elements with the specified values. 用指定的值对元素进行预置。 reduce(_:_:) Applies a closure to all elements and publishes a final result when the upstream publisher completes. 对所有元素应用一个闭包，并在上游发布器完成后发布一个最终结果。 removeDuplicates() Publishes an element only if it doesn't match the previous element. 只在一个元素与前一个元素不匹配时才发布。 replaceNil(with:) Replaces nil elements with the provided element. 用所提供的元素替换nil元素。 scan(_:_:) Transforms elements by applying a closure that receives its previous return value and the next element from the upstream publisher. 通过应用一个闭包来转换元素，该闭包从上游发布者那里接收其先前的返回值和下一个元素。 switchToLatest() Republishes elements sent by the most recently received publisher. 重新发布由最近收到的发布者发送的元素。 zip(_:) Waits until both publishers emit an element, then publishes the oldest unconsumed element from each one as a tuple. 等待，直到两个发布者都发出一个元素，然后将每个发布者中最古老的未被吸收的元素作为一个元组发布。 ","link":"https://blog.rakuyoo.top/cheatsheet-combine-operators/"},{"title":"GitLab-CI（三）：配置 GitLab-Runner","content":" 本文针对 GitLab-Runner 的配置进行讲解说明。 GitLab-CI 系列文章目前有三篇，主要讲解 GitLab-CI 的环境搭建与配置。本文为该系列的第三篇。 目录： GitLab-CI（一）：搭建 iOS CI 环境 GitLab-CI（二）：注册 GitLab-Runner GitLab-CI（三）：配置 GitLab-Runner config.tom 文件配置 在终端内输入 gitlab-runner list 命令，获取到 config.toml 文件路径，后续将针对该文件进行讲解说明。 concurrent 该文件顶部的 concurrent 字段意味着本台机器最多可以同时运行的作业数量。 请根据需求与 CI 机器的性能修改该字段。 例如 concurrent = 2 意味着 “该台电脑同一时间只能运行2个作业”。考虑到实际情况（一个作业对应一个打包任务），即同一时间内只能同时打2个包。 建议8g内存的机器将该值设置为2，以上内存的机器可将该值设置为4。 runners name 即注册 Runner 时填写的 description，可通过修改该值达到修改 Runner 名称的目的。 在下文介绍的描述中，也可修改。 在 GitLab - CI/CD 界面配置 找到群组/项目左侧导航栏最下方的设置按钮，依次选择 “设置（Settings） -&gt; CI/CD -&gt; Runners”，进入 Runner 设置页面。 找到需要编辑/配置的 Runner，点击右侧铅笔形状的 “编辑按钮”，进入编辑页面。 启用 通过勾选或取消勾选该选项，可开启/关闭该 Runner，被关闭的 Runner 将无法接收新的任务。 描述 即注册 Runner 时填写的 description，可通过修改该值达到修改 Runner 名称的目的。 最大作业超时 可设置任务超时时间。 超时时间有3种： Runner 处配置的超时时间，即此处配置的超时时间。优先级最高。 Git 项目的超时时间，可在 “设置（Settings） -&gt; CI/CD -&gt; 流水线通用设置” 处进行设置。优先级最低。 任务的超时时间，在具体的 .yml 文件中设置。优先级居中。 例如： Runner 配置了 2小时 超时 该 git 项目配置了 1小时 超时 所要执行的任务配置了 1.5小时 超时 则使用该 Runner 执行的任务的最终超时时间为 1.5 小时。 标签 可配置该 Runner 可接收的任务的标签。一个 Runner 可以设置多个标签，之间用 , 号进行分割。 只有当 Runner 的标签列表包含将要执行的任务的标签时，才会选择该 Runner 去执行这个任务。否则即使该 Runer 处于空闲状态，也不会被使用。 ","link":"https://blog.rakuyoo.top/gitlab-ci-config-runner/"},{"title":"GitLab-CI（二）：注册 GitLab-Runner","content":" 本文仅针对 macOS 和 Linux 平台，讲解如何注册 GitLab-Runner。Windows 平台不包含在本文介绍范围内。 GitLab-CI 系列文章目前有三篇，主要讲解 GitLab-CI 的环境搭建与配置。本文为该系列的第二篇。 目录： GitLab-CI（一）：搭建 iOS CI 环境 GitLab-CI（二）：注册 GitLab-Runner GitLab-CI（三）：配置 GitLab-Runner Runner 的分类 Runner 按照适用范围分为以下三类： 项目 Runner：仅某个项目可以使用该 Runner，其他项目不可使用。 群组 Runner：某个群组下的项目都可以使用该 Runner，其他群组下的项目不可使用。 共享 Runner：整个 GitLab 系统中的所有项目都可以使用该 Runner。 注册 Runner 前期准备 打开并登录 GitLab。 思考你需要注册哪种 Runner。 如果你需要注册第一种 “项目 Runner”，那么你需要打开某个具体的 git 项目。 如果你需要注册第二种 “群组 Runner”，那么你需要打开某个具体的群组。 找到左侧导航栏最下方的设置按钮，依次选择 “设置（Settings） -&gt; CI/CD -&gt; Runners”。 点击 Runner 右侧的 “展开” 按钮。 在展开内容的左侧，找到 “Set up a specific Runner manually” 中的内容。 后续将使用 “Set up a specific Runner manually” 中的内容注册 Runner。 注册 在终端中执行如下命令，开始注册流程： 注意： 如果是在 Linux 平台上注册，请使用 sudo 执行 register 命令，macOS 则直接执行下方命令即可。 gitlab-runner register 针对顶部黄色WARNING警告的说明请参考：顶部黄色WARNING警告。 1. 输入 GitLab URL 执行完命令后，首先要求输入 GitLab 的 url。填入你们 GitLab 的地址即可。 细心的你可能会注意到，“Set up a specific Runner manually” 中的 url 是 http，这里写的却是 https。 其实正确的应该是 https。如果你使用 http 进行注册，那么进行到最后你将收到 “认证失败” 的错误。 2. 输入 Token 这里的 token 来自 “前期准备” 一节中 “Set up a specific Runner manually” 里显示的 Token。 复制该 token 并贴入这里，按回车进入下一步。 3. 给 Runner 起一个名字 该值后续可进行修改，详见 配置 GitLab-Runner 第三步要求输入一个 description 描述，其实理解为 Runner 的名字会更好一点。 一般使用英文，例如 “sever_xxx_ios_project_spare”。 4. 设置 Runner 的标签 该值后续可进行修改，详见 配置 GitLab-Runner 标签列表（tag）决定着 Runner 可以执行哪些任务（job）。 在这一步您可以设置多个标签，之间使用 , 号分割即可。 一个清晰、简短并且可以表达 Runner 职责的标签名才是一个好的标签名。 针对 tag 的简单说明 上文有提到，Runner 首先会被项目、群组等范围限制着。 但是这样还不够，在下面这个现实场景中，就会有很多问题： 假设现在有一个“项目Runner”： 该 git 项目设置了多个CI/CD任务 该 git 项目内还注册了多个 Runner，甚至还有继承自群组的 Runner 此时如果你有特殊需求，需要任务A必须执行在RunnerA上，该如何做？ 这时我们就可以通过 “标签” 来做到这点，只需要确保RunnerA的标签包含任务A的标签即可。 只有当 Runner 的标签列表包含将要执行的任务的标签时，才会选择该 Runner 去执行这个任务。否则即使该 Runer 处于空闲状态，也不会被使用。 5. 无视这一步 直接按回车即可。 6. 选择执行器 当你输入正确的 url 和 token，那么你将最后一步：选择 Runner 的执行器： 在这一步输入你想选择的执行器的名称，输入回车即可完成 Runner 的注册。 有关执行器的详细说明，请参考 GitLab 的官方文档。这里重点说一下比较常用的两种执行器：shell 和 docker。 shell shell 执行器有以下几个特点： 当前任务在 本机的shell环境 下执行，意味着当前任务生成的文件将直接生成在本机路径内，不需要做任何外的配置，任务就可以访问本机中任意文件。 每个任务和每个任务之间没有隔离，意味着当前任务生成的文件，不需要任何额外配置，就能够被下个任务直接读取使用。 shell 执行器一般用于执行纯 shell 命令、脚本，同时对任务之间的隔离不敏感的任务。 iOS、macOS App 打包必须选择 shell 执行器，无法使用 docker 执行。 docker 简单地、按照本文作者的个人理解，解释一下 docker 是什么： docker 技术即容器技术，基于 docker 可以快速地配置好用户所需的开发环境，同时基于 docker，可以实现容器与容器之间的隔离。 当我们选择 docker 执行器后，下一步会让我们填写一个默认的 docker 镜像名称，该名称后续可更改。 Android 打包、上传 bugly 等操作均可使用 docker 执行器执行。 总结 iOS、macOS App 打包只能选择 shell。 不需要考虑任务与任务之间互相隔离的、轻量化的任务可以选择 shell。 需要复杂的开发环境，任务与任务之间需要互相隔离，或者较为繁杂的任务可以选择 docker。 顶部黄色WARNING警告 首先，如果是在 macOS 环境下，那么无视该警告即可； 如果是在 Linux 环境下，则是因为执行 gitlab-runner register 命令时没有添加 sudo 导致的，中断当前流程，重新执行 sudo gitlab-runner register 即可。 通过上文我们已经了解到，iOS 打包必须在 shell 环境下执行，打包过程中使用当前用户申请去执行相关 gitlab-runner 命令，所以在注册 runner 时，无法使用 sudo 执行。 GitLab-Runner 没有对此进行额外的判断，所以只要不加 sudo，就是 user-mode，就会输出该警告。 ","link":"https://blog.rakuyoo.top/gitlab-ci-register-runner/"},{"title":"GitLab-CI（一）：搭建 iOS CI 环境","content":" 本文档用于介绍如何搭建适用于构建 iOS 项目的 GitLab-CI 环境。 GitLab-CI 系列文章目前有三篇，主要讲解 GitLab-CI 的环境搭建与配置。本文为该系列的第一篇。 目录： GitLab-CI（一）：搭建 iOS CI 环境 GitLab-CI（二）：注册 GitLab-Runner GitLab-CI（三）：配置 GitLab-Runner macOS 构建 iOS 项目必须要基于 macOS 操作系统。 无法上云（因为公有云不支持 CPU 虚拟化），且目前没有提供的 macOS 服务器，故需要一台本地硬件来提供 CI/CD 服务。 最低要求 macOS 的系统版本要求符合开发所使用的 Xcode 所要求的最低系统版本。 因为一般来说，一个开发组内的系统版本保持一致，故 CI 机器的系统版本应当尽量保持一致。 可查阅 Apple 官方的 Xcode - 支持 文档，查看系统最低要求。 如果使用 Xcode 14.2 &amp; macOS 13 版本的系统进行开发，则 CI 机器最低应使用 macOS 12.5 版本。 翻墙 VPN 因为后续诸多步骤需要翻墙才能提高访问速度，甚至需要翻墙才能安装成功，所以建议先把翻墙VPN配置好。 开发环境 Xcode 在 macOS 上，Xcode 是大部分编程环境的基础；Xcode 包含例如 git 在内的一系列开发工具，所以第一步我们应当先下载 Xcode，之后再执行其他操作。 通过 Mac App Store 下载最新版本的 Xcode，或去官网下载对应版本的 Xcode。 如上所述，CI 机器上的 Xcode 版本应当与开发所使用的版本保持一致。 下载安装好 Xcode 之后，应当先打开一次 Xcode，完成后续流程，直至看到欢迎页面。 命令行工具 打开终端，输入以下命令，安装 Xcode 命令行工具： xcode-select --install 在弹出的弹窗内，选择安装，并根据提示完成后续安装即可。 Git 配置 安装 Xcode 的过程中，将自动安装 git 服务。此时您需要在命令行中进行一些额外的配置： git config --global user.name &quot;git账户名&quot; git config --global user.email &quot;注册git所用邮箱&quot; SSH 您需要配置 SSH，将本机的 SSH 添加到 GitLab 系统中。 首先进入 .ssh 目录： cd ~/.ssh # 如果该目录不存在，则需要您手动使用 mkdir ~/.ssh 进行创建 接着创建 ssh 文件： ssh-keygen -t rsa -C &quot;注册git所用邮箱&quot; 输入命令之后，连续敲击3个回车完成创建（请勿设置密码，否则可能导致一些问题） 最后，使用下列命令查看生成的公钥，并复制到 GitLab 中即可： cat id_rsa.pub 环境初始化 博主自己写了一个用于初始化环境的脚本： /bin/zsh -c &quot;$(curl -fsSL 以后的脚本路径)&quot; ci 在终端中，输入上述命令后，将安装如下服务： Homebrew（安装过程中需要用户手动选择国内镜像源） RVM，并确保 ruby 版本为 2.7.4 版本 Bundle Mint 在 ~ 目录下添加开机解锁密码（默认为 qazxsw2） 您可以 fork 该脚本后修改脚本内容，以安装适用于您自己的开发环境。 针对 Homebrew 的额外配置 执行初始化脚本时，可能出现如下报错： No remote 'origin' in ... fatal: not in a git directory Error 此时初始化脚本会被中断。我们可以执行 brew -v 命令查看提示，并按照提示执行如下命令： git config --global --add safe.directory homebrew-core路径 git config --global --add safe.directory homebrew-cask路径 git config --global --add safe.directory homebrew-services路径 将 homebrew-core、homebrew-cask 和 homebrew-services 的路径添加到 git config 中即可。 之后再重新执行初始化脚本即可。 内网 VPN 一般来说 GitLab 服务都安装在公司内网，需要连接内网才能进行访问。 您需要在这一步中根据您自身的情况，确保 CI 电脑可以顺利访问公司内网服务。 GitLab-Runner 整体安装、配置流程可参考 官方文档，本节内容仅作为补充说明使用。其内容与官方文档基本一致。 下载安装 因为官方使用的是亚马逊的 s3 服务器，在墙内下载会比较慢，建议开启翻墙 VPN 或在早上或者网络条件比较好的时候下载。 GitLab-Runner 作为 GitLab-CI 的基础，其版本应该和 GitLab 的版本有所对应，否则容易出现不匹配的情况。 14.8.1-jh 版本的 GitLab 可以使用 15.1.0 版本的 Runner。 在终端输入下面的链接下载安装包： 该安装包适用于 Intel 芯片的 Mac，如果是 M 系列芯片的 Mac，则需要将最后的 amd64 修改为 arm64。 sudo curl --output /usr/local/bin/gitlab-runner https://gitlab-runner-downloads.s3.amazonaws.com/v15.1.0/binaries/gitlab-runner-darwin-amd64 赋予权限 sudo chmod +x /usr/local/bin/gitlab-runner 在终端输入上述命令后，即可在终端内使用 gitlab-runner 命令。 注册 Runner 详细注册流程请参考 注册 GitLab-Runner 启动 Runner 首先打开终端，切换到当前登陆用户： su - &lt;username&gt; 接着安装 Runner 服务并启动： cd ~ gitlab-runner install gitlab-runner start 最后重启电脑即可完成 Runner 的安装。 可以在终端内输入 gitlab-runner list 命令，查看输出，并检查 config.toml 文件路径。 配置 Runner 请参考 配置 GitLab-Runner 文档中 concurrent 一节进行配置。 至此，这台电脑完成了 CI/CD 的相关配置。 ","link":"https://blog.rakuyoo.top/gitlab-ci-build-ios-environment/"},{"title":"Objective-C delegate 性能小优化","content":"之前也是对 delegate 怨念颇深——每次都需要检查 deleagte 并且检查是否响应了某个方法。不过那个时候的怨念是来自于 需要写那么一大段代码，而不是怨念性能。 过去的解决方法 当时的解决办法是写了这么一个 宏 ： #define MBCCheckDelegate(methodName) (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(methodName)]) 实际上写成 内联函数 也是可以的。不过到了这一步又开始有点犯懒了，所以一直没有继续。 优化 直到今天看到了 参考1 的这篇文章。文章中提到了可以缓存 respondsToSelector: 方法的结果，让我感慨原来还能这么做！ @protocol SomethingDelegate &lt;NSObject&gt; @optional - (void)something:(id)something didFinishLoadingItem:(id)item; - (void)something:(id)something didFailWithError:(NSError *)error; @end @interface Something : NSObject @property (nonatomic, weak) id &lt;SomethingDelegate&gt; delegate; @end @implementation Something { struct { unsigned int didFinishLoadingItem:1; unsigned int didFailWithError:1; } delegateRespondsTo; } @synthesize delegate; - (void)setDelegate:(id &lt;JSSomethingDelegate&gt;)aDelegate { if (delegate != aDelegate) { delegate = aDelegate; delegateRespondsTo.didFinishLoadingItem = [delegate respondsToSelector:@selector(something:didFinishLoadingItem:)]; delegateRespondsTo.didFailWithError = [delegate respondsToSelector:@selector(something:didFailWithError:)]; } } @end 如上所示，便是使用 结构体 来缓存结果。我们也可以使用其他的数据结构来达到我们的目的。 然后在实际通过 delegate 对象调用方法时，只需要判断对应的属性即可。 但是有一点需要留意，Objective-C 可以动态添加方法，所以设置时的情况未必能代表调用时的情况。具体要不要用这种方法还要考虑团队内的开发氛围。 简写的 delegate 在有 protocol 之前，一般是给 NSObject 加一个 category 来声明 delegate 可以实现的方法。比如，现如今 CALayer 还有： @interface NSObject(CALayerDelegate) - (void)displayLayer:(CALayer *)layer; // ... other methods here @end 意思是告诉编译器，任何对象都可以实现 displayLayer: 方法。 如果这样写的话，在调用方法之前也要同样要用上面提到的 -respondsToSelector: 来检查。只要让 delegate 对象实现这个方法，然后把它保存在 delegate 属性里就行了，不用写 protocol 什么的。 苹果官方的库里有不少这样的东西，但是新写的代码最好还是用上面声明 protocol 的正规写法。 因为这种简写方法会污染NSObject（会干扰代码自动补全），并且也让编译器不易检查出打错字之类的 error。 参考 [爆栈热门 iOS 问题——戴仓薯] 如何写好一个 delegate ","link":"https://blog.rakuyoo.top/objc-delegate-optimization/"},{"title":"C 与 Objective-C 中的枚举","content":"本文介绍 C 与 Objective-C 中的枚举，同时对 Objective-C 中的字符串枚举进行介绍 C语言中的枚举 C语言中也是有枚举的，或者说枚举正是从C语言中诞生的。在C语言中，枚举使用 enum 关键字声明，辅以 typedef。让我们来举个例子： typedef enum RKOEnumType { RKOEnumTypeNone = 0, RKOEnumTypeNormal, ... } RKOEnumType; 上面的代码便定义了一个枚举类型 RKOEnumType，使用它声明变量时我们可以这么使用： RKOEnumType type = RKOEnumTypeNone; 而用它进行判断时则是这样的： switch (type) { case RKOEnumTypeNone: // some code break; case RKOEnumTypeNormal: // some code break; ... } Objective-C 中的枚举 在 Objective-C 语言中，Foundaation 框架为我们封装了一套更方便的枚举定义方法。那便是 NS_ENUM 和 NS_OPTIONS。 NS_ENUM NS_ENUM 用来申明单选类型的枚举，即枚举变量中只可以有一种值。让我们来看一下栗子： typedef NS_ENUM(NSInteger, RKOEnumType) { RKOEnumTypeNone = 0, RKOEnumTypeNormal, ... }; 我们可以看到，这里用 NSInteger 声明了枚举变量的类型，即整数类型，其在使用时和 C语言 并无区别，依然使用 switch 语法用以区分每种不同的枚举变量。 NS_OPTIONS 除了 NS_ENUM 之后，Objective-C 还为我们封装了一套 NS_OPTIONS。有的时候单一的枚举值并不满足我们的需求，例如在如下场景时：我们希望设一个视图的可选转方向，它即可向左旋转，又可向右旋转。这时如果我们使用枚举来代表旋转方向的话，显然我们不应该设置一个枚举值为“既可向左又可向右”，我们依然定义一个 RKORotatTypeLeft 一个 RKORotatTypeRight，然后多选它们。那么我们该如何定义呢？下面来举个例子： typedef NS_OPTIONS(NSUInteger, RKORotatType) { RKORotatTypeRightNone = 0, // 2进制中的 0000 RKORotatTypeRight = 1 &lt;&lt; 0, // 值为2的0次方，二进制中的 0001 RKORotatTypeLeft = 1 &lt;&lt; 1, // 值为2的1次方，二进制中的 0010 ... }; 这样我们使用 NS_OPTIONS，结合位移操作，就定义了一个可以进行多选的枚举类型了。需要注意的是，NS_OPTIONS 使用的变量类型为 NSUInteger。而不是 NS_ENUM 的 NSInteger。 在对变量赋值时，我们使用 | 或运算符连接多个不同的枚举值，例如： RKORotatType type = RKORotatTypeRight | RKORotatTypeLeft; 判断 NS_OPTIONS 在对变量的判断上与 NS_ENUM 不同，因为变量中可以包含多个值，所以我们就不方便使用 switch 来进行判断了。 一般的，我们使用 if 来进行 NS_OPTIONS 类型的枚举的值判读，如下所示： // RKORotatTypeRight if (type &amp; RKORotatTypeRight) { // some code } // 包含 RKORotatTypeLeft if (type &amp; RKORotatTypeLeft) { // some code } 使用 if 判断，结合 &amp; 与运算符，我们即可判断变量中是否包含某个具体的枚举值，进而执行操作。 排除 有的时候，我们为了方便，有可能定义下面这样的一个选项枚举： typedef NS_OPTIONS(NSUInteger, RKORotatType) { RKORotatTypeRightNone = 0, RKORotatTypeRight = 1 &lt;&lt; 0, RKORotatTypeLeft = 1 &lt;&lt; 1, RKORotatTypeTop = 1 &lt;&lt; 2, RKORotatTypeBottom = 1 &lt;&lt; 3, RKORotatTypeAll = RKORotatTypeRight | RKORotatTypeLeft | RKORotatTypeTop | RKORotatTypeBottom, }; 这里我额外定义了一个枚举选项为 RKORotatTypeAll，代表所有的旋转类型。现在我们有可能有这么一个需求，点击某个按钮，或者执行了某个操作之后，要禁止这个视图向左旋转。 我们可以重新对 type 进行赋值，也可以像下面这样，将 RKORotatTypeLeft 从 type 中排除掉： type = type &amp; (~RKORotatTypeLeft); 将 RKORotatTypeLeft 取反后再与 type 进行与操作，即可从 type 中移除 RKORotatTypeLeft 选项。 C数组与字符串枚举 如上所述，c 与 Objective-C 的常见枚举都是 int 类型，如果我们需要一个字符串枚举呢？ 我们可以借助 c 数组来实现。首先定义一个常见的 Objective-C 枚举： typedef NS_ENUM(NSUInteger, KLType) { KLTypeRed = 1, KLTypeGreen = 2, KLTypeOrange = 3, }; 随后使用该 Objective-C 枚举作为下标，定义 c 数组： // 这个是 Map NSString * 类型的数组 NSString *KLTypeStringMap[] = { [KLTypeRed] = @&quot;红色&quot;, [KLTypeGreen] = @&quot;绿色&quot;, [KLTypeOrange] = @&quot;橘色&quot; }; // 使用： KLTypeStringMap[KLTypeRed]; 参考 iOS Enum-枚举的正确使用——Snow_xueY NS_OPTIONS枚举的用法——Channe OC中枚举写法 以及 字符串类型枚举实现探索 ","link":"https://blog.rakuyoo.top/enums-in-objc/"},{"title":"SQL 基础语句与 SQLite 基础操作","content":"这篇文章主要是围绕 SQLite，记录总结 SQL 的一些用法。 至于 iOS 中其余的几种存储方式例如 .plist 等，以及数据库的概念，SQL 的概念等，先不做介绍。 SQL 的特点 不区分大小写。 每条语句必须以分号 ; 结尾。 不可以使用关键字来命名表、字段。（关键字见下一小节） SQL 中的关键字 select 、 insert 、 update 、 delete 、 from 、 create 、 where 、 desc 、 order 、 by 、 group 、 table 、 alter 、 view 、 index etc. 注意，为了保持良好的数据库编程习惯，我们在编写 SQL 语句的时候，应当采用关键字大写的形式。 SQL 语句的种类 DDL 数据定义语句 数据定义语句 DDL 的全称是 Data Definition Language。 其包含 create 、 drop 等操作。create 即 创建表 (create table) 。drop 则是 删除表 （drop table）。 DML 数据操作语句 数据操作语句 DML 的全称是 Data Manipulation Language。 包括 insert 、 update 、 delete 等操作。 第一次接触的时候，只看这些关键词的话可以会误解 delete 为删除表的操作。实则不然，DML 全部都是对 数据 的操作，DDL 才是对于表的操作。 所以这里 insert 为在表中 添加 （插入）数据，update 为 修改 表中的数据，delete 为 删除 表中的数据。 DQL 数据查询语句 数据查询语句 DQL 的全称是 Data Query Language。用于查询并获得表中的数据。 关键字 select 是 DQL （也是所有 SQL ）用的最多的操作。 其他的 DQL 常用的关键字有 where 、order by 、 group by 、 having 等。 SQL基础操作 以下内容就是重点要记录的部分了。为了更加清晰的划分各个模块，以下内容将使用分割线来对各个模块进行划分。 创表 CREATE TABLE 表名 (字段名1 字段类型1, 字段名2 字段类型2, ...); 上面个这条语句是最基本的创表语句，create 关键字 和 table 关键字连用，用于创建一张表，用 () 英文括号将多个 字段名 和 字段类型 括起来。 一般的，我们不使用上面那条语句，为了更加的安全，我们使用 下面这种写法进行表的创建 ： CREATE TABLE IF NOT EXISTS 表名 (字段名1 字段类型1, 字段名2 字段类型2, ...); IF NOT EXISTS 用于判断所要创建的 表是否存在，如果不存在的话才会创建。 举个例子的话创建一张表的实际语句是这样的： CREATE TABLE IF NOT EXISTS t_student (id integer, name text, age inetger, score real); tip: 又一则良好的 SQL 编码习惯——在创建表时，表名前加上 t_ 来表明这是一张表，同理，创建视图时使用 v_ 来表明视图。 然而，当我们使用例如 Navicat Premium 等软件，在 GUI 中创建表，然后使用 DDL 查看该表的创表语法时，我们会看到如下的语句： CREATE TABLE &quot;t_shop&quot; ( &quot;name&quot; text, &quot;price&quot; real, &quot;left_count&quot; integer ); 表名和字段名都加了引号。我稍微查了一下，好像 oracle 是需要加引号的，好像和大小写有关。不过在 SQLite 中不加引号即可。毕竟 Navicat Premium 中集成了多种数据库，不是仅有 SQLite。 字段类型 SQLite 将数据划分为以下几种存储类型： 名称 含义 integer 整型值 real 浮点值 text 文本字符串 blob 二进制数据（比如文件） 然而呢，实际上 SQLite 是 无类型 的。就算我们将一个字段声明为 integer，还能可以存储类如 字符串之类的数据（注意，这里 主键除外）。 这也就意味着我们在建表的时候实际上是可以不声明类型的，只声明名称即可。但是为了保持良好的编程习惯，可可读性等等，我们还是应该声明类型的。 删表 删表的时候使用关键字 drop，和创表时一样，分为普通的写法和我们平时会用到的写法。这里就直接给出后者了： DROP TABLE IF EXISTS 表名; 举个例子： DROP TABLE IF EXISTS t_student; 插入数据 INSERT INTO 表名 (字段1, 字段2, ...) values (字段1的值, 字段2的值, ...); 提炼一下上述语法，即 insert into ... values ...。感觉还是很好理解的：插入到... 它的值是 ... 举例来说： INSERT INTO t_student (name, age) VALUE ('mj', 10); 注意： 在存储 字符串 时，我们应当使用 单引号 将其括起来。 在插入数据时，并不一定要每个字段都有值，即表名后面的那个括号，不必包含表中的所有字段。 更新数据 UPDATE 表名 SET 字段1 = 字段1的值, 字段2 = 字段2的值, ...; 上面便是更新数据的语法格式，但是如果仅仅是套用这个格式的话，例如下面这条语句： UPDATE t_student SET name = 'jack', age = 20; 这条语句将会将整张表的所有数据，name 字段的值都改为 jack，age 字段的值都改为20。 所以在使用的时候我们还要结合下一大节的条件语句进行使用。 删除数据 DELETE FROM 表名; 删除数据的一般语法也很简单，但是和更新数据一样。执行了上面的操作之后，整张表的所有数据都会被删除。所以也要结合条件语句进行使用。 条件语句 在 创表 和 删表 时，我们曾经使用过 if 这个关键词，可以理解为如果。但是这个 if 并不是条件判断语句的用词。 在条件判断语句中，我们使用 where 关键字，可以翻译为 当....时，初次接触时我很好奇，如果不使用 if 的话，为什么不用 when 呢？感觉这里可能更是为了突出 在某行记录 的这个概念吧。 条件语句的格式也很好记忆，即在需要条件判断的语句后面，跟上由 where 开头的条件判断语句即可。 格式 含义 WHERE 字段 = 某个值 字段的值是否等于某个值 WHERE 字段 != 某个值 字段的值是否不等于某个值 WHERE 字段 &gt; 某个值 字段的值是否大于某个值 WHERE 字段 &lt; 某个值 字段的值是否小于某个值 WHERE 字段1 = 某个值 AND 字段2 &gt; 某个值 关键字 AND 用于连接两个判断条件 WHERE 字段1 = 某个值 OR 字段2 &gt; 某个值 关键字 OR 用于连接两个判断条件 举例： -- 将 t_student 表中年龄大于10并且姓名不等于jack的记录，年龄都改为5。 UPDATE t_student SET age = 5 WHERE age &gt; 10 AND name != 'jack'; -- 删除 t_student 表中年龄小于等于 10 或者 年龄大于 30 的记录。 DELETE FROM t_student WHERE age &lt; 10 OR age &gt; 30; -- 将 t_student 表中名字等于 jack 的记录，score 字段的值都改为 age 字段的值。 UPDATE t_student SET score = age WHERE name = 'jack'; 特别注意：在 SQLite 中，等于 这个概念使用的是 单独的等号。和 Obj-C 以及其他大部分编程语言都不相同。 查询数据 查询操作使用关键字 select。格式为： SELECT 字段1, 字段2, ... FROM 表名; 如果我们想要查询整张表的数据，可以使用 * 号来代替字段名，即 SELECT * FROM 表名; 举个例子： SELECT name, age FROM t_student; SELECT * FROM t_student WHERE age &gt; 10; 别名 在进行查询操作时，我们可以为 字段 和 表 起一个 别名，从而我们我们查看或者进行某些操作。不过需要注意的是，别名 顾名思义，只是另外一个称呼，并不会修改字段本身的名称。 别名 使用关键字 as，不过该关键字是可以省略的，而且，这个别名可以使用 中文。其格式如下： -- 最基本的写法为： SELECT 字段1 AS 别名1, 字段2 AS 别名2, ... FROM 表名 AS 表别名; -- 当隐藏 AS 时 SELECT 字段1 别名1, 字段2 别名2, ... FROM 表名 表别名; 同时，如果我们为表起了一个 别名，那么我们在查询时就可以这么定义需要查询的字段： SELECT 表别名.字段1 别名1, 表别名.字段2 别名2, ... FROM 表名 表别名; 即用 表别名 后接 . 再接字段名的格式，用 表别名 来引用表中的字段。这样做的好处是，在使用如 Navicat Premium 时，可以提示该表有哪些字段，以防字段太多我们记不清楚。而且当多表联查时出现了字段名重名的问题的话，表别名 也是一个很好的解决办法。 举个例子： SELECT s.name 姓名, s.age 年龄 FROM t_student s; 计算记录的数量 在 SQL 中有这么一个函数 count() ，其作用为记录某个字段的数量。格式为： SELECT COUNT(字段名) FROM 表名; 不过一般来说，我们直接使用 * 号来代替字段名。即： SELECT COUNT(*) FROM 表名; 举个例子： SELECT COUNT(*) FROM t_student WHERE score &gt;= 60; 查询结果排序 我们可以使用关键字 order by 对查询结果进行排序，其格式为： SELECT 字段名 FROM 表名 ORDER BY 字段名 排序规则; 其默认是按照 asc ，即升序排列。我们可以显示的修改排序规则，改为 desc， 即降序排列。如果省略排序规则的话，则是默认的升序排列。 举个例子： -- 省略排序规则。(按照升序排列 SELECT * FROM t_student ORDER BY age; -- 降序排列 SELECT * FROM t_student ORDER BY age DESC; 同时我们还可以指定按照多个字段进行排序，例如下面这条语句： SELECT * FROM t_student ORDER BY age ASC, height DESC; 这条语句会将查询结果按照字段 age 升序排列，年龄相等的话就会按照字段 height 降序排列。 未完待续 ... ","link":"https://blog.rakuyoo.top/sql-basic-and-sqlite-basic/"},{"title":"去掉隐式动画","content":"实际上 iOS 好像是会在很多地方默认添加上动画的。这些动画倒也还好，但是有的时候就和需求不符就比较烦人了。 前几天偶然的再次查到了这个方法，于是决定开个文章记录一下。 感谢参考1，原作者的总结。本文基本引用自参考1。 说到隐式动画，之前在做手势控件的时候，对于 CALayer 的一些操作就会有隐式动画，例如说下面这行代码就会有隐式动画： self.frameLayer.frame = self.frameView.bounds; 这里介绍几种可以去掉系统动画的方法。如果您想隐藏的是 CALayer 相关的动画，请直接参考 方法三。 方法一 方法一是使用 UIView 类的类方法： performWithoutAnimation [UIView performWithoutAnimation:^{ // your code }]; 如果你的 App 需要最少支持到 iOS 7 。那么推荐你使用该方法。 方法二 该方法可行，但是实在是太蠢了，不建议使用 在你知道会产生动画的代码处，再次添加一个动画，只不过将这个动画的时间设为0： [UIView animateWithDuration:0 animations:^{ [collectionView performBatchUpdates:^{ [collectionView reloadItemsAtIndexPaths:@[[NSIndexPath indexPathForItem:index inSection:0]]]; } completion:nil]; }]; 方法三 方法四是针对 CALayer 的隐式动画的。这种情况下上面的三种方法是无效的，只能采用方法四： [CATransaction begin]; [CATransaction setDisableActions:YES]; // CALayer 动画 self.frameLayer.frame = self.frameView.bounds; [CATransaction commit]; 参考 iOS开发小技巧-如何去掉隐式动画——木头加白水 ","link":"https://blog.rakuyoo.top/remove-implicit-animation/"},{"title":"PushKit 的集成","content":"实际上项目中很早就由我提出要将现有的 APNs 更改为 PushKit 了。只不过当初后端的同学很忙，没有时间搞这个... 现在因为要接入 CallKit，所以这个不搞不行了。那么也来记录一下吧。 这篇文章中没有涉及到证书的申请，这块儿我还不太会，等到未来接触了会回过来补充的 流程 导入框架 Xcode设置 这里要区分一下 Xcode 的版本。如果你的版本是 Xcode 9 以前的版本，那么请按照如下步骤配置： 在 Xcode 中选中你的项目，切换到主 Target 下。 点击 capabilities 选项卡，找到 Background Modes 这一项。 勾选 Voice over IP 以及 Remote notifications 两项即可。 如果你的 Xcode 版本是 Xcode 9 及以上版本，那么很遗憾。苹果在 Background Modes 中移除了 Voice over IP 这一项，所以我们只能选择手动地在 info.plist 文件中进行配置： 我们可以选择 Open As Source Code 模型，然后添加如下代码： 我们也可以直接打开 info.plist 文件，然后在 Required background modes 中添加图中的这项。 最后我们在 Build Phases 的 Link Binary With Libraries 中添加 PushKit 的系统库，如下图所示： AppDelegate.m 首先我们在 AppDelegate.m 中导入头文件： #import &lt;PushKit/PushKit.h&gt; 其次我们还需要遵守 PKPushRegistryDelegate 协议。 注册推送 我们在 AppDelegate.m 文件中，编写如下方法： // 注册pushKit推送 - (void)registerPushKitNotification { if ([UIDevice currentDevice].systemVersion.floatValue &gt;= 8.0) { PKPushRegistry *pushRegistry = [[PKPushRegistry alloc] initWithQueue:dispatch_get_main_queue()]; pushRegistry.delegate = self; pushRegistry.desiredPushTypes = [NSSet setWithObject:PKPushTypeVoIP]; } } 注意： PushKit 的支持是需要 iOS 系统大于 8.0 的。 PKPushTypeVoIP 是一个 key 值，具体的会放在后面讲解。 之后我们在 application:didFinishLaunchingWithOptions: 方法中调用上述方法即可。 代理方法 pushRegistry:didUpdatePushCredentials: PKPushRegistryDelegate 协议中有一个必须要实现的代理方法： - (void)pushRegistry:(PKPushRegistry *)registry didUpdatePushCredentials:(PKPushCredentials *)pushCredentials forType:(PKPushType)type; 简单说一下，就是当收到一个指定的 PKPushType（这是一个枚举）类型的新的 credentials（凭证/证书）（包括 push token）时，就会调用这个方法。 在这个方法中，我们可以获取 token 值，然后将其缓存起来： - (void)pushRegistry:(PKPushRegistry *)registry didUpdatePushCredentials:(PKPushCredentials *)credentials forType:(NSString *)type { NSLog(@&quot;--- Token ---%@ ====%@&quot;, credentials.token, [credentials.token description]) NSString *deviceTokenStr = [[credentials.token description] stringByReplacingOccurrencesOfString:@&quot; &quot; withString:@&quot;&quot;]; deviceTokenStr = [deviceTokenStr stringByReplacingOccurrencesOfString:@&quot;&lt;&quot; withString:@&quot;&quot;]; deviceTokenStr = [deviceTokenStr stringByReplacingOccurrencesOfString:@&quot;&gt;&quot; withString:@&quot;&quot;]; NSUserDefaults *groupDefault = [[NSUserDefaults alloc] initWithSuiteName:GroupDefaultsName]; [groupDefault setValue:deviceTokenStr forKey:DeviceTokenKey]; [groupDefault synchronize]; } pushRegistry:didInvalidatePushTokenForType: 接着我们可以在 pushRegistry: didInvalidatePushTokenForType: 方法中清除 Token - (void)pushRegistry:(PKPushRegistry *)registry didInvalidatePushTokenForType:(PKPushType)type { NSUserDefaults *groupDefault = [[NSUserDefaults alloc] initWithSuiteName:GroupDefaultsName]; [groupDefault setValue:@&quot;&quot; forKey:DeviceTokenKey]; [groupDefault synchronize]; } pushRegistry:didReceiveIncomingPushWithPayload: 接下来的代理方法特别重要，那就是 pushRegistry:didReceiveIncomingPushWithPayload: 。这个方法不是必须实现，但是我们一般将业务逻辑写在该方法中。 一般我们可以在这个方法中执行 CallKit 相关的代码，或者结合本地推送进行操作。 - (void)pushRegistry:(PKPushRegistry *)registry didReceiveIncomingPushWithPayload:(PKPushPayload *)payload forType:(PKPushType)type { // your code } 参考 论养成一个好的习惯有多重要.....当初写这篇文章的时候居然忘记记录参考了，结果现在回过头来补充的时候找不到当初的参考了....如果您发现这篇文章引用了您的文章，请评论或者邮件告诉我，我会在这里引用上您的文章链接。谢谢！ ","link":"https://blog.rakuyoo.top/pushKit-integration/"},{"title":"从 Share Extension 跳转到 Containing App","content":"Share Extension 这篇文章就不多讲了。 单纯的说一下从前辈那里请教来的如何从 Share Extension 跳转到 Containing App 吧。 代码 NSURL *customURL = [NSURL URLWithString:@&quot;ShareKit://&quot;]; SEL sel = NSSelectorFromString(@&quot;openURL:&quot;); NSExtensionContext *context = [[NSExtensionContext alloc]init]; [context openURL:customURL completionHandler:nil]; UIResponder *responder = self; while (responder != nil){ if ([responder respondsToSelector:sel]) { [responder performSelector:sel withObject:customURL]; } responder = responder.nextResponder; } 原理 代码是从前辈那里请教过来的，原理就是利用 UIResponder 查找响应链。直接在 Extension 中调 openURL 方法是会闪退的，因为响应不了方法。 所以使用 UIResponder，从响应树上查找能够响应这个方法的对象，也就是 Safari，或者其他使用原生分享的 App。 用途 用途这块实际上也没必要多说，不过说一点，这个功能上架不会被拒，像是 QQ浏览器，微信， 支付宝 等等都有这种跳转的功能，不过 微信 的及其隐蔽。所以大家在使用中可能还是得把入口藏得深一些了。 ","link":"https://blog.rakuyoo.top/jump-from-share-extension-to-app/"},{"title":"Xcode9 快捷键","content":"开个贴记录一下 Xcode 9 下自己常用的几个发生了变化的快捷键。 快速跳转至定义 Xcode 9 下有这么一个新的功能，command + 鼠标左键 之后会弹出下图的这个菜单。 但是这里部分的功能很少用到，再加上之前已有的习惯，所以这个改动真的让人很难受。而且它提供的快捷键 control + command 有的时候还按不出来。 实际上这里有个新的快捷键： command + 鼠标右键 大家可以回去试一下，可以直接跳转到定义。 代码折叠 代码折叠的方式也改了，现在的快捷键是： 局部折叠（折叠一个函数） Command + Option + 方向键左/右 全局折叠（折叠当前文件下的全部函数） Shift + Command + Option + 方向键左 / 右 折叠注释块：（/* */之间的文字） Ctrl + Shift + Command + 方向键左 / 右 隐藏/显示左侧边栏 Command + 0 我的 macOS 版本是 macOS 10.12.6，在这个版本下，Xcode 9 不能做到两个项目分屏.... 不知道和系统或者 Xcode 版本有没有关系... 所以这里只能曲线救国一下，打开单个的代码文件，然后用这个文件和项目进行分屏。 但是这样所导致的问题就是，运行项目后，代码文件 那边左侧的边栏会显示出来，但是因为是单独的文件，所以没有右上角的快捷按钮... 所以这个小节介绍的快捷键就很重要了。 参考 Xcode 9 快速跳转到定义新姿势（Jump to Definition） Xcode 9 代码折叠，全局折叠，快捷键 ","link":"https://blog.rakuyoo.top/xcode9-shortcuts/"},{"title":"iOS 开发之适配 iOS11","content":"好了，现在 Xcode 9 的正式版终于推送了，那么我们也该适配 iOS 11了。 iOS 11的改动还是挺大的，这篇文章主要只是把自己遇到的问题记录下来，没有遇到的暂时先不会出现在文章内。等有时间的话会去网上找一找然后总结下来的。 NavigationBar TitleView 宽度 我的 App 中是有这么一个自定义的NavigationBar TitleView的，其宽度原本应该与屏幕宽度一致。在 iOS 10 以及 Xcode 8.3.3 上一切安然无恙。但是在 iOS 11 以及 Xcode 9 上就变成了下图所示的模样，挤到了一起。 我们查看层次结构可以发现，TitleView变得这么小了。 解决方法 我们先来看解决方法，再来说原因。 解决方法很简单，在自定义的 TitleView 的类中添加下面的代码，就ok了。 // 适配iOS11的NavigationBar Tiltle宽度。 - (CGSize)intrinsicContentSize { return UILayoutFittingExpandedSize; } 现在我们再运行程序，一切正常： 原因 通过参考1，里面有这么一句话： As an explanation: the titleView is now laid out with Auto Layout. Since it looks for the intrinsicContentSize, this is what worked. 我翻译不好就不翻译了，大概的意思好像就是现在 TitleView 会去寻找 intrinsicContentSize 这个属性，所以我们现在如果需要去重写一下这个属性的 get方法 。 然而这个属性是只读的，所以我们要么重写这个属性，然后给它赋值，要么重写 get方法 ，直接 return 。 更加详细的可以移步到参考1去查看。 右侧视图 今天测试妹子提了这么一个 bug，操作步骤简化一下是这样的： 点击页面（该页面 NavigationBar 包含一个自定义的 rightBarButtonItem ）中的一个 UISearchBar ，调用一个点击手势，push 到一个新的页面 newViewController。 newViewController 的 NavigationBar 的 titleView 是一个自定义的视图。其包含了一个 UISearchBar 和一个取消按钮。同时 NavigationBar 的左侧是没有返回按钮的。 理想的效果是，在进入 newViewController 的同时，其 NavigationBar 上的 UISearchBar 应该变成第一响应者并弹出键盘。 但是实际上，键盘是出现了一瞬间，然后就消失了。 解决方法 在点击手势的方法中，将 NavigationBar 的 rightBarButtonItem 置为 nil。然后在 viewWillAppear 中对 rightBarButtonItem 重新赋值。 注意：隐藏是无效的，必须置 nil 才可以。 原因 这个是什么原因我也不太清楚....找了一上午实在找不到，发现和 UISearchBar 以及控制器本身无关。和 NavigationBar（空白的）也无关。无奈只能挨个注释模块，最终找到了这个 rightBarButtonItem 的问题。 推测与 iOS 11 中 rightBarButtonItem 的占位有关。但是为何会导致键盘消失还是不太清楚.... TabaleView 切换时的滑动动画 在 iOS 11 上，push 进入 Table View 或者 pop 出 Table View 的时候，会有一个 自下而上 的滑动效果。 解决方法 将 Table View 的 contentInsetAdjustmentBehavior 属性设为 UIScrollViewContentInsetAdjustmentNever 即可。 注意：需要做版本判断。这个属性是从 iOS 11 开始才有的。 参考代码如下： if (@available(iOS 11.0, *)) { self.tableView.contentInsetAdjustmentBehavior = UIScrollViewContentInsetAdjustmentNever; self.tableView.contentInset = UIEdgeInsetsMake(0, 0, [[UIScreen mainScreen] bounds].size.height == 812 ? 83 : 49, 0); self.tableView.scrollIndicatorInsets = _tableView.contentInset; } 原因 这个效果实际上不是 Table View 的。而是 Scroll View 的，详情见下面的 Scroll View 小节。 ScrollView Scroll View在 iOS 11 新增的两个属性：adjustContentInset 和 contentInsetAdjustmentBehavior。 adjustContentInset 表示 contentView.frame.origin 偏移了scrollview.frame.origin 多少；是系统计算得来的，计算方式由 contentInsetAdjustmentBehavior 决定。 contentInsetAdjustmentBehavior 是个结构体，具体如下： typedef NS_ENUM(NSInteger, UIScrollViewContentInsetAdjustmentBehavior) { UIScrollViewContentInsetAdjustmentAutomatic, UIScrollViewContentInsetAdjustmentScrollableAxes, UIScrollViewContentInsetAdjustmentNever, UIScrollViewContentInsetAdjustmentAlways, } 每一种分别代表着一种计算方式： UIScrollViewContentInsetAdjustmentAutomatic：如果 Scroll View 在一个 automaticallyAdjustsScrollViewContentInset = YES 的 控制器 上，并且这个 控制器 包含在一个 Navigation Controller 中，这种情况下会设置在 top &amp; bottom 上 adjustedContentInset = safeAreaInset + contentInset 不管是否滚动。其他情况下与第二个的 UIScrollViewContentInsetAdjustmentScrollableAxes 相同。 UIScrollViewContentInsetAdjustmentScrollableAxes：在可滚动方向上 adjustedContentInset = safeAreaInset + contentInset ，在不可滚动方向上 adjustedContentInset = contentInset ；依赖于 Scroll Enabled 和alwaysBounceHorizontal / vertical = YES，scrollEnabled 默认为 yes，所以大多数情况下，计算方式还是 adjustedContentInset = safeAreaInset + contentInset UIScrollViewContentInsetAdjustmentNever：adjustedContentInset = contentInset。 adjustContentInset 值不受 SafeAreaInset 值的影响。 UIScrollViewContentInsetAdjustmentAlways： adjustedContentInset = safeAreaInset + contentInset 权限 保存图片 在 iOS 11 中，如果你使用 XCode 9 及以上版本打包。那么在保存图片的时候，可能会遇到下面这个崩溃： This app has crashed because it attempted to access privacy-sensitive data without a usage description. The app's Info.plist must contain an NSPhotoLibraryAddUsageDescription key with a string value explaining to the user how the app uses this data. 解决方法 我们可以用 Source Code 的方式打开 info.plist 文件 输入下面的代码： &lt;key&gt;NSPhotoLibraryAddUsageDescription&lt;/key&gt; &lt;string&gt;App需要您的同意,才能保存图片&lt;/string&gt; 又或者选择 Property List 方法，在 App Transport Security Settings 项中点击加号，添加 Photo Library Additions Usage Description 字段。Type 选择 String，然后在 Value 中添加提示语。 原因 这个崩溃的原因是因为，在 iOS 11 中，保存图片也像调用相机一样，需要获取权限了。 参考 iOS 11 navigationItem.titleView Width Not Set 你可能需要为你的APP适配iOS11 iOS 11中APP中tableView内容下移20pt或下移64pt的问题适配的一个总结 iOS 11 NSPhotoLibraryAddUsageDescription 错误的解决办法 ","link":"https://blog.rakuyoo.top/available-for-ios11/"},{"title":"Objective-C 中的 nullable、__nullable 和 _Nullable","content":"这次的内容是关于 nullable、__nullable 和 _Nullable 的。对于我们这样的初学者，在看第三方框架或者官方文档的时候经常会看到这样的字样。然而平时也没有去研究它到底是什么，这次就来好好记录一下一下吧。 本次的内容转载自参考1，感觉原作者的分享与贡献。 前言 在 Swift 中，我们会使用 ? 和 ! 去显式声明一个对象或者方法的参数是 optional 还是 non-optional ，而在 Objective-C 中则没有这一区分，这样就会带来一个问题：在 Swift 与 Objective-C 混编时，Swift 编译器并不知道一个 Objective-C 对象或者一个方法的参数到底是 optional 还是 non-optional ，因此这种情况下编译器会隐式地都当成是 non-optional 来处理，这显然是不太好的。 解决方案 为了解决这个问题，苹果在 Xcode 6.3 引入了一个 Objective-C 的新特性： Nullability Annotations ，这一新特性的核心是两个新的类型修饰： __nullable 和 __nonnull 。从字面上我们可知， __nullable 表示对象可以是 NULL 或 nil，而 __nonnull 表示对象不应该为空。当我们不遵循这一规则时，编译器就会给出警告。 在 Xcode 7 中，为了避免与第三方库潜在的冲突，苹果把 __nonnull/__nullable 改成 _Nonnull/_Nullable 。再加上苹果同样支持了没有下划线的写法 nonnull/nullable ，于是就造成现在有三种写法这样混乱的局面。 但是这三种写法本质上都是互通的，只是放的位置不同，举例如下： 方法返回值修饰： - (nullable NSString *)method; - (NSString* __nullable)method; - (NSString* _Nullable)method; 声明属性的修饰： @property (nonatomic, copy, nullable) NSString *aString; @property (nonatomic, copy) NSString *__nullable aString; @property (nonatomic, copy) NSString *_Nullable aString; 方法参数修饰： - (void)methodWithString:(nullable NSString*)aString; - (void)methodWithString:(NSString * _Nullable)aString; - (void)methodWithString:(NSString * __nullable)aString; 而对于 双指针类型对象 、 Block 的返回值 、 Block 的参数 等，这时候就不能用 nonnull/nullable 修饰，只能用带下划线的 __nonnull/__nullable 或者 _Nonnull/_Nullable ： - (void)methodWithError:(NSError* _Nullable * _Nullable)error - (void)methodWithError:(NSError* __nullable* __null_unspecified)error; // 以及其他的组合方式 - (void)methodWithBlock:(nullable void(^)())block; // 注意上面的 nullable 用于修饰方法传入的参数 Block 可以为空，而不是修饰 Block 返回值； - (void)methodWithBlock:(void(^ _Nullable)())block; - (void)methodWithBlock:(void(^ __nullable)())block; - (void)methodWithBlock:(nullable id __nonnull(^)(id __nullable params))block; // 注意上面的 nullable 用于修饰方法传入的参数 Block 可以为空，而 __nonnull 用于修饰 Block 返回值 id 不能为空； - (void)methodWithBlock:(id __nonnull(^ __nullable)(id __nullable params))block; - (void)methodWithBlock:(id _Nonnull (^ _Nullable)(id _Nullable params))block; // the method accepts a nullable block that returns a nonnull value // there are some more combinations here, you get the idea 使用规范 在看了原生 iOS SDK 里 Foundation 和 UIKit 的头文件以及苹果的博文 《Nullability and Objective-C》 ，我们总结如下使用规范： 对于属性、方法返回值、方法参数的修饰，使用： nonnull/nullable； 对于 C 函数的参数、Block的参数、Block返回值的修饰，使用： _Nonnull/_Nullable， 建议弃用 __nonnull/__nullable 。 Nonnull Audited Regions 如果需要每个属性或每个方法都去指定 nonnull 和 nullable ，将是一件非常繁琐的事。 苹果为了减轻我们的工作量，专门提供了两个宏： NS_ASSUME_NONNULL_BEGIN 和 NS_ASSUME_NONNULL_END 。在这两个宏之间的代码，所有简单指针对象都被假定为 nonnull ，因此我们只需要去指定那些 nullable 指针对象即可。如下代码所示： NS_ASSUME_NONNULL_BEGIN @interface myClass() @property (nonatomic, copy)NSString *aString; - (id)methodWithString:(nullable NSString*)str; @end NS_ASSUME_NONNULL_END 在上面的代码中， aString 属性默认是 nonnull 的， methodWithString:方法的返回值也是 nonnull ，而方法的参数 str 被显式指定为 nullable 。 不过，为了安全起见，苹果还制定了以下几条规则： 通过 typedef 定义的类型的 nullability 特性通常依赖于上下文，即使是在 Audited Regions 中，也不能假定它为 nonnull； 对于复杂的指针类型（如 id * ）必须显式去指定是 nonnull 还是 nullable。例如，指定一个指向 nullable 对象的 nonnull 指针，可以使用 __nullable id * __nonnull ； 我们经常使用的 NSError ** 通常是被假定为一个指向 nullable NSError 对象的 nullable 指针 疑问 虽然在 Xcode 7 里面，苹果建议我们放弃使用 __nonnull/__nullable ，改用 _Nonnull/_Nullable 来修饰对象可否为空，但即使是在最新 ios 9.3 SDK 的 Foundation 和 UIKit 的头文件里我们可以看到官方原生类的方法参数仍然在用 __nonnull/__nullable 修饰。 另外为什么已经有了 nonnull/nullable ，为什么还要增加 _Nonnull/_Nullable ？这到底是出于什么考虑？苹果在它的博文 《Nullability and Objective-C》 中也没有具体解释，于是 StackOverflow 上有个关于此问题的讨论： Difference between nullable, __nullable and _Nullable in Objective-C 。 参考 nullable、__nullable、_Nullable 究竟有什么区别呢？——bravegogo 注意：上面的blog标准该博文未转帖，然而并没有标注原帖地址，故只能在此放出转帖地址。 ","link":"https://blog.rakuyoo.top/nullable-of-objc/"},{"title":"Objective-C 之 Block 基础用法","content":"这两天改bug改的太忙了....实际上该整理的知识点挺多的，今天就先说一下 Block 吧。 本篇文章中大量内容参考、转载自文章末尾的参考1，感谢原作者的总结与分享。原文中还有更多更详细的内容，欢迎大家点击原文学习更多内容。 什么是Block 让我们先简单的介绍一下Block 代码块Block是苹果在iOS4开始引入的对C语言的扩展,用来实现匿名函数的特性，Block是一种特殊的数据类型，其可以正常定义变量、作为参数、作为返回值，特殊地，Block还可以保存一段代码，在需要的时候调用，目前Block已经广泛应用于iOS开发中，常用于GCD、动画、排序及各类回调。 综上我们可以得知： Block是一种数据类型。 Block可以做变量，也可以做参数，还可以做为返回值，甚至用来保存一段代码。 Block变量 Block的声明 Block的声明格式为：返回值(^Block名称)(参数列表)，让我们来举个栗子: NSString *(^aBlock)(NSString *str, NSArray *arr); 如上是一个返回值为NSString，名称为aBlock，拥有2个参数，分别为NSString和NSArray的一个Block代码块。 注意： 其中形参的形参名，即栗子中的str和arr可以省略不记。 这里的名称我们便可以将它想象成函数名。 给Block变量赋值 我们声明完Block之后，就该给变量赋值了。 这种情况下的格式为：变量名 = ^返回值类型(参数类型){函数体}。举个栗子： aBlock = ^NSString *((NSString *str, NSArray *arr) { NSLog(@&quot;%@, %@&quot;, str, arr); return str; }; 这里实际上我们是把一个函数体赋值给了Block变量。从这里我们也可以看出来Block的一个重要用法，那就是用来存储函数体。 注意： 这里的返回值类型可以不用声明，直接省略。因为编译器可以从存储代码块的变量中确定返回值的类型。 如果没有参数列表，在赋值的时候可以省略。 声明的同时赋值 把上面两点综合起来就就可以了，这里直接给个栗子吧。 NSString *(^aBlock)(NSString *, NSArray *) = ^(NSString *str, NSArray *arr) { NSLog(@&quot;%@, %@&quot;, str, arr); return str; }; 调用Block变量 Block变量的调用实际上和C语言函数的调用非常接近。为了节省时间，这里的参数str1和arr我只进行了初始化，没有赋值。 NSString *str1 = [[NSString alloc] init]; NSArray *arr = [NSArray array]; NSString *str = aBlock(str1, arr); NSLog(@&quot;%@&quot;,aBlock(str1, arr)); 是不是和C语言很像呢。 使用typedef定义Block类型 在实际使用Block的过程中,我们可能需要重复地声明多个相同返回值相同参数列表的Block变量,如果总是重复地编写一长串代码来声明变量会非常繁琐,所以我们可以使用typedef来定义Block类型。 // 定义一种无返回值无参数列表的Block类型 typedef void(^SayHello)(); // 我们可以像OC中声明变量一样使用Block类型SayHello来声明变量 SayHello hello = ^() { NSLog(@&quot;hello&quot;); }; // 调用后控制台输出&quot;hello&quot; hello(); 注意，在使用typedef的时候，(^)内的Block名已经被当做了整个Block类型的名称，而不单单是一个Block的名称。 在函数形参中使用Block 形参使用Block时函数的声明 Block作为函数形参是一个很重要的用法， 很多知名的第三方库或者网络请求中都会在函数的形参中用到Block。我们自己写代码的时候，偶尔为了方便高效，或者为了封装，也可以使用Block。 其格式为：-（返回值）函数名称：（Block返回类型（^）（参数列表））函数参数名 注意： 为了看起来清晰，在上面的格式中，我使用的都是中文标点，实际使用中肯定都要是英文标点的。 在作为形参使用时，将Block写在函数定义/声明的形参位置时，Block没有Block名称。 下面是我自己的在一个项目中定义的一个函数，就使用到了Block作为形参。在这里大家理解这种声明的格式即可。 - (void)autoresizingMaskOfChildView:(NSMutableArray&lt;NSNumber *&gt; *(^)())autoMaskArr { NSMutableArray *tempArrM = [NSMutableArray arrayWithArray:autoMaskArr()]; } 上面定义了一个返回值为空void，名称为autoresizingMaskOfChildView，拥有一个Block参数的函数。 其中Block参数是一个返回值为存储NSNumber的NSMutableArray，没有参数列表。 调用形参使用Block的函数 没有参数的Block形参 上面那个栗子中的函数，其调用的时候会是这样的： [self.view autoresizingMaskOfChildView:^NSMutableArray&lt;NSNumber *&gt; *{ &lt;#code#&gt; }]; 我们在&lt;#code#&gt;中输入自己的代码，这一部分的代码相当于是赋值给了Block形参。 有参数的Block形参 我们先定义一个函数，方法中定义了一个block数据类型参数（返回值为int类型的，且带有一个int类型的形参） - (void)calculate:(int (^)(int)) calculateBlock { //calculateBlock接受外界传入的代码块，也就意味着怎么去操作是由外界调用者决定的 self.result = calculateBlock(_result);//将_result的值作为实参传入 } 外部控制器调用时如下所示： [manager calculate:^int(int i) { //参数i自加1，然后返回 i++; return i; }]; NSLog(@&quot;%d&quot;,manager.result); //输出结果为1 通过最后的NSLog输出我们可以看到，在外界调用Block的时候，参数i的值被传给了函数定义时的参数_result。相当于_result = i。 即是外界提供值，然后赋值给Block内部的变量。而不是从Block中将值传给外界。 注意：上面这种写法实际上有很大问题，我们在这个函数声明的时候，没有说这个blcok是不能为空的，那么假如外界在调用这个block的时候，如果给block参数的位置传的是nil，而函数内部又给这个block传了参数，那么就会有产生Crach。 例如下面这样： [manager calculate:nil]; calculate:函数内部不变，依然是这样： - (void)calculate:(int (^)(int)) calculateBlock { self.result = calculateBlock(_result); } 这样就会导致Crach，所以我们在使用Block之前要对Block做判空处理。 - (void)calculate:(int (^)(int)) calculateBlock { if (!calculateBlock) { self.result = calculateBlock(_result); } } 使用typedef简化Block // 1.使用typedef定义Block类型 typedef int(^MyBlock)(int, int); // 2.定义一个形参为Block的OC函数 - (void)useBlockForOC:(MyBlock)aBlock { NSLog(@&quot;result = %d&quot;, aBlock(300,200)); } // 3.声明并赋值定义一个Block变量 MyBlock addBlock = ^(int x, int y){ return x+y; }; // 4.以Block作为函数参数,把Block像对象一样传递 [self useBlockForOC:addBlock]; // 将第3点和第4点合并一起,以内联定义的Block作为函数参数 [self useBlockForOC:^(int x, int y){ return x+y; }]; Objective-C 中的block属性 说完了形参与变量，那么在 Objective-C 的属性中该如何使用 block 语法呢？ 定义 block 类型 首先我们应该定义一个 block 类型： // 在#import 与 @interface 之间声明该 block 类型 typedef void(^ButtonEventsBlock)(UIButton *btn); 这样我们就定义了一个返回值为空，名称为 ButtonEventsBlock，带有一个 UIButton 类型参数的 block 类型了。 声明 block 属性 这一步很简单，就如同声明其他变量一样，使用之前定义好的 block 类型声明一个变量即可。 @property (nonatomic, copy) ButtonEventsBlock buttonEventsBlock; 对 block 属性赋值 这里我将演示两种方法：懒加载 与 Runtime。 懒加载 在代码中为 block 属性赋值和使用 懒加载 对 block 赋值在语法层面没有太大的差异，所以这里就只演示懒加载了。 那么让我们直接砍代码吧： - (ButtonEventsBlock)buttonEventsBlock { if (!_buttonEventsBlock) { _buttonEventsBlock = ^(UIButton *btn) { // your code }; } return _buttonEventsBlock; } 我们可以看到，在语法层面上，除了为 block 赋值的那部分外，其余部分与一般的懒加载并无差异。而为 block 赋值的那部分代码我们之前也已经提到过了。 Runtime 如果我们要在分类中使用 block 属性的话，我们就要借住 Runtime 来实现了。因为 Category 中并不会为我们自动生成成员变量。 那么我们代码长什么样子呢？ static void *buttonEventsBlockKey = &amp;buttonEventsBlockKey; - (ButtonEventsBlock)buttonEventsBlock { return objc_getAssociatedObject(self, &amp;buttonEventsBlockKey); } - (void)setMbc_buttonEventsBlock:(ButtonEventsBlock)buttonEventsBlock { objc_setAssociatedObject(self, &amp;buttonEventsBlockKey, buttonEventsBlockKey, OBJC_ASSOCIATION_COPY); } 哈，这里又和一般的在 Category 中使用属性的语法没有什么区别了。只不过，这里我们就没有办法使用懒加载为其赋值了，如果需要默认操作的话，我们只能在代码中对其赋值了。 参考 一篇文章看懂iOS代码块Block——蚊香酱 iOS开发：Block作为参数使用（常见于各框架）——夏鲁鲁 ","link":"https://blog.rakuyoo.top/objc-block-basic-usage/"},{"title":"Objective-C 中 id 和 instancetype 的使用与异同","content":"今天记录一下在Objective-C中，保留字id和instancetype各自的用法，以及异同。 id 什么是id类型 在概念上，id类似于Java中的Object类，可以转换为任何数据类型。换句话说，id类型的变量可以存放任何数据类型的对象。在内部处理上，这种类型被定义为指向对象的指针，实际上是一个指向这种对象的实例变量的指针。 下面是id类型在Objective-C中的定义: typedef struct objc_object { Class isa; } *id; 从上面看出，id是指向struct objc_object的一个指针。也就是说，id是一个指向任何一个继承了Object（或者NSObject）类的对象。 id的用法 id是一个指针 因为id类型是一个指针，所以我们在使用id类型的时候不需要添加任何的星号，例如: id foo = nil; 上面的代码声明了一个id类型的指针foo，这个指针指向NSObject的任意一个子类。 而下面的代码则定义了一个指针，这个指针指向另一个指针，被指向的这个指针指向NSObject的一个子类。 id *foo = nil; 可以接收任何消息 在ObjeciveC中，id是可以接收任何消息的，所以我们可以将一个方法或者一个变量声明为id类型，用来接收多种类型的数据。 例如NSArray中即可以接收NSString，也可以是NSObject，这时候就需要用id了。 小结 在我的理解看来，id类型就是一个万能的类型，当我们暂时不知道方法的返回值该是什么类型的时候，我们可以先尝试将方法定义为id类型，等待确定方法返回值后再回来修改，或者就直接定义为id类型罢了。 或者我们可以定义一个id类型的变量，用它来做中间变量，用来接收多种类型的数据。 关联返回类型 在介绍instancetype之前先讲解一个概念，就是关联返回类型的方法。 根据Cocoa的命名规则，满足下述规则的方法： 类方法中，以alloc或new开头 实例方法中，以autorelease，init，retain或self开头 会返回一个方法所在类 类型 的变量，这里我用空格和加粗断句，方便大家理解。也就是说，这些方法的返回值的类型，是调用这些方法的那个类的类型。NSArray调用的alloc方法，即[NSArray alloc]。那么这个方法的返回值就是NSArray类型的。同理[[NSArray alloc] init]返回的也是NSArray类型的值。 那么说回来，以上这些的方法呢，我们就称之为关联返回类型的方法。 instancetype 什么是instancetype类型 instancetype是从 clang 3.5 开始提供的一个关键字，表示某个方法返回的未知类型的Objective-C对象。单看这个定义，感觉和id还是挺像的。 instancetype的作用 当我们有一个自定义的方法，例如下面这个: @interface UIView (TestView) + (id) testFounation; @end TestView类是UIView类的分类，当我们如下调用testFounation方法时 [TestView testFounation]; 其返回值的类型和方法的声明相同，是id类型。 而如果我们如下使用instancetype声明testFounation的话 @interface UIView (TestView) + (instancetype) testFounation; @end 当我们再次调用testFounation方法: [TestView testFounation]; 其返回值的类型会是TestView类型。 小结 综上我们可以看出，instancetype的作用实际上就是使非关联返回类型的方法返回所在类的类型。 通俗的讲，就是当我们需要方法的返回类型不是未知的id类型，而是具体的，调用该方法的类的类型的时候，我们要使用instancetype类型。 再具体一些，当我们自定义init方法的时候，其返回值就是instancetype类型。 id和instancetype的异同 总结下来，id和instancetype的异同一共有以下几点: 相同之处 其都可以作为方法的返回类型。 不同之处 instancetype可以返回和方法所在类相同类型的对象，id只能返回未知类型的对象。 instancetype只能作为返回值，不能像id那样作为参数。instancetype只适用于初始化方法和便利构造器的返回值类型。 在不同的内存管理机制中: 在ARC(Auto Reference Count)环境下:instancetype用来在编译期确定实例的类型,而使用id的话,编译器不检查类型, 运行时检查类型。 在MRC(Manual Reference Count)环境下:instancetype和id一样,不做具体类型检查。 关于第三点，因为我现在还没有具体学习到内存管理相关的知识，可以参考下方参考中三木成森的文章，有举例说明该点。 参考 Objective-C中的id类型——Kilnn 理解Objective C 中id——做个不善的人 OC中instancetype与id的区别——三木成森 Objective-C中的instancetype和id区别——kuizhang1 ","link":"https://blog.rakuyoo.top/use-of-id-and-instancetype/"},{"title":"C语言的变量类型","content":"c语言复习之路，之一 变量类型 变量的存储类型 C语言根据变量的存储类型的不同，可以把变量分为:自动变量、静态变量、寄存器变量。 自动变量 定义：自动变量是存储在堆栈中的。 所有局部变量默认情况下都是自动变量。 声明周期：自动变量随所在代码块被执行而创建，随所在代码块执行结束而销毁。如果函数被重复调用，自动变量会被重复创建、销毁。 静态变量 定义：静态变量存储于静态内存中，也就是不属于堆栈。 哪些是静态变量: 所有的全局变量都是静态变量。 被关键字static修饰的局部变量也是静态变量。 声明周期:静态变量在程序运行之前被创建，始终存在。 寄存器变量 定义:存储在硬件寄存器中的变量，称为寄存器变量。 哪些变量是寄存器变量: 被关键字register修饰的自动变量都是寄存器变量。 只有自动变量才可以是寄存器变量，静态变量(全局变量)不行。 寄存器变量只限于int、char和指针类型使用。 生命周期:调用该函数时占用寄存器中存放的值，当函数结束时释放寄存器，变量消失。 使用注意: 不能过多使用。如果寄存器使用饱和时，程序将寄存器变量自动转换为自动变量处理。 为了提高运算速度，一般会将一些频繁使用的自动变量定义为寄存器变量，这样程序尽可能地为它分配寄存器存放，而不用内存。 register int a; // a就是一个寄存器变量 参考 【C语言】18-变量类型——M了个J ","link":"https://blog.rakuyoo.top/variable-types-in-c/"},{"title":"Git 基本操作总结","content":"总结一下 Mac 下 Git 的一些基本操作。 本文其实是把之前给大一学生讲 Git 时备课的稿子拿过来，整理修改，二次加工后的产物。 文章风格偏向于“备忘录”，而不是“教程”。部分地方说的不够清晰还请读者见谅。 至于Git的初学者可以拉到文章最下面，到廖雪峰大神的blog去学习。 概览 首先放一个后文涉及到的命令的总结，方便快速查找。 指令 作用 ssh-keygen -t rsa -C &quot;your-email@emial.com&quot; 新建 SSH ssh -T git@&lt;git url&gt; 检查本地和远端的 SSH 连通性 git add xx.txt 添加某一文件到缓存区 git add . 添加所有文件到缓存区 git commit -m&quot;注释信息&quot; 提交修改到工作区 git status 查看Git仓库状态 git diff 查看文件与之前有何不同 git reset --hard HEAD^ 返回到上一个版本 git reset --hard HEAD~10 向前回滚10个版本 git reset --hard commit ID值 回滚到某个具体的版本 git log --pretty=oneline 输出commit日志，包含作者，日期，提交说明，提交ID git reflog 输出所有的操作信息。方便我们在清屏或退出终端后查询commit ID值 git checkout -- file 撤销工作区修改(add之前) git reset HEAD file 撤销暂存区修改(commit之前) rm file 删除本地文件 git rm file 删除git仓库中的文件 git branch 查看分支列表，绿色为当前分支 git branch 分支名 创建分支 git checkout 分支名 切换分支 git checkout -b 分支名 切换分支，若不存在则创建它 git log --graph --pretty=oneline --abbrev-commit 输出带分支信息的log列表 git merge 目标分支名 合并分支 git branch -d 分支名 删除分支 SSH 首先是 SSH，建议通过 SSH 而不是 https 克隆项目，有一些公司甚至可能会设置只允许通过 SSH 进行克隆。 检查本地是否存在配置 SSH 本地目录为 ~/.ssh，可以在 Finder 或终端中进到该文件夹，查看是否存在 id_rsa 和 id_rsa.pub 文件，来判断是否已经创建了 SSH 配置。如果您之前没有配置过 SSH，那么可能连这个文件夹都不存在。 新建 SSH 如果没有，那就需要新建。命令如下： $ ssh-keygen -t rsa -C &quot;your-email@emial.com&quot; 输入完这条命令之后，我们连着敲三个回车，不管它显示的什么，一直敲回车。直到下面出现一个图形。 之后就可以到 ~/.ssh 文件夹下查看是否多出了 id_rsa 和 id_rsa.pub 文件。 添加到远端 Git 平台 之后我们可以通过 cat 命令，或者直接打开 id_rsa.pub 文件，将其中的内容复制到 Git 平台的 SSH 配置中即可。 检查连通性 添加完成后，我们可以执行下面的命令检查本地和远端 Git 的 SSH 连通性。 $ ssh -T git@&lt;git url&gt; 敲回车后，如果你是第一次连接，会询问你yes or no，输入yes，然后输入 Git 的密码。如果一切都没问题，会返回欢迎信息。 Git 配置 配置好 SSH 之后，就可以回过头来配置 Git。 Mac 平台在安装了 Xcode 后自带 Git 服务。此时我们可以直接在终端输入下列命令进行 Git 配置： $ git config --global user.name &quot;Your Name&quot; $ git config --global user.email &quot;email@example.com&quot; 新建 Git 项目与远端克隆 一般很少有只在本地使用 Git 进行版本管理的场景，基本都会和远端 Git 结合一起使用。 那么我建议的流程是： 现在远端建立空项目 将远端项目克隆到本地 在克隆的文件夹下创建项目进行开发 有的人习惯本地有项目之后，再和远端项目进行关联。这里不介绍该种方法。 如果你本地已经有代码： 没有集成 Git 的情况下，在远端空项目克隆到本地后，直接将本地已有的代码移动到该空项目中即可。 如果已经集成了 Git，则可以修改项目文件夹下的 .git/config 文件，将文件中的 remote 里的 url 项改为远端 url 即可。该操作也适用于更换项目的远端地址。 克隆项目 克隆的命令非常简单，而且非常顾名思义。在某一目录下执行下面的指令，就可以将远程仓库里的内容全部克隆到本地该文件夹下。 $ git clone &lt;ssh链接&gt; 推送文件 可以使用下面的代码将本地项目 push 推送到远程仓库。 $ git push origin master 该命令实际上是把当前分支 master 推送到远程。 Git 常用操作 添加，提交文件 添加、提交文件的步骤为: $ git add xx.txt $ git commit -m &quot;注释信息&quot; add，添加的意思，把xx.txt添加到git仓库。 commit，提交的意思。后面的-m的内容，是一个描述性内容，用来描述我们这次提交的对文件做了哪些修改的。 注意: 可以使用 git add . 将所有文件一并 add，适合对多个文件进行修改的情况。一般直接用这个就可以。 在提交时，-m 可以先输入一个左单引号，敲回车后可以输入多行注释信息。然后再输入右单引号，完成注释信息的输入。 这个 add 命令实际上是可以一口气添加多个文件，然后一口气 commit。 修改文件 指令 作用 git status 查看Git仓库状态 git diff 查看文件与之前有何不同 版本回退 下面的表格是版本回退的具体指令。 指令 作用 git reset --hard HEAD^ 返回到上一个版本 git reset --hard HEAD~10 向前回滚10个版本 git reset --hard commit ID值 回滚到某个具体的版本 下面的表格可以为我们提供我们所需要的commit ID值。 指令 作用 git log --pretty=oneline 输出 commit 日志，包含作者，日期，提交说明，提交ID git reflog 输出所有的操作信息。方便我们在清屏或退出终端后查询commit ID值 撤销修改 在我们 push 到远程仓库之前，我们可以用下表的指令来撤销我们对仓库内文件做出的修改。恢复到上次提交的状态。 指令 作用 git checkout -- file 撤销工作区修改(add之前) git reset HEAD file 撤销暂存区修改(commit之前) git reset --hard HEAD^ 回滚到上一版本(push之前) 删除文件/文件夹 指令 作用 rm file 删除本地文件 git rm file 删除git仓库中的文件 git rm 文件夹名 -r -f 删除git和本地中该文件夹及其下文件 注意 在 git rm 之前，如果我们想撤销，可以放弃工作区修改，git checkout -- file。 在 git rm 之后，如果我们想撤销，直接 git reset --hard HEAD^ 回滚到上一个版本就可以了 在这里多说一句，如果想要删除Git仓库，我们用代码 rm -rf .git 删除**.git文件夹**就可以了。 创建并切换分支 创建分支与切换分支相关的命令如下表所示: 指令 作用 git branch 查看分支列表，绿色为当前分支 git branch 分支名 创建分支 git checkout 分支名 切换分支 git checkout -b 分支名 切换分支，若不存在则创建它 git log --graph --pretty=oneline --abbrev-commit 输出带分支信息的log列表 合并分支 在我们切换回master分支后，执行下面的命令，就可以用快速合并的模式将目标分支合并到master分支上。 $ git merge &lt;目标分支名&gt; 注意: 假如我们要将A分支，合并到 master 分支，那么我们必须先切换到master分支，然后再执行把A分支合并到 master 分支的操作。 介绍一个 git 指令 git ls-files，该指令可以查看当前 git 仓库下的文件。如果想验证新建文件是否合并成功，可以使用该指令。 删除分支 删除分支的命令如下所示。注意，这条命令可不是类似 branch rm 了。 $ git branch -d &lt;分支名&gt; 分支管理小结 关于分支管理的一般过程，我做了一个 GIF，如下图所示: 如图GIF演示了从创建分支到合并分支的过程，其中每一个圆饼代表着一次 commit。 参考 廖雪峰大神的blog ","link":"https://blog.rakuyoo.top/git/"}]}